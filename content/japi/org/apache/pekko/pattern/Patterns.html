<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.11) on Wed Feb 08 11:53:31 CET 2023 -->
<title>Patterns</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-02-08">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Patterns";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":41,"i3":9,"i4":41,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.pekko.pattern</a></div>
<h2 title="Class Patterns" class="title">Class Patterns</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.apache.pekko.pattern.Patterns</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">Patterns</span>
extends java.lang.Object</pre>
<div class="block">Java API: for Akka patterns such as <code>ask</code>, <code>pipe</code> and others which work with <code>CompletionStage</code>.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">Patterns</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#after(java.time.Duration,org.apache.pekko.actor.ClassicActorSystemProvider,java.util.concurrent.Callable)">after</a></span>&#8203;(java.time.Duration&nbsp;duration,
     <a href="../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;system,
     java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Returns a <code>CompletionStage</code> that will be completed with the success or failure of the provided Callable
 after the specified duration.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#after(java.time.Duration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext,java.util.concurrent.Callable)">after</a></span>&#8203;(java.time.Duration&nbsp;duration,
     <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
     scala.concurrent.ExecutionContext&nbsp;context,
     java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Returns a <code>CompletionStage</code> that will be completed with the success or failure of the provided Callable
 after the specified duration.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#after(java.time.Duration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext,java.util.concurrent.CompletionStage)">after</a></span>&#8203;(java.time.Duration&nbsp;duration,
     <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
     scala.concurrent.ExecutionContext&nbsp;context,
     java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;value)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts a Callable of CompletionStage instead.</div>
</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;scala.concurrent.Future&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#after(scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext,java.util.concurrent.Callable)">after</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;duration,
     <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
     scala.concurrent.ExecutionContext&nbsp;context,
     java.util.concurrent.Callable&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Returns a <code>Future</code> that will be completed with the success or failure of the provided Callable
 after the specified duration.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;scala.concurrent.Future&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#after(scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext,scala.concurrent.Future)">after</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;duration,
     <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
     scala.concurrent.ExecutionContext&nbsp;context,
     scala.concurrent.Future&lt;T&gt;&nbsp;value)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overload one which accepts a Callable of Future instead.</div>
</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static scala.concurrent.Future&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ask(org.apache.pekko.actor.ActorRef,java.lang.Object,long)">ask</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
   java.lang.Object&nbsp;message,
   long&nbsp;timeoutMillis)</code></th>
<td class="colLast">
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>Future</code>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the <code>sender</code> reference provided.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ask(org.apache.pekko.actor.ActorRef,java.lang.Object,java.time.Duration)">ask</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
   java.lang.Object&nbsp;message,
   java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>CompletionStage</code>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the <code>sender</code> reference provided.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static scala.concurrent.Future&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ask(org.apache.pekko.actor.ActorRef,java.lang.Object,org.apache.pekko.util.Timeout)">ask</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
   java.lang.Object&nbsp;message,
   <a href="../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>Future</code>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the <code>sender</code> reference provided.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static scala.concurrent.Future&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ask(org.apache.pekko.actor.ActorSelection,java.lang.Object,long)">ask</a></span>&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
   java.lang.Object&nbsp;message,
   long&nbsp;timeoutMillis)</code></th>
<td class="colLast">
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>Future</code>
 holding the eventual reply message; this means that the target <code>pekko.actor.ActorSelection</code>
 needs to send the result to the <code>sender</code> reference provided.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ask(org.apache.pekko.actor.ActorSelection,java.lang.Object,java.time.Duration)">ask</a></span>&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
   java.lang.Object&nbsp;message,
   java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>CompletionStage</code>
 holding the eventual reply message; this means that the target <code>pekko.actor.ActorSelection</code>
 needs to send the result to the <code>sender</code> reference provided.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static scala.concurrent.Future&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ask(org.apache.pekko.actor.ActorSelection,java.lang.Object,org.apache.pekko.util.Timeout)">ask</a></span>&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
   java.lang.Object&nbsp;message,
   <a href="../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>Future</code>
 holding the eventual reply message; this means that the target <code>pekko.actor.ActorSelection</code>
 needs to send the result to the <code>sender</code> reference provided.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#askWithReplyTo(org.apache.pekko.actor.ActorRef,org.apache.pekko.japi.function.Function,java.time.Duration)">askWithReplyTo</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
              <a href="../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
              java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static scala.concurrent.Future&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#askWithReplyTo(org.apache.pekko.actor.ActorRef,org.apache.pekko.japi.Function,long)">askWithReplyTo</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
              <a href="../japi/Function.html" title="interface in org.apache.pekko.japi">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
              long&nbsp;timeoutMillis)</code></th>
<td class="colLast">
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static scala.concurrent.Future&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#askWithReplyTo(org.apache.pekko.actor.ActorRef,org.apache.pekko.japi.Function,org.apache.pekko.util.Timeout)">askWithReplyTo</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
              <a href="../japi/Function.html" title="interface in org.apache.pekko.japi">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
              <a href="../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static scala.concurrent.Future&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#askWithReplyTo(org.apache.pekko.actor.ActorSelection,org.apache.pekko.japi.Function,long)">askWithReplyTo</a></span>&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
              <a href="../japi/Function.html" title="interface in org.apache.pekko.japi">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
              long&nbsp;timeoutMillis)</code></th>
<td class="colLast">
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#askWithReplyTo(org.apache.pekko.actor.ActorSelection,org.apache.pekko.japi.Function,java.time.Duration)">askWithReplyTo</a></span>&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
              <a href="../japi/Function.html" title="interface in org.apache.pekko.japi">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
              java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#askWithStatus(org.apache.pekko.actor.ActorRef,java.lang.Object,java.time.Duration)">askWithStatus</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
             java.lang.Object&nbsp;message,
             java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">Use for messages whose response is known to be a <code>pekko.pattern.StatusReply</code>.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static java.util.concurrent.CompletionStage&lt;java.lang.Boolean&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#gracefulStop(org.apache.pekko.actor.ActorRef,java.time.Duration)">gracefulStop</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;target,
            java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">Returns a <code>CompletionStage</code> that will be completed with success (value <code>true</code>) when
 existing messages of the target actor has been processed and the actor has been
 terminated.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static java.util.concurrent.CompletionStage&lt;java.lang.Boolean&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#gracefulStop(org.apache.pekko.actor.ActorRef,java.time.Duration,java.lang.Object)">gracefulStop</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;target,
            java.time.Duration&nbsp;timeout,
            java.lang.Object&nbsp;stopMessage)</code></th>
<td class="colLast">
<div class="block">Returns a <code>CompletionStage</code> that will be completed with success (value <code>true</code>) when
 existing messages of the target actor has been processed and the actor has been
 terminated.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static scala.concurrent.Future&lt;java.lang.Boolean&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#gracefulStop(org.apache.pekko.actor.ActorRef,scala.concurrent.duration.FiniteDuration)">gracefulStop</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;target,
            scala.concurrent.duration.FiniteDuration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">Returns a <code>Future</code> that will be completed with success (value <code>true</code>) when
 existing messages of the target actor has been processed and the actor has been
 terminated.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static scala.concurrent.Future&lt;java.lang.Boolean&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#gracefulStop(org.apache.pekko.actor.ActorRef,scala.concurrent.duration.FiniteDuration,java.lang.Object)">gracefulStop</a></span>&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;target,
            scala.concurrent.duration.FiniteDuration&nbsp;timeout,
            java.lang.Object&nbsp;stopMessage)</code></th>
<td class="colLast">
<div class="block">Returns a <code>Future</code> that will be completed with success (value <code>true</code>) when
 existing messages of the target actor has been processed and the actor has been
 terminated.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="PipeToSupport.PipeableCompletionStage.html" title="class in org.apache.pekko.pattern">PipeToSupport.PipeableCompletionStage</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pipe(java.util.concurrent.CompletionStage,scala.concurrent.ExecutionContext)">pipe</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;future,
    scala.concurrent.ExecutionContext&nbsp;context)</code></th>
<td class="colLast">
<div class="block">When this <code>CompletionStage</code> finishes, send its result to the given
 <code>pekko.actor.ActorRef</code> or <code>pekko.actor.ActorSelection</code>.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="PipeToSupport.PipeableFuture.html" title="class in org.apache.pekko.pattern">PipeToSupport.PipeableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pipe(scala.concurrent.Future,scala.concurrent.ExecutionContext)">pipe</a></span>&#8203;(scala.concurrent.Future&lt;T&gt;&nbsp;future,
    scala.concurrent.ExecutionContext&nbsp;context)</code></th>
<td class="colLast">
<div class="block">Register an onComplete callback on this <code>Future</code> to send
 the result to the given <code>pekko.actor.ActorRef</code> or <code>pekko.actor.ActorSelection</code>.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(java.util.concurrent.Callable,int,java.time.Duration,java.time.Duration,double,org.apache.pekko.actor.ClassicActorSystemProvider)">retry</a></span>&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
     int&nbsp;attempts,
     java.time.Duration&nbsp;minBackoff,
     java.time.Duration&nbsp;maxBackoff,
     double&nbsp;randomFactor,
     <a href="../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;system)</code></th>
<td class="colLast">
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, each subsequent attempt will be made with a backoff time,
 if the previous attempt failed.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(java.util.concurrent.Callable,int,java.time.Duration,java.time.Duration,double,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext)">retry</a></span>&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
     int&nbsp;attempts,
     java.time.Duration&nbsp;minBackoff,
     java.time.Duration&nbsp;maxBackoff,
     double&nbsp;randomFactor,
     <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
     scala.concurrent.ExecutionContext&nbsp;ec)</code></th>
<td class="colLast">
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, each subsequent attempt will be made with a backoff time,
 if the previous attempt failed.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(java.util.concurrent.Callable,int,java.time.Duration,org.apache.pekko.actor.ClassicActorSystemProvider)">retry</a></span>&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
     int&nbsp;attempts,
     java.time.Duration&nbsp;delay,
     <a href="../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;system)</code></th>
<td class="colLast">
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, and each subsequent attempt will be made after 'delay'.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(java.util.concurrent.Callable,int,java.time.Duration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext)">retry</a></span>&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
     int&nbsp;attempts,
     java.time.Duration&nbsp;delay,
     <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
     scala.concurrent.ExecutionContext&nbsp;ec)</code></th>
<td class="colLast">
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, and each subsequent attempt will be made after 'delay'.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(java.util.concurrent.Callable,int,java.util.function.IntFunction,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext)">retry</a></span>&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
     int&nbsp;attempts,
     java.util.function.IntFunction&lt;java.util.Optional&lt;java.time.Duration&gt;&gt;&nbsp;delayFunction,
     <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
     scala.concurrent.ExecutionContext&nbsp;context)</code></th>
<td class="colLast">
<div class="block">Returns an internally retrying <code>CompletionStage</code>.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(java.util.concurrent.Callable,int,scala.concurrent.ExecutionContext)">retry</a></span>&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
     int&nbsp;attempts,
     scala.concurrent.ExecutionContext&nbsp;ec)</code></th>
<td class="colLast">
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, each subsequent attempt will be made immediately
 if the previous attempt failed.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;scala.concurrent.Future&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(java.util.concurrent.Callable,int,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext)">retry</a></span>&#8203;(java.util.concurrent.Callable&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;attempt,
     int&nbsp;attempts,
     scala.concurrent.duration.FiniteDuration&nbsp;delay,
     <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
     scala.concurrent.ExecutionContext&nbsp;context)</code></th>
<td class="colLast">
<div class="block">Returns an internally retrying <code>Future</code>
 The first attempt will be made immediately, and each subsequent attempt will be made after 'delay'.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Patterns</h4>
<pre>public&nbsp;Patterns()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="ask(org.apache.pekko.actor.ActorRef,java.lang.Object,org.apache.pekko.util.Timeout)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre class="methodSignature">public static&nbsp;scala.concurrent.Future&lt;java.lang.Object&gt;&nbsp;ask&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
                                                            java.lang.Object&nbsp;message,
                                                            <a href="../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</pre>
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>Future</code>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the <code>sender</code> reference provided.
 <p>
 The Future will be completed with an <code>pekko.pattern.AskTimeoutException</code> after the
 given timeout has expired; this is independent from any timeout applied
 while awaiting a result for this future (i.e. in
 <code>Await.result(..., timeout)</code>). A typical reason for <code>AskTimeoutException</code> is that the
 recipient actor didn't send a reply.
 <p>
 <b>Warning:</b>
 When using future callbacks, inside actors you need to carefully avoid closing over
 the containing actor&amp;rsquo;s object, i.e. do not call methods or access mutable state
 on the enclosing actor from within the callback. This would break the actor
 encapsulation and may introduce synchronization bugs and race conditions because
 the callback will be scheduled concurrently to the enclosing actor. Unfortunately
 there is not yet a way to detect these illegal accesses at compile time.
 <p>
 <b>Recommended usage:</b>
 <p>
 <pre><code>
   final Future&lt;Object&gt; f = Patterns.ask(worker, request, timeout);
   f.onSuccess(new Procedure&lt;Object&gt;() {
     public void apply(Object o) {
       nextActor.tell(new EnrichedResult(request, o));
     }
   });
 </code></pre></div>
</li>
</ul>
<a id="ask(org.apache.pekko.actor.ActorRef,java.lang.Object,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre class="methodSignature">public static&nbsp;java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;&nbsp;ask&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
                                                                         java.lang.Object&nbsp;message,
                                                                         java.time.Duration&nbsp;timeout)</pre>
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>CompletionStage</code>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the <code>sender</code> reference provided.
 <p>
 The CompletionStage will be completed with an <code>pekko.pattern.AskTimeoutException</code> after the
 given timeout has expired; this is independent from any timeout applied
 while awaiting a result for this future (i.e. in
 <code>Await.result(..., timeout)</code>). A typical reason for <code>AskTimeoutException</code> is that the
 recipient actor didn't send a reply.
 <p>
 <b>Warning:</b>
 When using future callbacks, inside actors you need to carefully avoid closing over
 the containing actor&amp;rsquo;s object, i.e. do not call methods or access mutable state
 on the enclosing actor from within the callback. This would break the actor
 encapsulation and may introduce synchronization bugs and race conditions because
 the callback will be scheduled concurrently to the enclosing actor. Unfortunately
 there is not yet a way to detect these illegal accesses at compile time.
 <p>
 <b>Recommended usage:</b>
 <p>
 <pre><code>
   final CompletionStage&lt;Object&gt; f = Patterns.ask(worker, request, duration);
   f.thenRun(result -&gt; nextActor.tell(new EnrichedResult(request, result)));
 </code></pre></div>
</li>
</ul>
<a id="askWithStatus(org.apache.pekko.actor.ActorRef,java.lang.Object,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>askWithStatus</h4>
<pre class="methodSignature">public static&nbsp;java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;&nbsp;askWithStatus&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
                                                                                   java.lang.Object&nbsp;message,
                                                                                   java.time.Duration&nbsp;timeout)</pre>
<div class="block">Use for messages whose response is known to be a <code>pekko.pattern.StatusReply</code>. When a <code>pekko.pattern.StatusReply#success</code> response
 arrives the future is completed with the wrapped value, if a <code>pekko.pattern.StatusReply#error</code> arrives the future is instead
 failed.</div>
</li>
</ul>
<a id="askWithReplyTo(org.apache.pekko.actor.ActorRef,org.apache.pekko.japi.Function,org.apache.pekko.util.Timeout)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>askWithReplyTo</h4>
<pre class="methodSignature">public static&nbsp;scala.concurrent.Future&lt;java.lang.Object&gt;&nbsp;askWithReplyTo&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
                                                                       <a href="../japi/Function.html" title="interface in org.apache.pekko.japi">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
                                                                       <a href="../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</pre>
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.
 <p>
 <pre><code>
 final Future&lt;Object&gt; f = Patterns.askWithReplyTo(
   worker,
   replyTo -&gt; new Request(replyTo),
   timeout);
 </code></pre></div>
</li>
</ul>
<a id="askWithReplyTo(org.apache.pekko.actor.ActorRef,org.apache.pekko.japi.function.Function,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>askWithReplyTo</h4>
<pre class="methodSignature">public static&nbsp;java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;&nbsp;askWithReplyTo&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
                                                                                    <a href="../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
                                                                                    java.time.Duration&nbsp;timeout)</pre>
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.
 <p>
 <pre><code>
 final CompletionStage&lt;Object&gt; f = Patterns.askWithReplyTo(
   worker,
   askSender -&gt; new Request(askSender),
   timeout);
 </code></pre>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>actor</code> - the actor to be asked</dd>
<dd><code>messageFactory</code> - function taking an actor ref and returning the message to be sent</dd>
<dd><code>timeout</code> - the timeout for the response before failing the returned completion stage</dd>
</dl>
</li>
</ul>
<a id="ask(org.apache.pekko.actor.ActorRef,java.lang.Object,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre class="methodSignature">public static&nbsp;scala.concurrent.Future&lt;java.lang.Object&gt;&nbsp;ask&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
                                                            java.lang.Object&nbsp;message,
                                                            long&nbsp;timeoutMillis)</pre>
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>Future</code>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the <code>sender</code> reference provided.
 <p>
 The Future will be completed with an <code>pekko.pattern.AskTimeoutException</code> after the
 given timeout has expired; this is independent from any timeout applied
 while awaiting a result for this future (i.e. in
 <code>Await.result(..., timeout)</code>). A typical reason for <code>AskTimeoutException</code> is that the
 recipient actor didn't send a reply.
 <p>
 <b>Warning:</b>
 When using future callbacks, inside actors you need to carefully avoid closing over
 the containing actor&amp;rsquo;s object, i.e. do not call methods or access mutable state
 on the enclosing actor from within the callback. This would break the actor
 encapsulation and may introduce synchronization bugs and race conditions because
 the callback will be scheduled concurrently to the enclosing actor. Unfortunately
 there is not yet a way to detect these illegal accesses at compile time.
 <p>
 <b>Recommended usage:</b>
 <p>
 <pre><code>
   final Future&lt;Object&gt; f = Patterns.ask(worker, request, timeout);
   f.onSuccess(new Procedure&lt;Object&gt;() {
     public void apply(Object o) {
       nextActor.tell(new EnrichedResult(request, o));
     }
   });
 </code></pre></div>
</li>
</ul>
<a id="askWithReplyTo(org.apache.pekko.actor.ActorRef,org.apache.pekko.japi.Function,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>askWithReplyTo</h4>
<pre class="methodSignature">public static&nbsp;scala.concurrent.Future&lt;java.lang.Object&gt;&nbsp;askWithReplyTo&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;actor,
                                                                       <a href="../japi/Function.html" title="interface in org.apache.pekko.japi">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
                                                                       long&nbsp;timeoutMillis)</pre>
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.
 <p>
 <pre><code>
 final Future&lt;Object&gt; f = Patterns.askWithReplyTo(
   worker,
   replyTo -&gt; new Request(replyTo),
   timeout);
 </code></pre></div>
</li>
</ul>
<a id="ask(org.apache.pekko.actor.ActorSelection,java.lang.Object,org.apache.pekko.util.Timeout)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre class="methodSignature">public static&nbsp;scala.concurrent.Future&lt;java.lang.Object&gt;&nbsp;ask&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
                                                            java.lang.Object&nbsp;message,
                                                            <a href="../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</pre>
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>Future</code>
 holding the eventual reply message; this means that the target <code>pekko.actor.ActorSelection</code>
 needs to send the result to the <code>sender</code> reference provided.
 <p>
 The Future will be completed with an <code>pekko.pattern.AskTimeoutException</code> after the
 given timeout has expired; this is independent from any timeout applied
 while awaiting a result for this future (i.e. in
 <code>Await.result(..., timeout)</code>). A typical reason for <code>AskTimeoutException</code> is that the
 recipient actor didn't send a reply.
 <p>
 <b>Warning:</b>
 When using future callbacks, inside actors you need to carefully avoid closing over
 the containing actor&amp;rsquo;s object, i.e. do not call methods or access mutable state
 on the enclosing actor from within the callback. This would break the actor
 encapsulation and may introduce synchronization bugs and race conditions because
 the callback will be scheduled concurrently to the enclosing actor. Unfortunately
 there is not yet a way to detect these illegal accesses at compile time.
 <p>
 <b>Recommended usage:</b>
 <p>
 <pre><code>
   final Future&lt;Object&gt; f = Patterns.ask(selection, request, timeout);
   f.onSuccess(new Procedure&lt;Object&gt;() {
     public void apply(Object o) {
       nextActor.tell(new EnrichedResult(request, o));
     }
   });
 </code></pre></div>
</li>
</ul>
<a id="ask(org.apache.pekko.actor.ActorSelection,java.lang.Object,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre class="methodSignature">public static&nbsp;java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;&nbsp;ask&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
                                                                         java.lang.Object&nbsp;message,
                                                                         java.time.Duration&nbsp;timeout)</pre>
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>CompletionStage</code>
 holding the eventual reply message; this means that the target <code>pekko.actor.ActorSelection</code>
 needs to send the result to the <code>sender</code> reference provided.
 <p>
 The CompletionStage will be completed with an <code>pekko.pattern.AskTimeoutException</code> after the
 given timeout has expired; this is independent from any timeout applied
 while awaiting a result for this future (i.e. in
 <code>Await.result(..., timeout)</code>). A typical reason for <code>AskTimeoutException</code> is that the
 recipient actor didn't send a reply.
 <p>
 <b>Warning:</b>
 When using future callbacks, inside actors you need to carefully avoid closing over
 the containing actor&amp;rsquo;s object, i.e. do not call methods or access mutable state
 on the enclosing actor from within the callback. This would break the actor
 encapsulation and may introduce synchronization bugs and race conditions because
 the callback will be scheduled concurrently to the enclosing actor. Unfortunately
 there is not yet a way to detect these illegal accesses at compile time.
 <p>
 <b>Recommended usage:</b>
 <p>
 <pre><code>
   final CompletionStage&lt;Object&gt; f = Patterns.ask(selection, request, duration);
   f.thenRun(result -&gt; nextActor.tell(new EnrichedResult(request, result)));
 </code></pre></div>
</li>
</ul>
<a id="ask(org.apache.pekko.actor.ActorSelection,java.lang.Object,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre class="methodSignature">public static&nbsp;scala.concurrent.Future&lt;java.lang.Object&gt;&nbsp;ask&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
                                                            java.lang.Object&nbsp;message,
                                                            long&nbsp;timeoutMillis)</pre>
<div class="block"><i>Java API for <code>org.apache.pekko.pattern.ask</code>:</i>
 Sends a message asynchronously and returns a <code>Future</code>
 holding the eventual reply message; this means that the target <code>pekko.actor.ActorSelection</code>
 needs to send the result to the <code>sender</code> reference provided.
 <p>
 The Future will be completed with an <code>pekko.pattern.AskTimeoutException</code> after the
 given timeout has expired; this is independent from any timeout applied
 while awaiting a result for this future (i.e. in
 <code>Await.result(..., timeout)</code>). A typical reason for <code>AskTimeoutException</code> is that the
 recipient actor didn't send a reply.
 <p>
 <b>Warning:</b>
 When using future callbacks, inside actors you need to carefully avoid closing over
 the containing actor&amp;rsquo;s object, i.e. do not call methods or access mutable state
 on the enclosing actor from within the callback. This would break the actor
 encapsulation and may introduce synchronization bugs and race conditions because
 the callback will be scheduled concurrently to the enclosing actor. Unfortunately
 there is not yet a way to detect these illegal accesses at compile time.
 <p>
 <b>Recommended usage:</b>
 <p>
 <pre><code>
   final Future&lt;Object&gt; f = Patterns.ask(selection, request, timeout);
   f.onSuccess(new Procedure&lt;Object&gt;() {
     public void apply(Object o) {
       nextActor.tell(new EnrichedResult(request, o));
     }
   });
 </code></pre></div>
</li>
</ul>
<a id="askWithReplyTo(org.apache.pekko.actor.ActorSelection,org.apache.pekko.japi.Function,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>askWithReplyTo</h4>
<pre class="methodSignature">public static&nbsp;scala.concurrent.Future&lt;java.lang.Object&gt;&nbsp;askWithReplyTo&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
                                                                       <a href="../japi/Function.html" title="interface in org.apache.pekko.japi">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
                                                                       long&nbsp;timeoutMillis)</pre>
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.
 <p>
 <pre><code>
 final Future&lt;Object&gt; f = Patterns.askWithReplyTo(
   selection,
   replyTo -&gt; new Request(replyTo),
   timeout);
 </code></pre></div>
</li>
</ul>
<a id="askWithReplyTo(org.apache.pekko.actor.ActorSelection,org.apache.pekko.japi.Function,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>askWithReplyTo</h4>
<pre class="methodSignature">public static&nbsp;java.util.concurrent.CompletionStage&lt;java.lang.Object&gt;&nbsp;askWithReplyTo&#8203;(<a href="../actor/ActorSelection.html" title="class in org.apache.pekko.actor">ActorSelection</a>&nbsp;selection,
                                                                                    <a href="../japi/Function.html" title="interface in org.apache.pekko.japi">Function</a>&lt;<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>,&#8203;java.lang.Object&gt;&nbsp;messageFactory,
                                                                                    java.time.Duration&nbsp;timeout)</pre>
<div class="block">A variation of ask which allows to implement "replyTo" pattern by including
 sender reference in message.
 <p>
 <pre><code>
 final CompletionStage&lt;Object&gt; f = Patterns.askWithReplyTo(
   selection,
   replyTo -&gt; new Request(replyTo),
   timeout);
 </code></pre></div>
</li>
</ul>
<a id="pipe(scala.concurrent.Future,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pipe</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="PipeToSupport.PipeableFuture.html" title="class in org.apache.pekko.pattern">PipeToSupport.PipeableFuture</a>&lt;T&gt;&nbsp;pipe&#8203;(scala.concurrent.Future&lt;T&gt;&nbsp;future,
                                                       scala.concurrent.ExecutionContext&nbsp;context)</pre>
<div class="block">Register an onComplete callback on this <code>Future</code> to send
 the result to the given <code>pekko.actor.ActorRef</code> or <code>pekko.actor.ActorSelection</code>.
 Returns the original Future to allow method chaining.
 If the future was completed with failure it is sent as a <code>pekko.actor.Status.Failure</code>
 to the recipient.
 <p>
 <b>Recommended usage example:</b>
 <p>
 <pre><code>
   final Future&lt;Object&gt; f = Patterns.ask(worker, request, timeout);
   // apply some transformation (i.e. enrich with request info)
   final Future&lt;Object&gt; transformed = f.map(new org.apache.pekko.japi.Function&lt;Object, Object&gt;() { ... });
   // send it on to the next operator
   Patterns.pipe(transformed, context).to(nextActor);
 </code></pre></div>
</li>
</ul>
<a id="pipe(java.util.concurrent.CompletionStage,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pipe</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="PipeToSupport.PipeableCompletionStage.html" title="class in org.apache.pekko.pattern">PipeToSupport.PipeableCompletionStage</a>&lt;T&gt;&nbsp;pipe&#8203;(java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;future,
                                                                scala.concurrent.ExecutionContext&nbsp;context)</pre>
<div class="block">When this <code>CompletionStage</code> finishes, send its result to the given
 <code>pekko.actor.ActorRef</code> or <code>pekko.actor.ActorSelection</code>.
 Returns the original CompletionStage to allow method chaining.
 If the future was completed with failure it is sent as a <code>pekko.actor.Status.Failure</code>
 to the recipient.
 <p>
 <b>Recommended usage example:</b>
 <p>
 <pre><code>
   final CompletionStage&lt;Object&gt; f = Patterns.ask(worker, request, timeout);
   // apply some transformation (i.e. enrich with request info)
   final CompletionStage&lt;Object&gt; transformed = f.thenApply(result -&gt; { ... });
   // send it on to the next operator
   Patterns.pipe(transformed, context).to(nextActor);
 </code></pre></div>
</li>
</ul>
<a id="gracefulStop(org.apache.pekko.actor.ActorRef,scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gracefulStop</h4>
<pre class="methodSignature">public static&nbsp;scala.concurrent.Future&lt;java.lang.Boolean&gt;&nbsp;gracefulStop&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;target,
                                                                      scala.concurrent.duration.FiniteDuration&nbsp;timeout)</pre>
<div class="block">Returns a <code>Future</code> that will be completed with success (value <code>true</code>) when
 existing messages of the target actor has been processed and the actor has been
 terminated.
 <p>
 Useful when you need to wait for termination or compose ordered termination of several actors.
 <p>
 If the target actor isn't terminated within the timeout the <code>Future</code>
 is completed with failure <code>pekko.pattern.AskTimeoutException</code>.</div>
</li>
</ul>
<a id="gracefulStop(org.apache.pekko.actor.ActorRef,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gracefulStop</h4>
<pre class="methodSignature">public static&nbsp;java.util.concurrent.CompletionStage&lt;java.lang.Boolean&gt;&nbsp;gracefulStop&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;target,
                                                                                   java.time.Duration&nbsp;timeout)</pre>
<div class="block">Returns a <code>CompletionStage</code> that will be completed with success (value <code>true</code>) when
 existing messages of the target actor has been processed and the actor has been
 terminated.
 <p>
 Useful when you need to wait for termination or compose ordered termination of several actors.
 <p>
 If the target actor isn't terminated within the timeout the <code>CompletionStage</code>
 is completed with failure <code>pekko.pattern.AskTimeoutException</code>.</div>
</li>
</ul>
<a id="gracefulStop(org.apache.pekko.actor.ActorRef,scala.concurrent.duration.FiniteDuration,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gracefulStop</h4>
<pre class="methodSignature">public static&nbsp;scala.concurrent.Future&lt;java.lang.Boolean&gt;&nbsp;gracefulStop&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;target,
                                                                      scala.concurrent.duration.FiniteDuration&nbsp;timeout,
                                                                      java.lang.Object&nbsp;stopMessage)</pre>
<div class="block">Returns a <code>Future</code> that will be completed with success (value <code>true</code>) when
 existing messages of the target actor has been processed and the actor has been
 terminated.
 <p>
 Useful when you need to wait for termination or compose ordered termination of several actors.
 <p>
 If you want to invoke specialized stopping logic on your target actor instead of PoisonPill, you can pass your
 stop command as <code>stopMessage</code> parameter
 <p>
 If the target actor isn't terminated within the timeout the <code>Future</code>
 is completed with failure <code>pekko.pattern.AskTimeoutException</code>.</div>
</li>
</ul>
<a id="gracefulStop(org.apache.pekko.actor.ActorRef,java.time.Duration,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gracefulStop</h4>
<pre class="methodSignature">public static&nbsp;java.util.concurrent.CompletionStage&lt;java.lang.Boolean&gt;&nbsp;gracefulStop&#8203;(<a href="../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;target,
                                                                                   java.time.Duration&nbsp;timeout,
                                                                                   java.lang.Object&nbsp;stopMessage)</pre>
<div class="block">Returns a <code>CompletionStage</code> that will be completed with success (value <code>true</code>) when
 existing messages of the target actor has been processed and the actor has been
 terminated.
 <p>
 Useful when you need to wait for termination or compose ordered termination of several actors.
 <p>
 If you want to invoke specialized stopping logic on your target actor instead of PoisonPill, you can pass your
 stop command as <code>stopMessage</code> parameter
 <p>
 If the target actor isn't terminated within the timeout the <code>CompletionStage</code>
 is completed with failure <code>pekko.pattern.AskTimeoutException</code>.</div>
</li>
</ul>
<a id="after(scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext,java.util.concurrent.Callable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>after</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;scala.concurrent.Future&lt;T&gt;&nbsp;after&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;duration,
                                                   <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
                                                   scala.concurrent.ExecutionContext&nbsp;context,
                                                   java.util.concurrent.Callable&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;value)</pre>
<div class="block">Returns a <code>Future</code> that will be completed with the success or failure of the provided Callable
 after the specified duration.</div>
</li>
</ul>
<a id="after(java.time.Duration,org.apache.pekko.actor.ClassicActorSystemProvider,java.util.concurrent.Callable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>after</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;after&#8203;(java.time.Duration&nbsp;duration,
                                                                <a href="../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;system,
                                                                java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;value)</pre>
<div class="block">Returns a <code>CompletionStage</code> that will be completed with the success or failure of the provided Callable
 after the specified duration.</div>
</li>
</ul>
<a id="after(java.time.Duration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext,java.util.concurrent.Callable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>after</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;after&#8203;(java.time.Duration&nbsp;duration,
                                                                <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
                                                                scala.concurrent.ExecutionContext&nbsp;context,
                                                                java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;value)</pre>
<div class="block">Returns a <code>CompletionStage</code> that will be completed with the success or failure of the provided Callable
 after the specified duration.</div>
</li>
</ul>
<a id="after(scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext,scala.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>after</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;scala.concurrent.Future&lt;T&gt;&nbsp;after&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;duration,
                                                   <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
                                                   scala.concurrent.ExecutionContext&nbsp;context,
                                                   scala.concurrent.Future&lt;T&gt;&nbsp;value)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overload one which accepts a Callable of Future instead. Since 2.5.22.</div>
</div>
<div class="block">Returns a <code>Future</code> that will be completed with the success or failure of the provided Callable
 after the specified duration.</div>
</li>
</ul>
<a id="after(java.time.Duration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext,java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>after</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;after&#8203;(java.time.Duration&nbsp;duration,
                                                                <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
                                                                scala.concurrent.ExecutionContext&nbsp;context,
                                                                java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;value)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts a Callable of CompletionStage instead. Since 2.5.22.</div>
</div>
<div class="block">Returns a <code>CompletionStage</code> that will be completed with the success or failure of the provided value
 after the specified duration.</div>
</li>
</ul>
<a id="retry(java.util.concurrent.Callable,int,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;retry&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
                                                                int&nbsp;attempts,
                                                                scala.concurrent.ExecutionContext&nbsp;ec)</pre>
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, each subsequent attempt will be made immediately
 if the previous attempt failed.
 <p>
 If attempts are exhausted the returned completion operator is simply the result of invoking attempt.
 Note that the attempt function will be invoked on the given execution context for subsequent tries
 and therefore must be thread safe (not touch unsafe mutable state).</div>
</li>
</ul>
<a id="retry(java.util.concurrent.Callable,int,java.time.Duration,java.time.Duration,double,org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;retry&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
                                                                int&nbsp;attempts,
                                                                java.time.Duration&nbsp;minBackoff,
                                                                java.time.Duration&nbsp;maxBackoff,
                                                                double&nbsp;randomFactor,
                                                                <a href="../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;system)</pre>
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, each subsequent attempt will be made with a backoff time,
 if the previous attempt failed.
 <p>
 If attempts are exhausted the returned future is simply the result of invoking attempt.
 Note that the attempt function will be invoked on the given execution context for subsequent tries and
 therefore must be thread safe (not touch unsafe mutable state).
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>minBackoff</code> - minimum (initial) duration until the child actor will
                     started again, if it is terminated</dd>
<dd><code>maxBackoff</code> - the exponential back-off is capped to this duration</dd>
<dd><code>randomFactor</code> - after calculation of the exponential back-off an additional
                     random delay based on this factor is added, e.g. <code>0.2</code> adds up to <code>20%</code> delay.
                     In order to skip this additional delay pass in <code>0</code>.</dd>
</dl>
</li>
</ul>
<a id="retry(java.util.concurrent.Callable,int,java.time.Duration,java.time.Duration,double,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;retry&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
                                                                int&nbsp;attempts,
                                                                java.time.Duration&nbsp;minBackoff,
                                                                java.time.Duration&nbsp;maxBackoff,
                                                                double&nbsp;randomFactor,
                                                                <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
                                                                scala.concurrent.ExecutionContext&nbsp;ec)</pre>
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, each subsequent attempt will be made with a backoff time,
 if the previous attempt failed.
 <p>
 If attempts are exhausted the returned future is simply the result of invoking attempt.
 Note that the attempt function will be invoked on the given execution context for subsequent tries and
 therefore must be thread safe (not touch unsafe mutable state).
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>minBackoff</code> - minimum (initial) duration until the child actor will
                     started again, if it is terminated</dd>
<dd><code>maxBackoff</code> - the exponential back-off is capped to this duration</dd>
<dd><code>randomFactor</code> - after calculation of the exponential back-off an additional
                     random delay based on this factor is added, e.g. <code>0.2</code> adds up to <code>20%</code> delay.
                     In order to skip this additional delay pass in <code>0</code>.</dd>
</dl>
</li>
</ul>
<a id="retry(java.util.concurrent.Callable,int,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;scala.concurrent.Future&lt;T&gt;&nbsp;retry&#8203;(java.util.concurrent.Callable&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;attempt,
                                                   int&nbsp;attempts,
                                                   scala.concurrent.duration.FiniteDuration&nbsp;delay,
                                                   <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
                                                   scala.concurrent.ExecutionContext&nbsp;context)</pre>
<div class="block">Returns an internally retrying <code>Future</code>
 The first attempt will be made immediately, and each subsequent attempt will be made after 'delay'.
 A scheduler (eg context.system.scheduler) must be provided to delay each retry
 <p>
 If attempts are exhausted the returned future is simply the result of invoking attempt.
 Note that the attempt function will be invoked on the given execution context for subsequent tries and
 therefore must be thread safe (not touch unsafe mutable state).</div>
</li>
</ul>
<a id="retry(java.util.concurrent.Callable,int,java.time.Duration,org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;retry&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
                                                                int&nbsp;attempts,
                                                                java.time.Duration&nbsp;delay,
                                                                <a href="../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;system)</pre>
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, and each subsequent attempt will be made after 'delay'.
 A scheduler (eg context.system.scheduler) must be provided to delay each retry
 <p>
 If attempts are exhausted the returned completion operator is simply the result of invoking attempt.
 Note that the attempt function will be invoked on the given execution context for subsequent tries
 and therefore must be thread safe (not touch unsafe mutable state).</div>
</li>
</ul>
<a id="retry(java.util.concurrent.Callable,int,java.time.Duration,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;retry&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
                                                                int&nbsp;attempts,
                                                                java.time.Duration&nbsp;delay,
                                                                <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
                                                                scala.concurrent.ExecutionContext&nbsp;ec)</pre>
<div class="block">Returns an internally retrying <code>CompletionStage</code>
 The first attempt will be made immediately, and each subsequent attempt will be made after 'delay'.
 A scheduler (eg context.system.scheduler) must be provided to delay each retry
 <p>
 If attempts are exhausted the returned completion operator is simply the result of invoking attempt.
 Note that the attempt function will be invoked on the given execution context for subsequent tries
 and therefore must be thread safe (not touch unsafe mutable state).</div>
</li>
</ul>
<a id="retry(java.util.concurrent.Callable,int,java.util.function.IntFunction,org.apache.pekko.actor.Scheduler,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;retry&#8203;(java.util.concurrent.Callable&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;attempt,
                                                                int&nbsp;attempts,
                                                                java.util.function.IntFunction&lt;java.util.Optional&lt;java.time.Duration&gt;&gt;&nbsp;delayFunction,
                                                                <a href="../actor/Scheduler.html" title="interface in org.apache.pekko.actor">Scheduler</a>&nbsp;scheduler,
                                                                scala.concurrent.ExecutionContext&nbsp;context)</pre>
<div class="block">Returns an internally retrying <code>CompletionStage</code>.
 The first attempt will be made immediately, each subsequent attempt will be made after
 the 'delay' return by <code>delayFunction</code>(the input next attempt count start from 1).
 Return an empty <code>Optional</code> instance for no delay.
 A scheduler (eg context.system.scheduler) must be provided to delay each retry.
 You could provide a function to generate the next delay duration after first attempt,
 this function should never return <code>null</code>, otherwise an <code>IllegalArgumentException</code> will be through.
 <p>
 If attempts are exhausted the returned future is simply the result of invoking attempt.
 Note that the attempt function will be invoked on the given execution context for subsequent tries and
 therefore must be thread safe (not touch unsafe mutable state).</div>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
