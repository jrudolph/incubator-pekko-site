<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.11) on Wed Feb 08 11:53:31 CET 2023 -->
<title>Tcp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-02-08">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Tcp";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":42,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":42,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":42,"i40":42,"i41":10,"i42":10,"i43":10,"i44":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.pekko.stream.scaladsl</a></div>
<h2 title="Class Tcp" class="title">Class Tcp</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.apache.pekko.stream.scaladsl.Tcp</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="../../actor/Extension.html" title="interface in org.apache.pekko.actor">Extension</a></code></dd>
</dl>
<hr>
<pre>public final class <span class="typeNameLabel">Tcp</span>
extends java.lang.Object
implements <a href="../../actor/Extension.html" title="interface in org.apache.pekko.actor">Extension</a></pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Tcp.IncomingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection</a></span></code></th>
<td class="colLast">
<div class="block">Represents an accepted incoming TCP connection.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Tcp.IncomingConnection$.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection$</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a></span></code></th>
<td class="colLast">
<div class="block">Represents a prospective outgoing TCP connection.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Tcp.OutgoingConnection$.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection$</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a></span></code></th>
<td class="colLast">
<div class="block">Represents a successful TCP server binding.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Tcp.ServerBinding$.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding$</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(org.apache.pekko.actor.ExtendedActorSystem)">Tcp</a></span>&#8203;(<a href="../../actor/ExtendedActorSystem.html" title="class in org.apache.pekko.actor">ExtendedActorSystem</a>&nbsp;system)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static <a href="Tcp.html" title="class in org.apache.pekko.stream.scaladsl">Tcp</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#apply(org.apache.pekko.actor.ActorSystem)">apply</a></span>&#8203;(<a href="../../actor/ActorSystem.html" title="class in org.apache.pekko.actor">ActorSystem</a>&nbsp;system)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Tcp.IncomingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bind(java.lang.String,int,int,scala.collection.immutable.Iterable,boolean,scala.concurrent.duration.Duration)">bind</a></span>&#8203;(java.lang.String&nbsp;interface_,
    int&nbsp;port,
    int&nbsp;backlog,
    scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
    boolean&nbsp;halfClose,
    scala.concurrent.duration.Duration&nbsp;idleTimeout)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bind$default$3()">bind$default$3</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bind$default$4()">bind$default$4</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bind$default$5()">bind$default$5</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>scala.concurrent.duration.Duration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bind$default$6()">bind$default$6</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandle(org.apache.pekko.stream.scaladsl.Flow,java.lang.String,int,int,scala.collection.immutable.Iterable,boolean,scala.concurrent.duration.Duration,org.apache.pekko.stream.Materializer)">bindAndHandle</a></span>&#8203;(<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;?&gt;&nbsp;handler,
             java.lang.String&nbsp;interface_,
             int&nbsp;port,
             int&nbsp;backlog,
             scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
             boolean&nbsp;halfClose,
             scala.concurrent.duration.Duration&nbsp;idleTimeout,
             <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;m)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 handling the incoming connections using the provided Flow.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandle$default$4()">bindAndHandle$default$4</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandle$default$5()">bindAndHandle$default$5</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandle$default$6()">bindAndHandle$default$6</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>scala.concurrent.duration.Duration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandle$default$7()">bindAndHandle$default$7</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandleTls(org.apache.pekko.stream.scaladsl.Flow,java.lang.String,int,javax.net.ssl.SSLContext,org.apache.pekko.stream.TLSProtocol.NegotiateNewSession,int,scala.collection.immutable.Iterable,scala.concurrent.duration.Duration,org.apache.pekko.stream.Materializer)">bindAndHandleTls</a></span>&#8203;(<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;?&gt;&nbsp;handler,
                java.lang.String&nbsp;interface_,
                int&nbsp;port,
                javax.net.ssl.SSLContext&nbsp;sslContext,
                <a href="../TLSProtocol.NegotiateNewSession.html" title="class in org.apache.pekko.stream">TLSProtocol.NegotiateNewSession</a>&nbsp;negotiateNewSession,
                int&nbsp;backlog,
                scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                scala.concurrent.duration.Duration&nbsp;idleTimeout,
                <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;m)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use bindAndHandleWithTls that takes a SSLEngine factory instead.</div>
</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandleTls$default$6()">bindAndHandleTls$default$6</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandleTls$default$7()">bindAndHandleTls$default$7</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>scala.concurrent.duration.Duration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandleTls$default$8()">bindAndHandleTls$default$8</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandleWithTls(org.apache.pekko.stream.scaladsl.Flow,java.lang.String,int,scala.Function0,int,scala.collection.immutable.Seq,scala.concurrent.duration.Duration,scala.Function1,org.apache.pekko.stream.TLSClosing,org.apache.pekko.stream.Materializer)">bindAndHandleWithTls</a></span>&#8203;(<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;?&gt;&nbsp;handler,
                    java.lang.String&nbsp;interface_,
                    int&nbsp;port,
                    scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine,
                    int&nbsp;backlog,
                    scala.collection.immutable.Seq&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                    scala.concurrent.duration.Duration&nbsp;idleTimeout,
                    scala.Function1&lt;javax.net.ssl.SSLSession,&#8203;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&nbsp;verifySession,
                    <a href="../TLSClosing.html" title="class in org.apache.pekko.stream">TLSClosing</a>&nbsp;closing,
                    <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;m)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 all incoming and outgoing bytes are passed through TLS and handling the incoming connections using the
 provided Flow.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindAndHandleWithTls(org.apache.pekko.stream.scaladsl.Flow,java.lang.String,int,scala.Function0,org.apache.pekko.stream.Materializer)">bindAndHandleWithTls</a></span>&#8203;(<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;?&gt;&nbsp;handler,
                    java.lang.String&nbsp;interface_,
                    int&nbsp;port,
                    scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine,
                    <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;m)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 all incoming and outgoing bytes are passed through TLS and handling the incoming connections using the
 provided Flow.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>scala.concurrent.duration.FiniteDuration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindShutdownTimeout()">bindShutdownTimeout</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Tcp.IncomingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindTls(java.lang.String,int,javax.net.ssl.SSLContext,org.apache.pekko.stream.TLSProtocol.NegotiateNewSession,int,scala.collection.immutable.Iterable,scala.concurrent.duration.Duration)">bindTls</a></span>&#8203;(java.lang.String&nbsp;interface_,
       int&nbsp;port,
       javax.net.ssl.SSLContext&nbsp;sslContext,
       <a href="../TLSProtocol.NegotiateNewSession.html" title="class in org.apache.pekko.stream">TLSProtocol.NegotiateNewSession</a>&nbsp;negotiateNewSession,
       int&nbsp;backlog,
       scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
       scala.concurrent.duration.Duration&nbsp;idleTimeout)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use bindWithTls that takes a SSLEngine factory instead.</div>
</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindTls$default$5()">bindTls$default$5</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindTls$default$6()">bindTls$default$6</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>scala.concurrent.duration.Duration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindTls$default$7()">bindTls$default$7</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Tcp.IncomingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindWithTls(java.lang.String,int,scala.Function0)">bindWithTls</a></span>&#8203;(java.lang.String&nbsp;interface_,
           int&nbsp;port,
           scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 where all incoming and outgoing bytes are passed through TLS.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Tcp.IncomingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindWithTls(java.lang.String,int,scala.Function0,int,scala.collection.immutable.Seq,scala.concurrent.duration.Duration,scala.Function1,org.apache.pekko.stream.TLSClosing)">bindWithTls</a></span>&#8203;(java.lang.String&nbsp;interface_,
           int&nbsp;port,
           scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine,
           int&nbsp;backlog,
           scala.collection.immutable.Seq&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
           scala.concurrent.duration.Duration&nbsp;idleTimeout,
           scala.Function1&lt;javax.net.ssl.SSLSession,&#8203;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&nbsp;verifySession,
           <a href="../TLSClosing.html" title="class in org.apache.pekko.stream">TLSClosing</a>&nbsp;closing)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 where all incoming and outgoing bytes are passed through TLS.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static <a href="Tcp.html" title="class in org.apache.pekko.stream.scaladsl">Tcp</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createExtension(org.apache.pekko.actor.ExtendedActorSystem)">createExtension</a></span>&#8203;(<a href="../../actor/ExtendedActorSystem.html" title="class in org.apache.pekko.actor">ExtendedActorSystem</a>&nbsp;system)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#equals(java.lang.Object)">equals</a></span>&#8203;(java.lang.Object&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static <a href="Tcp.html" title="class in org.apache.pekko.stream.scaladsl">Tcp</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#get(org.apache.pekko.actor.ActorSystem)">get</a></span>&#8203;(<a href="../../actor/ActorSystem.html" title="class in org.apache.pekko.actor">ActorSystem</a>&nbsp;system)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static <a href="Tcp.html" title="class in org.apache.pekko.stream.scaladsl">Tcp</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#get(org.apache.pekko.actor.ClassicActorSystemProvider)">get</a></span>&#8203;(<a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;system)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashCode()">hashCode</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static <a href="Tcp$.html" title="class in org.apache.pekko.stream.scaladsl">Tcp$</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lookup()">lookup</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingConnection(java.lang.String,int)">outgoingConnection</a></span>&#8203;(java.lang.String&nbsp;host,
                  int&nbsp;port)</code></th>
<td class="colLast">
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> without specifying options.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingConnection(java.net.InetSocketAddress,scala.Option,scala.collection.immutable.Iterable,boolean,scala.concurrent.duration.Duration,scala.concurrent.duration.Duration)">outgoingConnection</a></span>&#8203;(java.net.InetSocketAddress&nbsp;remoteAddress,
                  scala.Option&lt;java.net.InetSocketAddress&gt;&nbsp;localAddress,
                  scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                  boolean&nbsp;halfClose,
                  scala.concurrent.duration.Duration&nbsp;connectTimeout,
                  scala.concurrent.duration.Duration&nbsp;idleTimeout)</code></th>
<td class="colLast">
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> instance representing a prospective TCP client connection to the given endpoint.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>scala.Option&lt;java.net.InetSocketAddress&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingConnection$default$2()">outgoingConnection$default$2</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingConnection$default$3()">outgoingConnection$default$3</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingConnection$default$4()">outgoingConnection$default$4</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>scala.concurrent.duration.Duration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingConnection$default$5()">outgoingConnection$default$5</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>scala.concurrent.duration.Duration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingConnection$default$6()">outgoingConnection$default$6</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingConnectionWithTls(java.net.InetSocketAddress,scala.Function0)">outgoingConnectionWithTls</a></span>&#8203;(java.net.InetSocketAddress&nbsp;remoteAddress,
                         scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine)</code></th>
<td class="colLast">
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> with TLS.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code><a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingConnectionWithTls(java.net.InetSocketAddress,scala.Function0,scala.Option,scala.collection.immutable.Seq,scala.concurrent.duration.Duration,scala.concurrent.duration.Duration,scala.Function1,org.apache.pekko.stream.TLSClosing)">outgoingConnectionWithTls</a></span>&#8203;(java.net.InetSocketAddress&nbsp;remoteAddress,
                         scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine,
                         scala.Option&lt;java.net.InetSocketAddress&gt;&nbsp;localAddress,
                         scala.collection.immutable.Seq&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                         scala.concurrent.duration.Duration&nbsp;connectTimeout,
                         scala.concurrent.duration.Duration&nbsp;idleTimeout,
                         scala.Function1&lt;javax.net.ssl.SSLSession,&#8203;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&nbsp;verifySession,
                         <a href="../TLSClosing.html" title="class in org.apache.pekko.stream">TLSClosing</a>&nbsp;closing)</code></th>
<td class="colLast">
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> with TLS.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code><a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingTlsConnection(java.lang.String,int,javax.net.ssl.SSLContext,org.apache.pekko.stream.TLSProtocol.NegotiateNewSession)">outgoingTlsConnection</a></span>&#8203;(java.lang.String&nbsp;host,
                     int&nbsp;port,
                     javax.net.ssl.SSLContext&nbsp;sslContext,
                     <a href="../TLSProtocol.NegotiateNewSession.html" title="class in org.apache.pekko.stream">TLSProtocol.NegotiateNewSession</a>&nbsp;negotiateNewSession)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use outgoingConnectionWithTls that takes a SSLEngine factory instead.</div>
</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code><a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingTlsConnection(java.net.InetSocketAddress,javax.net.ssl.SSLContext,org.apache.pekko.stream.TLSProtocol.NegotiateNewSession,scala.Option,scala.collection.immutable.Iterable,scala.concurrent.duration.Duration,scala.concurrent.duration.Duration)">outgoingTlsConnection</a></span>&#8203;(java.net.InetSocketAddress&nbsp;remoteAddress,
                     javax.net.ssl.SSLContext&nbsp;sslContext,
                     <a href="../TLSProtocol.NegotiateNewSession.html" title="class in org.apache.pekko.stream">TLSProtocol.NegotiateNewSession</a>&nbsp;negotiateNewSession,
                     scala.Option&lt;java.net.InetSocketAddress&gt;&nbsp;localAddress,
                     scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                     scala.concurrent.duration.Duration&nbsp;connectTimeout,
                     scala.concurrent.duration.Duration&nbsp;idleTimeout)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use outgoingConnectionWithTls that takes a SSLEngine factory instead.</div>
</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>scala.Option&lt;java.net.InetSocketAddress&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingTlsConnection$default$4()">outgoingTlsConnection$default$4</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingTlsConnection$default$5()">outgoingTlsConnection$default$5</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>scala.concurrent.duration.Duration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingTlsConnection$default$6()">outgoingTlsConnection$default$6</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>scala.concurrent.duration.Duration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#outgoingTlsConnection$default$7()">outgoingTlsConnection$default$7</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;(org.apache.pekko.actor.ExtendedActorSystem)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Tcp</h4>
<pre>public&nbsp;Tcp&#8203;(<a href="../../actor/ExtendedActorSystem.html" title="class in org.apache.pekko.actor">ExtendedActorSystem</a>&nbsp;system)</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="apply(org.apache.pekko.actor.ActorSystem)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>apply</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tcp.html" title="class in org.apache.pekko.stream.scaladsl">Tcp</a>&nbsp;apply&#8203;(<a href="../../actor/ActorSystem.html" title="class in org.apache.pekko.actor">ActorSystem</a>&nbsp;system)</pre>
</li>
</ul>
<a id="get(org.apache.pekko.actor.ActorSystem)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tcp.html" title="class in org.apache.pekko.stream.scaladsl">Tcp</a>&nbsp;get&#8203;(<a href="../../actor/ActorSystem.html" title="class in org.apache.pekko.actor">ActorSystem</a>&nbsp;system)</pre>
</li>
</ul>
<a id="get(org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tcp.html" title="class in org.apache.pekko.stream.scaladsl">Tcp</a>&nbsp;get&#8203;(<a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;system)</pre>
</li>
</ul>
<a id="lookup()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lookup</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tcp$.html" title="class in org.apache.pekko.stream.scaladsl">Tcp$</a>&nbsp;lookup()</pre>
</li>
</ul>
<a id="createExtension(org.apache.pekko.actor.ExtendedActorSystem)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createExtension</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tcp.html" title="class in org.apache.pekko.stream.scaladsl">Tcp</a>&nbsp;createExtension&#8203;(<a href="../../actor/ExtendedActorSystem.html" title="class in org.apache.pekko.actor">ExtendedActorSystem</a>&nbsp;system)</pre>
</li>
</ul>
<a id="hashCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashCode</h4>
<pre class="methodSignature">public static final&nbsp;int&nbsp;hashCode()</pre>
</li>
</ul>
<a id="equals(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre class="methodSignature">public static final&nbsp;boolean&nbsp;equals&#8203;(java.lang.Object&nbsp;other)</pre>
</li>
</ul>
<a id="bindShutdownTimeout()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindShutdownTimeout</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.duration.FiniteDuration&nbsp;bindShutdownTimeout()</pre>
</li>
</ul>
<a id="bind(java.lang.String,int,int,scala.collection.immutable.Iterable,boolean,scala.concurrent.duration.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bind</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Tcp.IncomingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&gt;&nbsp;bind&#8203;(java.lang.String&nbsp;interface_,
                                                                                            int&nbsp;port,
                                                                                            int&nbsp;backlog,
                                                                                            scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                                                                                            boolean&nbsp;halfClose,
                                                                                            scala.concurrent.duration.Duration&nbsp;idleTimeout)</pre>
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>.
 <p>
 Please note that the startup of the server is asynchronous, i.e. after materializing the enclosing
 <code>pekko.stream.scaladsl.RunnableGraph</code> the server is not immediately available. Only after the materialized future
 completes is the server ready to accept client connections.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>interface</code> - The interface to listen on</dd>
<dd><code>port</code> - The port to listen on</dd>
<dd><code>backlog</code> - Controls the size of the connection backlog</dd>
<dd><code>options</code> - TCP options for the connections, see <code>pekko.io.Tcp</code> for details</dd>
<dd><code>halfClose</code> - Controls whether the connection is kept open even after writing has been completed to the accepted
                  TCP connections.
                  If set to true, the connection will implement the TCP half-close mechanism, allowing the client to
                  write to the connection even after the server has finished writing. The TCP socket is only closed
                  after both the client and server finished writing.
                  If set to false, the connection will immediately closed once the server closes its write side,
                  independently whether the client is still attempting to write. This setting is recommended
                  for servers, and therefore it is the default setting.</dd>
</dl>
</li>
</ul>
<a id="bind$default$3()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bind$default$3</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;bind$default$3()</pre>
</li>
</ul>
<a id="bind$default$4()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bind$default$4</h4>
<pre class="methodSignature">public&nbsp;scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;bind$default$4()</pre>
</li>
</ul>
<a id="bind$default$5()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bind$default$5</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;bind$default$5()</pre>
</li>
</ul>
<a id="bind$default$6()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bind$default$6</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.duration.Duration&nbsp;bind$default$6()</pre>
</li>
</ul>
<a id="bindAndHandle(org.apache.pekko.stream.scaladsl.Flow,java.lang.String,int,int,scala.collection.immutable.Iterable,boolean,scala.concurrent.duration.Duration,org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandle</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&nbsp;bindAndHandle&#8203;(<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;?&gt;&nbsp;handler,
                                                                java.lang.String&nbsp;interface_,
                                                                int&nbsp;port,
                                                                int&nbsp;backlog,
                                                                scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                                                                boolean&nbsp;halfClose,
                                                                scala.concurrent.duration.Duration&nbsp;idleTimeout,
                                                                <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;m)</pre>
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 handling the incoming connections using the provided Flow.
 <p>
 Please note that the startup of the server is asynchronous, i.e. after materializing the enclosing
 <code>pekko.stream.scaladsl.RunnableGraph</code> the server is not immediately available. Only after the returned future
 completes is the server ready to accept client connections.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>handler</code> - A Flow that represents the server logic</dd>
<dd><code>interface</code> - The interface to listen on</dd>
<dd><code>port</code> - The port to listen on</dd>
<dd><code>backlog</code> - Controls the size of the connection backlog</dd>
<dd><code>options</code> - TCP options for the connections, see <code>pekko.io.Tcp</code> for details</dd>
<dd><code>halfClose</code> - Controls whether the connection is kept open even after writing has been completed to the accepted
                  TCP connections.
                  If set to true, the connection will implement the TCP half-close mechanism, allowing the client to
                  write to the connection even after the server has finished writing. The TCP socket is only closed
                  after both the client and server finished writing.
                  If set to false, the connection will immediately closed once the server closes its write side,
                  independently whether the client is still attempting to write. This setting is recommended
                  for servers, and therefore it is the default setting.</dd>
</dl>
</li>
</ul>
<a id="bindAndHandle$default$4()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandle$default$4</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;bindAndHandle$default$4()</pre>
</li>
</ul>
<a id="bindAndHandle$default$5()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandle$default$5</h4>
<pre class="methodSignature">public&nbsp;scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;bindAndHandle$default$5()</pre>
</li>
</ul>
<a id="bindAndHandle$default$6()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandle$default$6</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;bindAndHandle$default$6()</pre>
</li>
</ul>
<a id="bindAndHandle$default$7()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandle$default$7</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.duration.Duration&nbsp;bindAndHandle$default$7()</pre>
</li>
</ul>
<a id="outgoingConnection(java.net.InetSocketAddress,scala.Option,scala.collection.immutable.Iterable,boolean,scala.concurrent.duration.Duration,scala.concurrent.duration.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingConnection</h4>
<pre class="methodSignature">public&nbsp;<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;&nbsp;outgoingConnection&#8203;(java.net.InetSocketAddress&nbsp;remoteAddress,
                                                                                                                  scala.Option&lt;java.net.InetSocketAddress&gt;&nbsp;localAddress,
                                                                                                                  scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                                                                                                                  boolean&nbsp;halfClose,
                                                                                                                  scala.concurrent.duration.Duration&nbsp;connectTimeout,
                                                                                                                  scala.concurrent.duration.Duration&nbsp;idleTimeout)</pre>
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> instance representing a prospective TCP client connection to the given endpoint.
 <p>
 Note that the ByteString chunk boundaries are not retained across the network,
 to achieve application level chunks you have to introduce explicit framing in your streams,
 for example using the <a href="Framing.html" title="class in org.apache.pekko.stream.scaladsl"><code>Framing</code></a> operators.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>remoteAddress</code> - The remote address to connect to</dd>
<dd><code>localAddress</code> - Optional local address for the connection</dd>
<dd><code>options</code> - TCP options for the connections, see <code>pekko.io.Tcp</code> for details</dd>
<dd><code>halfClose</code> - Controls whether the connection is kept open even after writing has been completed to the accepted
                  TCP connections.
                  If set to true, the connection will implement the TCP half-close mechanism, allowing the server to
                  write to the connection even after the client has finished writing. The TCP socket is only closed
                  after both the client and server finished writing. This setting is recommended for clients and
                  therefore it is the default setting.
                  If set to false, the connection will immediately closed once the client closes its write side,
                  independently whether the server is still attempting to write.</dd>
</dl>
</li>
</ul>
<a id="outgoingConnection(java.lang.String,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingConnection</h4>
<pre class="methodSignature">public&nbsp;<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;&nbsp;outgoingConnection&#8203;(java.lang.String&nbsp;host,
                                                                                                                  int&nbsp;port)</pre>
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> without specifying options.
 It represents a prospective TCP client connection to the given endpoint.
 <p>
 Note that the ByteString chunk boundaries are not retained across the network,
 to achieve application level chunks you have to introduce explicit framing in your streams,
 for example using the <a href="Framing.html" title="class in org.apache.pekko.stream.scaladsl"><code>Framing</code></a> operators.</div>
</li>
</ul>
<a id="outgoingConnection$default$2()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingConnection$default$2</h4>
<pre class="methodSignature">public&nbsp;scala.Option&lt;java.net.InetSocketAddress&gt;&nbsp;outgoingConnection$default$2()</pre>
</li>
</ul>
<a id="outgoingConnection$default$3()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingConnection$default$3</h4>
<pre class="methodSignature">public&nbsp;scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;outgoingConnection$default$3()</pre>
</li>
</ul>
<a id="outgoingConnection$default$4()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingConnection$default$4</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;outgoingConnection$default$4()</pre>
</li>
</ul>
<a id="outgoingConnection$default$5()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingConnection$default$5</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.duration.Duration&nbsp;outgoingConnection$default$5()</pre>
</li>
</ul>
<a id="outgoingConnection$default$6()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingConnection$default$6</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.duration.Duration&nbsp;outgoingConnection$default$6()</pre>
</li>
</ul>
<a id="outgoingTlsConnection(java.lang.String,int,javax.net.ssl.SSLContext,org.apache.pekko.stream.TLSProtocol.NegotiateNewSession)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingTlsConnection</h4>
<pre class="methodSignature">public&nbsp;<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;&nbsp;outgoingTlsConnection&#8203;(java.lang.String&nbsp;host,
                                                                                                                     int&nbsp;port,
                                                                                                                     javax.net.ssl.SSLContext&nbsp;sslContext,
                                                                                                                     <a href="../TLSProtocol.NegotiateNewSession.html" title="class in org.apache.pekko.stream">TLSProtocol.NegotiateNewSession</a>&nbsp;negotiateNewSession)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use outgoingConnectionWithTls that takes a SSLEngine factory instead. Setup the SSLEngine with needed parameters. Since 2.6.0.</div>
</div>
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> with TLS.
 The returned flow represents a TCP client connection to the given endpoint where all bytes in and
 out go through TLS.
 <p>
 For more advanced use cases you can manually combine <code>Tcp.outgoingConnection</code> and <a href="TLS.html" title="class in org.apache.pekko.stream.scaladsl"><code>TLS</code></a>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>negotiateNewSession</code> - Details about what to require when negotiating the connection with the server</dd>
<dd><code>sslContext</code> - Context containing details such as the trust and keystore
 <p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Tcp.outgoingConnection</code></dd>
</dl>
</li>
</ul>
<a id="outgoingTlsConnection(java.net.InetSocketAddress,javax.net.ssl.SSLContext,org.apache.pekko.stream.TLSProtocol.NegotiateNewSession,scala.Option,scala.collection.immutable.Iterable,scala.concurrent.duration.Duration,scala.concurrent.duration.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingTlsConnection</h4>
<pre class="methodSignature">public&nbsp;<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;&nbsp;outgoingTlsConnection&#8203;(java.net.InetSocketAddress&nbsp;remoteAddress,
                                                                                                                     javax.net.ssl.SSLContext&nbsp;sslContext,
                                                                                                                     <a href="../TLSProtocol.NegotiateNewSession.html" title="class in org.apache.pekko.stream">TLSProtocol.NegotiateNewSession</a>&nbsp;negotiateNewSession,
                                                                                                                     scala.Option&lt;java.net.InetSocketAddress&gt;&nbsp;localAddress,
                                                                                                                     scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                                                                                                                     scala.concurrent.duration.Duration&nbsp;connectTimeout,
                                                                                                                     scala.concurrent.duration.Duration&nbsp;idleTimeout)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use outgoingConnectionWithTls that takes a SSLEngine factory instead. Setup the SSLEngine with needed parameters. Since 2.6.0.</div>
</div>
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> with TLS.
 The returned flow represents a TCP client connection to the given endpoint where all bytes in and
 out go through TLS.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>negotiateNewSession</code> - Details about what to require when negotiating the connection with the server</dd>
<dd><code>sslContext</code> - Context containing details such as the trust and keystore</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Tcp.outgoingConnection</code></dd>
</dl>
</li>
</ul>
<a id="outgoingTlsConnection$default$4()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingTlsConnection$default$4</h4>
<pre class="methodSignature">public&nbsp;scala.Option&lt;java.net.InetSocketAddress&gt;&nbsp;outgoingTlsConnection$default$4()</pre>
</li>
</ul>
<a id="outgoingTlsConnection$default$5()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingTlsConnection$default$5</h4>
<pre class="methodSignature">public&nbsp;scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;outgoingTlsConnection$default$5()</pre>
</li>
</ul>
<a id="outgoingTlsConnection$default$6()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingTlsConnection$default$6</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.duration.Duration&nbsp;outgoingTlsConnection$default$6()</pre>
</li>
</ul>
<a id="outgoingTlsConnection$default$7()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingTlsConnection$default$7</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.duration.Duration&nbsp;outgoingTlsConnection$default$7()</pre>
</li>
</ul>
<a id="outgoingConnectionWithTls(java.net.InetSocketAddress,scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingConnectionWithTls</h4>
<pre class="methodSignature">public&nbsp;<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;&nbsp;outgoingConnectionWithTls&#8203;(java.net.InetSocketAddress&nbsp;remoteAddress,
                                                                                                                         scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine)</pre>
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> with TLS.
 The returned flow represents a TCP client connection to the given endpoint where all bytes in and
 out go through TLS.
 <p>
 You specify a factory to create an SSLEngine that must already be configured for
 client mode and with all the parameters for the first session.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Tcp.outgoingConnection</code></dd>
</dl>
</li>
</ul>
<a id="outgoingConnectionWithTls(java.net.InetSocketAddress,scala.Function0,scala.Option,scala.collection.immutable.Seq,scala.concurrent.duration.Duration,scala.concurrent.duration.Duration,scala.Function1,org.apache.pekko.stream.TLSClosing)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outgoingConnectionWithTls</h4>
<pre class="methodSignature">public&nbsp;<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.OutgoingConnection</a>&gt;&gt;&nbsp;outgoingConnectionWithTls&#8203;(java.net.InetSocketAddress&nbsp;remoteAddress,
                                                                                                                         scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine,
                                                                                                                         scala.Option&lt;java.net.InetSocketAddress&gt;&nbsp;localAddress,
                                                                                                                         scala.collection.immutable.Seq&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                                                                                                                         scala.concurrent.duration.Duration&nbsp;connectTimeout,
                                                                                                                         scala.concurrent.duration.Duration&nbsp;idleTimeout,
                                                                                                                         scala.Function1&lt;javax.net.ssl.SSLSession,&#8203;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&nbsp;verifySession,
                                                                                                                         <a href="../TLSClosing.html" title="class in org.apache.pekko.stream">TLSClosing</a>&nbsp;closing)</pre>
<div class="block">Creates an <a href="Tcp.OutgoingConnection.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.OutgoingConnection</code></a> with TLS.
 The returned flow represents a TCP client connection to the given endpoint where all bytes in and
 out go through TLS.
 <p>
 You specify a factory to create an SSLEngine that must already be configured for
 client mode and with all the parameters for the first session.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Tcp.outgoingConnection</code></dd>
</dl>
</li>
</ul>
<a id="bindTls(java.lang.String,int,javax.net.ssl.SSLContext,org.apache.pekko.stream.TLSProtocol.NegotiateNewSession,int,scala.collection.immutable.Iterable,scala.concurrent.duration.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindTls</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Tcp.IncomingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&gt;&nbsp;bindTls&#8203;(java.lang.String&nbsp;interface_,
                                                                                               int&nbsp;port,
                                                                                               javax.net.ssl.SSLContext&nbsp;sslContext,
                                                                                               <a href="../TLSProtocol.NegotiateNewSession.html" title="class in org.apache.pekko.stream">TLSProtocol.NegotiateNewSession</a>&nbsp;negotiateNewSession,
                                                                                               int&nbsp;backlog,
                                                                                               scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                                                                                               scala.concurrent.duration.Duration&nbsp;idleTimeout)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use bindWithTls that takes a SSLEngine factory instead. Setup the SSLEngine with needed parameters. Since 2.6.0.</div>
</div>
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 where all incoming and outgoing bytes are passed through TLS.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>negotiateNewSession</code> - Details about what to require when negotiating the connection with the server</dd>
<dd><code>sslContext</code> - Context containing details such as the trust and keystore</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Tcp.bind</code></dd>
</dl>
</li>
</ul>
<a id="bindTls$default$5()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindTls$default$5</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;bindTls$default$5()</pre>
</li>
</ul>
<a id="bindTls$default$6()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindTls$default$6</h4>
<pre class="methodSignature">public&nbsp;scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;bindTls$default$6()</pre>
</li>
</ul>
<a id="bindTls$default$7()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindTls$default$7</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.duration.Duration&nbsp;bindTls$default$7()</pre>
</li>
</ul>
<a id="bindWithTls(java.lang.String,int,scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindWithTls</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Tcp.IncomingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&gt;&nbsp;bindWithTls&#8203;(java.lang.String&nbsp;interface_,
                                                                                                   int&nbsp;port,
                                                                                                   scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine)</pre>
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 where all incoming and outgoing bytes are passed through TLS.
 <p>
 You specify a factory to create an SSLEngine that must already be configured for
 server mode and with all the parameters for the first session.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Tcp.bind</code></dd>
</dl>
</li>
</ul>
<a id="bindWithTls(java.lang.String,int,scala.Function0,int,scala.collection.immutable.Seq,scala.concurrent.duration.Duration,scala.Function1,org.apache.pekko.stream.TLSClosing)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindWithTls</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Tcp.IncomingConnection.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.IncomingConnection</a>,&#8203;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&gt;&nbsp;bindWithTls&#8203;(java.lang.String&nbsp;interface_,
                                                                                                   int&nbsp;port,
                                                                                                   scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine,
                                                                                                   int&nbsp;backlog,
                                                                                                   scala.collection.immutable.Seq&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                                                                                                   scala.concurrent.duration.Duration&nbsp;idleTimeout,
                                                                                                   scala.Function1&lt;javax.net.ssl.SSLSession,&#8203;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&nbsp;verifySession,
                                                                                                   <a href="../TLSClosing.html" title="class in org.apache.pekko.stream">TLSClosing</a>&nbsp;closing)</pre>
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 where all incoming and outgoing bytes are passed through TLS.
 <p>
 You specify a factory to create an SSLEngine that must already be configured for
 server mode and with all the parameters for the first session.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Tcp.bind</code></dd>
</dl>
</li>
</ul>
<a id="bindAndHandleWithTls(org.apache.pekko.stream.scaladsl.Flow,java.lang.String,int,scala.Function0,org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandleWithTls</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&nbsp;bindAndHandleWithTls&#8203;(<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;?&gt;&nbsp;handler,
                                                                       java.lang.String&nbsp;interface_,
                                                                       int&nbsp;port,
                                                                       scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine,
                                                                       <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;m)</pre>
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 all incoming and outgoing bytes are passed through TLS and handling the incoming connections using the
 provided Flow.
 <p>
 You specify a factory to create an SSLEngine that must already be configured for
 server mode and with all the parameters for the first session.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Tcp.bindAndHandle</code></dd>
</dl>
</li>
</ul>
<a id="bindAndHandleWithTls(org.apache.pekko.stream.scaladsl.Flow,java.lang.String,int,scala.Function0,int,scala.collection.immutable.Seq,scala.concurrent.duration.Duration,scala.Function1,org.apache.pekko.stream.TLSClosing,org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandleWithTls</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&nbsp;bindAndHandleWithTls&#8203;(<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;?&gt;&nbsp;handler,
                                                                       java.lang.String&nbsp;interface_,
                                                                       int&nbsp;port,
                                                                       scala.Function0&lt;javax.net.ssl.SSLEngine&gt;&nbsp;createSSLEngine,
                                                                       int&nbsp;backlog,
                                                                       scala.collection.immutable.Seq&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                                                                       scala.concurrent.duration.Duration&nbsp;idleTimeout,
                                                                       scala.Function1&lt;javax.net.ssl.SSLSession,&#8203;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&nbsp;verifySession,
                                                                       <a href="../TLSClosing.html" title="class in org.apache.pekko.stream">TLSClosing</a>&nbsp;closing,
                                                                       <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;m)</pre>
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 all incoming and outgoing bytes are passed through TLS and handling the incoming connections using the
 provided Flow.
 <p>
 You specify a factory to create an SSLEngine that must already be configured for
 server mode and with all the parameters for the first session.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Tcp.bindAndHandle</code></dd>
</dl>
</li>
</ul>
<a id="bindAndHandleTls(org.apache.pekko.stream.scaladsl.Flow,java.lang.String,int,javax.net.ssl.SSLContext,org.apache.pekko.stream.TLSProtocol.NegotiateNewSession,int,scala.collection.immutable.Iterable,scala.concurrent.duration.Duration,org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandleTls</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.Future&lt;<a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl">Tcp.ServerBinding</a>&gt;&nbsp;bindAndHandleTls&#8203;(<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;<a href="../../util/ByteString.html" title="class in org.apache.pekko.util">ByteString</a>,&#8203;?&gt;&nbsp;handler,
                                                                   java.lang.String&nbsp;interface_,
                                                                   int&nbsp;port,
                                                                   javax.net.ssl.SSLContext&nbsp;sslContext,
                                                                   <a href="../TLSProtocol.NegotiateNewSession.html" title="class in org.apache.pekko.stream">TLSProtocol.NegotiateNewSession</a>&nbsp;negotiateNewSession,
                                                                   int&nbsp;backlog,
                                                                   scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;options,
                                                                   scala.concurrent.duration.Duration&nbsp;idleTimeout,
                                                                   <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;m)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use bindAndHandleWithTls that takes a SSLEngine factory instead. Setup the SSLEngine with needed parameters. Since 2.6.0.</div>
</div>
<div class="block">Creates a <a href="Tcp.ServerBinding.html" title="class in org.apache.pekko.stream.scaladsl"><code>Tcp.ServerBinding</code></a> instance which represents a prospective TCP server binding on the given <code>endpoint</code>
 handling the incoming connections through TLS and then run using the provided Flow.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>negotiateNewSession</code> - Details about what to require when negotiating the connection with the server</dd>
<dd><code>sslContext</code> - Context containing details such as the trust and keystore</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>
 Marked API-may-change to leave room for an improvement around the very long parameter list.</code></dd>
</dl>
</li>
</ul>
<a id="bindAndHandleTls$default$6()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandleTls$default$6</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;bindAndHandleTls$default$6()</pre>
</li>
</ul>
<a id="bindAndHandleTls$default$7()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindAndHandleTls$default$7</h4>
<pre class="methodSignature">public&nbsp;scala.collection.immutable.Iterable&lt;<a href="../../io/Inet.SocketOption.html" title="interface in org.apache.pekko.io">Inet.SocketOption</a>&gt;&nbsp;bindAndHandleTls$default$7()</pre>
</li>
</ul>
<a id="bindAndHandleTls$default$8()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>bindAndHandleTls$default$8</h4>
<pre class="methodSignature">public&nbsp;scala.concurrent.duration.Duration&nbsp;bindAndHandleTls$default$8()</pre>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
