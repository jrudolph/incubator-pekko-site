<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.11) on Wed Feb 08 11:53:31 CET 2023 -->
<title>Source</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-02-08">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Source";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":41,"i1":9,"i2":41,"i3":41,"i4":9,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":9,"i16":10,"i17":10,"i18":10,"i19":10,"i20":42,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":9,"i27":9,"i28":9,"i29":9,"i30":10,"i31":42,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":9,"i41":10,"i42":42,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":42,"i51":9,"i52":9,"i53":10,"i54":10,"i55":10,"i56":9,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":9,"i66":41,"i67":41,"i68":41,"i69":9,"i70":9,"i71":9,"i72":9,"i73":9,"i74":41,"i75":9,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":42,"i84":10,"i85":42,"i86":10,"i87":42,"i88":10,"i89":42,"i90":10,"i91":42,"i92":10,"i93":10,"i94":10,"i95":10,"i96":10,"i97":10,"i98":10,"i99":10,"i100":42,"i101":41,"i102":41,"i103":9,"i104":9,"i105":9,"i106":9,"i107":10,"i108":10,"i109":10,"i110":10,"i111":10,"i112":10,"i113":10,"i114":10,"i115":10,"i116":10,"i117":10,"i118":10,"i119":10,"i120":10,"i121":10,"i122":10,"i123":10,"i124":9,"i125":10,"i126":10,"i127":10,"i128":10,"i129":10,"i130":10,"i131":10,"i132":10,"i133":10,"i134":10,"i135":10,"i136":9,"i137":10,"i138":10,"i139":10,"i140":42,"i141":10,"i142":10,"i143":9,"i144":10,"i145":10,"i146":10,"i147":10,"i148":10,"i149":10,"i150":10,"i151":10,"i152":10,"i153":9,"i154":9,"i155":9,"i156":9,"i157":9,"i158":10,"i159":10,"i160":42,"i161":42,"i162":10,"i163":10,"i164":10,"i165":9,"i166":10,"i167":10,"i168":10,"i169":10,"i170":10,"i171":10,"i172":10,"i173":10,"i174":10,"i175":10,"i176":10,"i177":10,"i178":10,"i179":10,"i180":41,"i181":10,"i182":9,"i183":10,"i184":10,"i185":10,"i186":10,"i187":10,"i188":10,"i189":10,"i190":10,"i191":10,"i192":10,"i193":10,"i194":42,"i195":10,"i196":10,"i197":10,"i198":10,"i199":42,"i200":42,"i201":42,"i202":42,"i203":42,"i204":42,"i205":9,"i206":41,"i207":10,"i208":10,"i209":10,"i210":10,"i211":9,"i212":9,"i213":9,"i214":9,"i215":9,"i216":10,"i217":10,"i218":10,"i219":10,"i220":10,"i221":10,"i222":10,"i223":10,"i224":10,"i225":10,"i226":10,"i227":10,"i228":10,"i229":10,"i230":10,"i231":10,"i232":10,"i233":10,"i234":9,"i235":10,"i236":10,"i237":10,"i238":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.pekko.stream.javadsl</a></div>
<h2 title="Class Source" class="title">Class Source&lt;Out,&#8203;Mat&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.apache.pekko.stream.javadsl.Source&lt;Out,&#8203;Mat&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out&gt;,&#8203;Mat&gt;</code></dd>
</dl>
<hr>
<pre>public final class <span class="typeNameLabel">Source&lt;Out,&#8203;Mat&gt;</span>
extends java.lang.Object
implements <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out&gt;,&#8203;Mat&gt;</pre>
<div class="block">Java API
 <p>
 A <code>Source</code> is a set of stream processing steps that has one open output and an attached input.
 Can be used as a <code>Publisher</code></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.org.apache.pekko.stream.Graph">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;org.apache.pekko.stream.<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a></h3>
<code><a href="../Graph.GraphMapMatVal.html" title="class in org.apache.pekko.stream">Graph.GraphMapMatVal</a>&lt;<a href="../Graph.GraphMapMatVal.html" title="type parameter in Graph.GraphMapMatVal">S</a> extends <a href="../Shape.html" title="class in org.apache.pekko.stream">Shape</a>,&#8203;<a href="../Graph.GraphMapMatVal.html" title="type parameter in Graph.GraphMapMatVal">M</a>&gt;</code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(org.apache.pekko.stream.scaladsl.Source)">Source</a></span>&#8203;(<a href="../scaladsl/Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;delegate)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRef(int,org.apache.pekko.stream.OverflowStrategy)">actorRef</a></span>&#8203;(int&nbsp;bufferSize,
        <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use variant accepting completion and failure matchers.</div>
</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRef(org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function,int,org.apache.pekko.stream.OverflowStrategy)">actorRef</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&gt;&nbsp;completionMatcher,
        <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;java.lang.Throwable&gt;&gt;&nbsp;failureMatcher,
        int&nbsp;bufferSize,
        <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRefWithAck(java.lang.Object)">actorRefWithAck</a></span>&#8203;(java.lang.Object&nbsp;ackMessage)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use actorRefWithBackpressure accepting completion and failure matchers.</div>
</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRefWithAck(java.lang.Object,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function)">actorRefWithAck</a></span>&#8203;(java.lang.Object&nbsp;ackMessage,
               <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&gt;&nbsp;completionMatcher,
               <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;java.lang.Throwable&gt;&gt;&nbsp;failureMatcher)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use actorRefWithBackpressure instead</div>
</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRefWithBackpressure(java.lang.Object,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function)">actorRefWithBackpressure</a></span>&#8203;(java.lang.Object&nbsp;ackMessage,
                        <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&gt;&nbsp;completionMatcher,
                        <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;java.lang.Throwable&gt;&gt;&nbsp;failureMatcher)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addAttributes(org.apache.pekko.stream.Attributes)">addAttributes</a></span>&#8203;(<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>&nbsp;attr)</code></th>
<td class="colLast">
<div class="block">Add the given attributes to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>&lt;Agg,&#8203;Emit&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Emit,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#aggregateWithBoundary(java.util.function.Supplier,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.Pair)">aggregateWithBoundary</a></span>&#8203;(java.util.function.Supplier&lt;Agg&gt;&nbsp;allocate,
                     <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;Agg,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;Agg,&#8203;java.lang.Object&gt;&gt;&nbsp;aggregate,
                     <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;Agg,&#8203;Emit&gt;&nbsp;harvest,
                     <a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;java.util.function.Predicate&lt;Agg&gt;,&#8203;java.time.Duration&gt;&nbsp;emitOnTimer)</code></th>
<td class="colLast">
<div class="block">Aggregate input elements into an arbitrary data structure that can be completed and emitted downstream
 when custom condition is met which can be triggered by aggregate or timer.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#alsoTo(org.apache.pekko.stream.Graph)">alsoTo</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, meaning that elements that passes
 through will also be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#alsoToAll(org.apache.pekko.stream.Graph...)">alsoToAll</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;...&nbsp;those)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, meaning that elements that passes
 through will also be sent to all those <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#alsoToAll(scala.collection.immutable.Seq)">alsoToAll</a></span>&#8203;(scala.collection.immutable.Seq&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&gt;&nbsp;those)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, meaning that elements that passes
 through will also be sent to all those <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;M2,&#8203;M3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M3&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#alsoToMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">alsoToMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M2&gt;&nbsp;that,
         <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M2,&#8203;M3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that elements that passes
 through will also be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ask(int,org.apache.pekko.actor.ActorRef,java.lang.Class,org.apache.pekko.util.Timeout)">ask</a></span>&#8203;(int&nbsp;parallelism,
   <a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
   java.lang.Class&lt;S&gt;&nbsp;mapTo,
   <a href="../../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">Use the <code>ask</code> pattern to send a request-reply message to the target <code>ref</code> actor.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ask(org.apache.pekko.actor.ActorRef,java.lang.Class,org.apache.pekko.util.Timeout)">ask</a></span>&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
   java.lang.Class&lt;S&gt;&nbsp;mapTo,
   <a href="../../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">Use the <code>ask</code> pattern to send a request-reply message to the target <code>ref</code> actor.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="../scaladsl/Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asScala()">asScala</a></span>()</code></th>
<td class="colLast">
<div class="block">Converts this Java DSL element to its Scala DSL counterpart.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>&lt;Ctx&gt;&nbsp;<a href="SourceWithContext.html" title="class in org.apache.pekko.stream.javadsl">SourceWithContext</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Ctx,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asSourceWithContext(org.apache.pekko.japi.function.Function)">asSourceWithContext</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Ctx&gt;&nbsp;extractContext)</code></th>
<td class="colLast">
<div class="block">Transform this source whose element is <code></code>e<code></code> into a source producing tuple <code></code>(e, f(e))<code></code></div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;org.reactivestreams.Subscriber&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asSubscriber()">asSubscriber</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as a <code>Subscriber</code></div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#async()">async</a></span>()</code></th>
<td class="colLast">
<div class="block">Put an asynchronous boundary around this <code>Source</code></div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#async(java.lang.String)">async</a></span>&#8203;(java.lang.String&nbsp;dispatcher)</code></th>
<td class="colLast">
<div class="block">Put an asynchronous boundary around this <code>Source</code></div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#async(java.lang.String,int)">async</a></span>&#8203;(java.lang.String&nbsp;dispatcher,
     int&nbsp;inputBufferSize)</code></th>
<td class="colLast">
<div class="block">Put an asynchronous boundary around this <code>Source</code></div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#backpressureTimeout(java.time.Duration)">backpressureTimeout</a></span>&#8203;(java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
 the stream is failed with a <code>TimeoutException</code>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#backpressureTimeout(scala.concurrent.duration.FiniteDuration)">backpressureTimeout</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#batch(long,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">batch</a></span>&#8203;(long&nbsp;max,
     <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;seed,
     <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;aggregate)</code></th>
<td class="colLast">
<div class="block">Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#batchWeighted(long,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">batchWeighted</a></span>&#8203;(long&nbsp;max,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;seed,
             <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;aggregate)</code></th>
<td class="colLast">
<div class="block">Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#buffer(int,org.apache.pekko.stream.OverflowStrategy)">buffer</a></span>&#8203;(int&nbsp;size,
      <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</code></th>
<td class="colLast">
<div class="block">Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collect(scala.PartialFunction)">collect</a></span>&#8203;(scala.PartialFunction&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;&nbsp;pf)</code></th>
<td class="colLast">
<div class="block">Transform this stream by applying the given partial function to each of the elements
 on which the function is defined as they pass through this processing step.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectType(java.lang.Class)">collectType</a></span>&#8203;(java.lang.Class&lt;T&gt;&nbsp;clazz)</code></th>
<td class="colLast">
<div class="block">Transform this stream by testing the type of each of the elements
 on which the element is an instance of the provided type as they pass through this processing step.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;U&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;U,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combine(org.apache.pekko.stream.javadsl.Source,org.apache.pekko.stream.javadsl.Source,java.util.List,org.apache.pekko.japi.function.Function)">combine</a></span>&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&nbsp;first,
       <a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&nbsp;second,
       java.util.List&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;rest,
       <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Integer,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanInShape.html" title="class in org.apache.pekko.stream">UniformFanInShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy)</code></th>
<td class="colLast">
<div class="block">Combines several sources with fan-in strategy like <a href="Merge.html" title="class in org.apache.pekko.stream.javadsl"><code>Merge</code></a> or <a href="Concat.html" title="class in org.apache.pekko.stream.javadsl"><code>Concat</code></a> into a single <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;U,&#8203;M1,&#8203;M2,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;U,&#8203;M&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combineMat(org.apache.pekko.stream.javadsl.Source,org.apache.pekko.stream.javadsl.Source,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">combineMat</a></span>&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M1&gt;&nbsp;first,
          <a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M2&gt;&nbsp;second,
          <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Integer,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanInShape.html" title="class in org.apache.pekko.stream">UniformFanInShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy,
          <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;M1,&#8203;M2,&#8203;M&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Combines two sources with fan-in strategy like <code>Merge</code> or <code>Concat</code> and returns <code>Source</code> with a materialized value.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#completionStage(java.util.concurrent.CompletionStage)">completionStage</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;completionStage)</code></th>
<td class="colLast">
<div class="block">Emits a single value when the given <code>CompletionStage</code> is successfully completed and then completes the stream.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#completionStageSource(java.util.concurrent.CompletionStage)">completionStageSource</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;completionStageSource)</code></th>
<td class="colLast">
<div class="block">Turn a <code>CompletionStage[Source]</code> into a source that will emit the values of the source when the future completes successfully.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#completionTimeout(java.time.Duration)">completionTimeout</a></span>&#8203;(java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">If the completion of the stream does not happen until the provided timeout, the stream is failed
 with a <code>TimeoutException</code>.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#completionTimeout(scala.concurrent.duration.FiniteDuration)">completionTimeout</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(org.apache.pekko.stream.Graph)">concat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that)</code></th>
<td class="colLast">
<div class="block">Concatenate this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with the given one, meaning that once current
 is exhausted and all result elements have been generated,
 the given source elements will be produced.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concatAllLazy(org.apache.pekko.stream.Graph...)">concatAllLazy</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;...&nbsp;those)</code></th>
<td class="colLast">
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s to this one, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concatAllLazy(scala.collection.immutable.Seq)">concatAllLazy</a></span>&#8203;(scala.collection.immutable.Seq&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&gt;&nbsp;those)</code></th>
<td class="colLast">
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s to this one, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concatLazy(org.apache.pekko.stream.Graph)">concatLazy</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that)</code></th>
<td class="colLast">
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concatLazyMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">concatLazyMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
             <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concatMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">concatMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
         <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Concatenate this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with the given one, meaning that once current
 is exhausted and all result elements have been generated,
 the given source elements will be produced.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#conflate(org.apache.pekko.japi.function.Function2)">conflate</a></span>&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;aggregate)</code></th>
<td class="colLast">
<div class="block">Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#conflateWithSeed(org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">conflateWithSeed</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;seed,
                <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;aggregate)</code></th>
<td class="colLast">
<div class="block">Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cycle(org.apache.pekko.japi.function.Creator)">cycle</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.Iterator&lt;O&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Helper to create 'cycled' <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> from iterator provider.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#delay(java.time.Duration,org.apache.pekko.stream.DelayOverflowStrategy)">delay</a></span>&#8203;(java.time.Duration&nbsp;of,
     <a href="../DelayOverflowStrategy.html" title="class in org.apache.pekko.stream">DelayOverflowStrategy</a>&nbsp;strategy)</code></th>
<td class="colLast">
<div class="block">Shifts elements emission in time by a specified amount.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#delay(scala.concurrent.duration.FiniteDuration,org.apache.pekko.stream.DelayOverflowStrategy)">delay</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;of,
     <a href="../DelayOverflowStrategy.html" title="class in org.apache.pekko.stream">DelayOverflowStrategy</a>&nbsp;strategy)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#delayWith(java.util.function.Supplier,org.apache.pekko.stream.DelayOverflowStrategy)">delayWith</a></span>&#8203;(java.util.function.Supplier&lt;<a href="DelayStrategy.html" title="interface in org.apache.pekko.stream.javadsl">DelayStrategy</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&gt;&nbsp;delayStrategySupplier,
         <a href="../DelayOverflowStrategy.html" title="class in org.apache.pekko.stream">DelayOverflowStrategy</a>&nbsp;overFlowStrategy)</code></th>
<td class="colLast">
<div class="block">Shifts elements emission in time by an amount individually determined through delay strategy a specified amount.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#detach()">detach</a></span>()</code></th>
<td class="colLast">
<div class="block">Detaches upstream demand from downstream demand without detaching the
 stream rates; in other words acts like a buffer of size 1.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#divertTo(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Predicate)">divertTo</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that,
        <a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;when)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that elements will be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>
 instead of being passed through if the predicate <code>when</code> returns <code>true</code>.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>&lt;M2,&#8203;M3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M3&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#divertToMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Predicate,org.apache.pekko.japi.function.Function2)">divertToMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M2&gt;&nbsp;that,
           <a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;when,
           <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M2,&#8203;M3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that elements will be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>
 instead of being passed through if the predicate <code>when</code> returns <code>true</code>.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#drop(long)">drop</a></span>&#8203;(long&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Discard the given number of elements at the beginning of the stream.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dropWhile(org.apache.pekko.japi.function.Predicate)">dropWhile</a></span>&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</code></th>
<td class="colLast">
<div class="block">Discard elements at the beginning of the stream while predicate is true.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dropWithin(java.time.Duration)">dropWithin</a></span>&#8203;(java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Discard the elements received within the given duration at beginning of the stream.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dropWithin(scala.concurrent.duration.FiniteDuration)">dropWithin</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#empty()">empty</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> with no elements, i.e.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#empty(java.lang.Class)">empty</a></span>&#8203;(java.lang.Class&lt;T&gt;&nbsp;clazz)</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> with no elements.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#expand(org.apache.pekko.japi.function.Function)">expand</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.Iterator&lt;U&gt;&gt;&nbsp;expander)</code></th>
<td class="colLast">
<div class="block">Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
 element until new element comes from the upstream.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extrapolate(org.apache.pekko.japi.function.Function)">extrapolate</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.Iterator&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&gt;&nbsp;extrapolator)</code></th>
<td class="colLast">
<div class="block">Allows a faster downstream to progress independent of a slower upstream.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extrapolate(org.apache.pekko.japi.function.Function,Out)">extrapolate</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.Iterator&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&gt;&nbsp;extrapolator,
           <a href="Source.html" title="type parameter in Source">Out</a>&nbsp;initial)</code></th>
<td class="colLast">
<div class="block">Allows a faster downstream to progress independent of a slower upstream.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#failed(java.lang.Throwable)">failed</a></span>&#8203;(java.lang.Throwable&nbsp;cause)</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> that immediately ends the stream with the <code>cause</code> failure to every connected <code>Sink</code>.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#filter(org.apache.pekko.japi.function.Predicate)">filter</a></span>&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</code></th>
<td class="colLast">
<div class="block">Only pass on those elements that satisfy the given predicate.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#filterNot(org.apache.pekko.japi.function.Predicate)">filterNot</a></span>&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</code></th>
<td class="colLast">
<div class="block">Only pass on those elements that NOT satisfy the given predicate.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapConcat(org.apache.pekko.japi.function.Function)">flatMapConcat</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Transform each input element into a <code>Source</code> of output elements that is
 then flattened into the output stream by concatenation,
 fully consuming one Source after the other.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMerge(int,org.apache.pekko.japi.function.Function)">flatMapMerge</a></span>&#8203;(int&nbsp;breadth,
            <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Transform each input element into a <code>Source</code> of output elements that is
 then flattened into the output stream by merging, where at most <code>breadth</code>
 substreams are being consumed at any given time.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Mat2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out2,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapPrefix(int,org.apache.pekko.japi.function.Function)">flatMapPrefix</a></span>&#8203;(int&nbsp;n,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Iterable&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Flow.html" title="class in org.apache.pekko.stream.javadsl">Flow</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Mat2&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Takes up to <code>n</code> elements from the stream (less than <code>n</code> only if the upstream completes before emitting <code>n</code> elements),
 then apply <code>f</code> on these elements in order to obtain a flow, this flow is then materialized and the rest of the input is processed by this flow (similar to via).</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out2,&#8203;Mat3&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapPrefixMat(int,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">flatMapPrefixMat</a></span>&#8203;(int&nbsp;n,
                <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Iterable&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Flow.html" title="class in org.apache.pekko.stream.javadsl">Flow</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Mat2&gt;&gt;&nbsp;f,
                <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;java.util.concurrent.CompletionStage&lt;Mat2&gt;,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">mat version of <a href="#flatMapPrefix(int,org.apache.pekko.japi.function.Function)"><code>flatMapPrefix(int, org.apache.pekko.japi.function.Function&lt;java.lang.Iterable&lt;Out&gt;, org.apache.pekko.stream.javadsl.Flow&lt;Out, Out2, Mat2&gt;&gt;)</code></a>, this method gives access to a future materialized value of the downstream flow (as a completion stage).</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fold(T,org.apache.pekko.japi.function.Function2)">fold</a></span>&#8203;(T&nbsp;zero,
    <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Similar to <code>scan</code> but only emits its result when the upstream completes,
 after which it also completes.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#foldAsync(T,org.apache.pekko.japi.function.Function2)">foldAsync</a></span>&#8203;(T&nbsp;zero,
         <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Similar to <code>fold</code> but with an asynchronous function.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#from(java.lang.Iterable)">from</a></span>&#8203;(java.lang.Iterable&lt;O&gt;&nbsp;iterable)</code></th>
<td class="colLast">
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> from <code>Iterable</code>.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromCompletionStage(java.util.concurrent.CompletionStage)">fromCompletionStage</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;O&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.completionStage' instead.</div>
</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromFuture(scala.concurrent.Future)">fromFuture</a></span>&#8203;(scala.concurrent.Future&lt;O&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.future' instead.</div>
</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromFutureSource(scala.concurrent.Future)">fromFutureSource</a></span>&#8203;(scala.concurrent.Future&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.futureSource' (potentially together with `Source.fromGraph`) instead.</div>
</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromGraph(org.apache.pekko.stream.Graph)">fromGraph</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;g)</code></th>
<td class="colLast">
<div class="block">A graph with the shape of a source logically is a source, this method makes
 it so also in type.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromIterator(org.apache.pekko.japi.function.Creator)">fromIterator</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.Iterator&lt;O&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> from <code>Iterator</code>.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>static &lt;O,&#8203;S extends java.util.stream.BaseStream&lt;O,&#8203;S&gt;&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromJavaStream(org.apache.pekko.japi.function.Creator)">fromJavaStream</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.stream.BaseStream&lt;O,&#8203;S&gt;&gt;&nbsp;stream)</code></th>
<td class="colLast">
<div class="block">Creates a source that wraps a Java 8 <code></code>Stream<code></code>.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromMaterializer(java.util.function.BiFunction)">fromMaterializer</a></span>&#8203;(java.util.function.BiFunction&lt;<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</code></th>
<td class="colLast">
<div class="block">Defers the creation of a <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> until materialization.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromPublisher(org.reactivestreams.Publisher)">fromPublisher</a></span>&#8203;(org.reactivestreams.Publisher&lt;O&gt;&nbsp;publisher)</code></th>
<td class="colLast">
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> from <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromSourceCompletionStage(java.util.concurrent.CompletionStage)">fromSourceCompletionStage</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;completion)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.completionStageSource' (potentially together with `Source.fromGraph`) instead.</div>
</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#future(scala.concurrent.Future)">future</a></span>&#8203;(scala.concurrent.Future&lt;T&gt;&nbsp;futureElement)</code></th>
<td class="colLast">
<div class="block">Emits a single value when the given Scala <code>Future</code> is successfully completed and then completes the stream.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code><a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAttributes()">getAttributes</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>&lt;K&gt;&nbsp;<a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupBy(int,org.apache.pekko.japi.function.Function)">groupBy</a></span>&#8203;(int&nbsp;maxSubstreams,
       <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;K&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">This operation demultiplexes the incoming stream into separate output
 streams, one for each element key.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>&lt;K&gt;&nbsp;<a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupBy(int,org.apache.pekko.japi.function.Function,boolean)">groupBy</a></span>&#8203;(int&nbsp;maxSubstreams,
       <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;K&gt;&nbsp;f,
       boolean&nbsp;allowClosedSubstreamRecreation)</code></th>
<td class="colLast">
<div class="block">This operation demultiplexes the incoming stream into separate output
 streams, one for each element key.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#grouped(int)">grouped</a></span>&#8203;(int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Chunk up this stream into groups of the given size, with the last group
 possibly smaller than requested due to end-of-stream.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupedWeighted(long,java.util.function.Function)">groupedWeighted</a></span>&#8203;(long&nbsp;minWeight,
               java.util.function.Function&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn)</code></th>
<td class="colLast">
<div class="block">Chunk up this stream into groups of elements that have a cumulative weight greater than or equal to
 the <code>minWeight</code>, with the last group possibly smaller than requested <code>minWeight</code> due to end-of-stream.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupedWeightedWithin(long,int,org.apache.pekko.japi.function.Function,java.time.Duration)">groupedWeightedWithin</a></span>&#8203;(long&nbsp;maxWeight,
                     int&nbsp;maxNumber,
                     <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn,
                     java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Chunk up this stream into groups of elements received within a time window,
 or limited by the weight and number of the elements, whatever happens first.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupedWeightedWithin(long,org.apache.pekko.japi.function.Function,java.time.Duration)">groupedWeightedWithin</a></span>&#8203;(long&nbsp;maxWeight,
                     <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn,
                     java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Chunk up this stream into groups of elements received within a time window,
 or limited by the weight of the elements, whatever happens first.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupedWeightedWithin(long,org.apache.pekko.japi.function.Function,scala.concurrent.duration.FiniteDuration)">groupedWeightedWithin</a></span>&#8203;(long&nbsp;maxWeight,
                     <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn,
                     scala.concurrent.duration.FiniteDuration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupedWithin(int,java.time.Duration)">groupedWithin</a></span>&#8203;(int&nbsp;maxNumber,
             java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Chunk up this stream into groups of elements received within a time window,
 or limited by the given number of elements, whatever happens first.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupedWithin(int,scala.concurrent.duration.FiniteDuration)">groupedWithin</a></span>&#8203;(int&nbsp;maxNumber,
             scala.concurrent.duration.FiniteDuration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(java.time.Duration)">idleTimeout</a></span>&#8203;(java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">If the time between two processed elements exceeds the provided timeout, the stream is failed
 with a <code>TimeoutException</code>.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(scala.concurrent.duration.FiniteDuration)">idleTimeout</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initialDelay(java.time.Duration)">initialDelay</a></span>&#8203;(java.time.Duration&nbsp;delay)</code></th>
<td class="colLast">
<div class="block">Delays the initial element by the specified duration.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initialDelay(scala.concurrent.duration.FiniteDuration)">initialDelay</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initialTimeout(java.time.Duration)">initialTimeout</a></span>&#8203;(java.time.Duration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block">If the first element has not passed through this operator before the provided timeout, the stream is failed
 with a <code>TimeoutException</code>.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initialTimeout(scala.concurrent.duration.FiniteDuration)">initialTimeout</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;timeout)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#interleave(org.apache.pekko.stream.Graph,int)">interleave</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that,
          int&nbsp;segmentSize)</code></th>
<td class="colLast">
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#interleave(org.apache.pekko.stream.Graph,int,boolean)">interleave</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that,
          int&nbsp;segmentSize,
          boolean&nbsp;eagerClose)</code></th>
<td class="colLast">
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#interleaveAll(java.util.List,int,boolean)">interleaveAll</a></span>&#8203;(java.util.List&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&gt;&nbsp;those,
             int&nbsp;segmentSize,
             boolean&nbsp;eagerClose)</code></th>
<td class="colLast">
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#interleaveMat(org.apache.pekko.stream.Graph,int,boolean,org.apache.pekko.japi.function.Function2)">interleaveMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
             int&nbsp;segmentSize,
             boolean&nbsp;eagerClose,
             <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#interleaveMat(org.apache.pekko.stream.Graph,int,org.apache.pekko.japi.function.Function2)">interleaveMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
             int&nbsp;segmentSize,
             <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersperse(Out)">intersperse</a></span>&#8203;(<a href="Source.html" title="type parameter in Source">Out</a>&nbsp;inject)</code></th>
<td class="colLast">
<div class="block">Intersperses stream with provided element, similar to how <code>scala.collection.immutable.List.mkString</code>
 injects a separator between a List's elements.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersperse(Out,Out,Out)">intersperse</a></span>&#8203;(<a href="Source.html" title="type parameter in Source">Out</a>&nbsp;start,
           <a href="Source.html" title="type parameter in Source">Out</a>&nbsp;inject,
           <a href="Source.html" title="type parameter in Source">Out</a>&nbsp;end)</code></th>
<td class="colLast">
<div class="block">Intersperses stream with provided element, similar to how <code>scala.collection.immutable.List.mkString</code>
 injects a separator between a List's elements.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#keepAlive(java.time.Duration,org.apache.pekko.japi.function.Creator)">keepAlive</a></span>&#8203;(java.time.Duration&nbsp;maxIdle,
         <a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;injectedElem)</code></th>
<td class="colLast">
<div class="block">Injects additional elements if upstream does not emit for a configured amount of time.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#keepAlive(scala.concurrent.duration.FiniteDuration,org.apache.pekko.japi.function.Creator)">keepAlive</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;maxIdle,
         <a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;injectedElem)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazily(org.apache.pekko.japi.function.Creator)">lazily</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.lazySource' instead.</div>
</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazilyAsync(org.apache.pekko.japi.function.Creator)">lazilyAsync</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.lazyCompletionStage' instead.</div>
</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazyCompletionStage(org.apache.pekko.japi.function.Creator)">lazyCompletionStage</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a future element until there is downstream demand.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazyCompletionStageSource(org.apache.pekko.japi.function.Creator)">lazyCompletionStageSource</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.concurrent.CompletionStage&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a future source until there is downstream demand.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazySingle(org.apache.pekko.japi.function.Creator)">lazySingle</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;T&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a single element until there is downstream demand.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazySource(org.apache.pekko.japi.function.Creator)">lazySource</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a future source until there is downstream demand.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#limit(int)">limit</a></span>&#8203;(int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Ensure stream boundedness by limiting the number of elements from upstream.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#limitWeighted(long,org.apache.pekko.japi.function.Function)">limitWeighted</a></span>&#8203;(long&nbsp;n,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn)</code></th>
<td class="colLast">
<div class="block">Ensure stream boundedness by evaluating the cost of incoming elements
 using a cost function.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#log(java.lang.String)">log</a></span>&#8203;(java.lang.String&nbsp;name)</code></th>
<td class="colLast">
<div class="block">Logs elements flowing through the stream as well as completion and erroring.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#log(java.lang.String,org.apache.pekko.event.LoggingAdapter)">log</a></span>&#8203;(java.lang.String&nbsp;name,
   <a href="../../event/LoggingAdapter.html" title="interface in org.apache.pekko.event">LoggingAdapter</a>&nbsp;log)</code></th>
<td class="colLast">
<div class="block">Logs elements flowing through the stream as well as completion and erroring.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#log(java.lang.String,org.apache.pekko.japi.function.Function)">log</a></span>&#8203;(java.lang.String&nbsp;name,
   <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;extract)</code></th>
<td class="colLast">
<div class="block">Logs elements flowing through the stream as well as completion and erroring.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#log(java.lang.String,org.apache.pekko.japi.function.Function,org.apache.pekko.event.LoggingAdapter)">log</a></span>&#8203;(java.lang.String&nbsp;name,
   <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;extract,
   <a href="../../event/LoggingAdapter.html" title="interface in org.apache.pekko.event">LoggingAdapter</a>&nbsp;log)</code></th>
<td class="colLast">
<div class="block">Logs elements flowing through the stream as well as completion and erroring.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#logWithMarker(java.lang.String,org.apache.pekko.japi.function.Function)">logWithMarker</a></span>&#8203;(java.lang.String&nbsp;name,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../event/LogMarker.html" title="class in org.apache.pekko.event">LogMarker</a>&gt;&nbsp;marker)</code></th>
<td class="colLast">
<div class="block">Logs elements flowing through the stream as well as completion and erroring.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#logWithMarker(java.lang.String,org.apache.pekko.japi.function.Function,org.apache.pekko.event.MarkerLoggingAdapter)">logWithMarker</a></span>&#8203;(java.lang.String&nbsp;name,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../event/LogMarker.html" title="class in org.apache.pekko.event">LogMarker</a>&gt;&nbsp;marker,
             <a href="../../event/MarkerLoggingAdapter.html" title="class in org.apache.pekko.event">MarkerLoggingAdapter</a>&nbsp;log)</code></th>
<td class="colLast">
<div class="block">Logs elements flowing through the stream as well as completion and erroring.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#logWithMarker(java.lang.String,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function)">logWithMarker</a></span>&#8203;(java.lang.String&nbsp;name,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../event/LogMarker.html" title="class in org.apache.pekko.event">LogMarker</a>&gt;&nbsp;marker,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;extract)</code></th>
<td class="colLast">
<div class="block">Logs elements flowing through the stream as well as completion and erroring.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#logWithMarker(java.lang.String,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function,org.apache.pekko.event.MarkerLoggingAdapter)">logWithMarker</a></span>&#8203;(java.lang.String&nbsp;name,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../event/LogMarker.html" title="class in org.apache.pekko.event">LogMarker</a>&gt;&nbsp;marker,
             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;extract,
             <a href="../../event/MarkerLoggingAdapter.html" title="class in org.apache.pekko.event">MarkerLoggingAdapter</a>&nbsp;log)</code></th>
<td class="colLast">
<div class="block">Logs elements flowing through the stream as well as completion and erroring.</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#map(org.apache.pekko.japi.function.Function)">map</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Transform this stream by applying the given function to each of the elements
 as they pass through this processing step.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapAsync(int,org.apache.pekko.japi.function.Function)">mapAsync</a></span>&#8203;(int&nbsp;parallelism,
        <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Transform this stream by applying the given function to each of the elements
 as they pass through this processing step.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapAsyncUnordered(int,org.apache.pekko.japi.function.Function)">mapAsyncUnordered</a></span>&#8203;(int&nbsp;parallelism,
                 <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Transform this stream by applying the given function to each of the elements
 as they pass through this processing step.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapConcat(org.apache.pekko.japi.function.Function)">mapConcat</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;? extends java.lang.Iterable&lt;T&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Transform each input element into an <code>Iterable</code> of output elements that is
 then flattened into the output stream.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapError(java.lang.Class,org.apache.pekko.japi.function.Function)">mapError</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;clazz,
        <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;E,&#8203;java.lang.Throwable&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">While similar to <a href="#recover(scala.PartialFunction)"><code>recover(scala.PartialFunction&lt;java.lang.Throwable,Out&gt;)</code></a> this operator can be used to transform an error signal to a different one *without* logging
 it as an error in the process.</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapError(scala.PartialFunction)">mapError</a></span>&#8203;(scala.PartialFunction&lt;java.lang.Throwable,&#8203;java.lang.Throwable&gt;&nbsp;pf)</code></th>
<td class="colLast">
<div class="block">While similar to <a href="#recover(scala.PartialFunction)"><code>recover(scala.PartialFunction&lt;java.lang.Throwable,Out&gt;)</code></a> this operator can be used to transform an error signal to a different one *without* logging
 it as an error in the process.</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>&lt;Mat2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Mat2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapMaterializedValue(org.apache.pekko.japi.function.Function)">mapMaterializedValue</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Transform only the materialized value of this Source, leaving all other properties as they were.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletableFuture&lt;java.util.Optional&lt;T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#maybe()">maybe</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> which materializes a <code>CompletableFuture</code> which controls what element
 will be emitted by the Source.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#merge(org.apache.pekko.stream.Graph)">merge</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that)</code></th>
<td class="colLast">
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#merge(org.apache.pekko.stream.Graph,boolean)">merge</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that,
     boolean&nbsp;eagerComplete)</code></th>
<td class="colLast">
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeAll(java.util.List,boolean)">mergeAll</a></span>&#8203;(java.util.List&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&gt;&nbsp;those,
        boolean&nbsp;eagerComplete)</code></th>
<td class="colLast">
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeLatest(org.apache.pekko.stream.Graph,boolean)">mergeLatest</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
           boolean&nbsp;eagerComplete)</code></th>
<td class="colLast">
<div class="block">MergeLatest joins elements from N input streams into stream of lists of size N.</div>
</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code>&lt;Mat2,&#8203;Mat3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat3&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeLatestMat(org.apache.pekko.stream.Graph,boolean,org.apache.pekko.japi.function.Function2)">mergeLatestMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
              boolean&nbsp;eagerComplete,
              <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">MergeLatest joins elements from N input streams into stream of lists of size N.</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">mergeMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
        <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.</div>
</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2,boolean)">mergeMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
        <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF,
        boolean&nbsp;eagerComplete)</code></th>
<td class="colLast">
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.</div>
</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergePreferred(org.apache.pekko.stream.Graph,boolean,boolean)">mergePreferred</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
              boolean&nbsp;preferred,
              boolean&nbsp;eagerComplete)</code></th>
<td class="colLast">
<div class="block">Merge two sources.</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code>&lt;Mat2,&#8203;Mat3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Mat3&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergePreferredMat(org.apache.pekko.stream.Graph,boolean,boolean,org.apache.pekko.japi.function.Function2)">mergePreferredMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
                 boolean&nbsp;preferred,
                 boolean&nbsp;eagerComplete,
                 <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Merge two sources.</div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergePrioritized(org.apache.pekko.stream.Graph,int,int,boolean)">mergePrioritized</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                int&nbsp;leftPriority,
                int&nbsp;rightPriority,
                boolean&nbsp;eagerComplete)</code></th>
<td class="colLast">
<div class="block">Merge two sources.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code>&lt;Mat2,&#8203;Mat3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Mat3&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergePrioritizedMat(org.apache.pekko.stream.Graph,int,int,boolean,org.apache.pekko.japi.function.Function2)">mergePrioritizedMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
                   int&nbsp;leftPriority,
                   int&nbsp;rightPriority,
                   boolean&nbsp;eagerComplete,
                   <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Merge multiple sources.</div>
</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergePrioritizedN(java.util.List,boolean)">mergePrioritizedN</a></span>&#8203;(java.util.List&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;,&#8203;java.lang.Integer&gt;&gt;&nbsp;sourcesAndPriorities,
                 boolean&nbsp;eagerComplete)</code></th>
<td class="colLast">
<div class="block">Merge multiple <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s.</div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeSorted(org.apache.pekko.stream.Graph,java.util.Comparator)">mergeSorted</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
           java.util.Comparator&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;comp)</code></th>
<td class="colLast">
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, taking elements as they arrive from input streams,
 picking always the smallest of the available elements (waiting for one element from each side
 to be available).</div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code>&lt;Mat2,&#8203;Mat3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Mat3&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeSortedMat(org.apache.pekko.stream.Graph,java.util.Comparator,org.apache.pekko.japi.function.Function2)">mergeSortedMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
              java.util.Comparator&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;comp,
              <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, taking elements as they arrive from input streams,
 picking always the smallest of the available elements (waiting for one element from each side
 to be available).</div>
</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#monitor()">monitor</a></span>()</code></th>
<td class="colLast">
<div class="block">Materializes to <code>Pair<Mat, FlowMonitor<<Out>></code>, which is unlike most other operators (!),
 in which usually the default materialized value keeping semantics is to keep the left value
 (by passing <code>Keep.left()</code> to a <code>*Mat</code> version of a method).</div>
</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#monitor(org.apache.pekko.japi.function.Function2)">monitor</a></span>&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use monitor() or monitorMat(combine) instead.</div>
</div>
</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#monitorMat(org.apache.pekko.japi.function.Function2)">monitorMat</a></span>&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Materializes to <code>FlowMonitor[Out]</code> that allows monitoring of the current flow.</div>
</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#named(java.lang.String)">named</a></span>&#8203;(java.lang.String&nbsp;name)</code></th>
<td class="colLast">
<div class="block">Add a <code></code>name<code></code> attribute to this Source.</div>
</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#never()">never</a></span>()</code></th>
<td class="colLast">
<div class="block">Never emits any elements, never completes and never fails.</div>
</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#orElse(org.apache.pekko.stream.Graph)">orElse</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;secondary)</code></th>
<td class="colLast">
<div class="block">Provides a secondary source that will be consumed if this source completes without any
 elements passing by.</div>
</td>
</tr>
<tr id="i145" class="rowColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#orElseMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">orElseMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;secondary,
         <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Provides a secondary source that will be consumed if this source completes without any
 elements passing by.</div>
</td>
</tr>
<tr id="i146" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prefixAndTail(int)">prefixAndTail</a></span>&#8203;(int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Takes up to <code>n</code> elements from the stream (less than <code>n</code> if the upstream completes before emitting <code>n</code> elements)
 and returns a pair containing a strict sequence of the taken element
 and a stream representing the remaining elements.</div>
</td>
</tr>
<tr id="i147" class="rowColor">
<td class="colFirst"><code><a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#preMaterialize(org.apache.pekko.actor.ClassicActorSystemProvider)">preMaterialize</a></span>&#8203;(<a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</code></th>
<td class="colLast">
<div class="block">Materializes this Source, immediately returning (1) its materialized value, and (2) a new Source
 that can be used to consume elements from the newly materialized Source.</div>
</td>
</tr>
<tr id="i148" class="altColor">
<td class="colFirst"><code><a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#preMaterialize(org.apache.pekko.stream.Materializer)">preMaterialize</a></span>&#8203;(<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</code></th>
<td class="colLast">
<div class="block">Materializes this Source, immediately returning (1) its materialized value, and (2) a new Source
 that can be used to consume elements from the newly materialized Source.</div>
</td>
</tr>
<tr id="i149" class="rowColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prepend(org.apache.pekko.stream.Graph)">prepend</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that)</code></th>
<td class="colLast">
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this one, meaning that once the given source
 is exhausted and all result elements have been generated, the current source's
 elements will be produced.</div>
</td>
</tr>
<tr id="i150" class="altColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prependLazy(org.apache.pekko.stream.Graph)">prependLazy</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that)</code></th>
<td class="colLast">
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that before elements
 are generated from this Flow, the Source's elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.</div>
</td>
</tr>
<tr id="i151" class="rowColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prependLazyMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">prependLazyMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
              <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that before elements
 are generated from this Flow, the Source's elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.</div>
</td>
</tr>
<tr id="i152" class="altColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prependMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">prependMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
          <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this one, meaning that once the given source
 is exhausted and all result elements have been generated, the current source's
 elements will be produced.</div>
</td>
</tr>
<tr id="i153" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../BoundedSourceQueue.html" title="interface in org.apache.pekko.stream">BoundedSourceQueue</a>&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queue(int)">queue</a></span>&#8203;(int&nbsp;bufferSize)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.BoundedSourceQueue</code>.</div>
</td>
</tr>
<tr id="i154" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="SourceQueueWithComplete.html" title="interface in org.apache.pekko.stream.javadsl">SourceQueueWithComplete</a>&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queue(int,org.apache.pekko.stream.OverflowStrategy)">queue</a></span>&#8203;(int&nbsp;bufferSize,
     <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.javadsl.SourceQueueWithComplete</code>.</div>
</td>
</tr>
<tr id="i155" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="SourceQueueWithComplete.html" title="interface in org.apache.pekko.stream.javadsl">SourceQueueWithComplete</a>&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queue(int,org.apache.pekko.stream.OverflowStrategy,int)">queue</a></span>&#8203;(int&nbsp;bufferSize,
     <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy,
     int&nbsp;maxConcurrentOffers)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.javadsl.SourceQueueWithComplete</code>.</div>
</td>
</tr>
<tr id="i156" class="altColor">
<td class="colFirst"><code>static <a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.lang.Integer,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#range(int,int)">range</a></span>&#8203;(int&nbsp;start,
     int&nbsp;end)</code></th>
<td class="colLast">
<div class="block">Creates <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> that represents integer values in range ''[start;end]'', step equals to 1.</div>
</td>
</tr>
<tr id="i157" class="rowColor">
<td class="colFirst"><code>static <a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.lang.Integer,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#range(int,int,int)">range</a></span>&#8203;(int&nbsp;start,
     int&nbsp;end,
     int&nbsp;step)</code></th>
<td class="colLast">
<div class="block">Creates <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> that represents integer values in range ''[start;end]'', with the given step.</div>
</td>
</tr>
<tr id="i158" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recover(java.lang.Class,java.util.function.Supplier)">recover</a></span>&#8203;(java.lang.Class&lt;? extends java.lang.Throwable&gt;&nbsp;clazz,
       java.util.function.Supplier&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;supplier)</code></th>
<td class="colLast">
<div class="block">Recover allows to send last element on failure and gracefully complete the stream
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.</div>
</td>
</tr>
<tr id="i159" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recover(scala.PartialFunction)">recover</a></span>&#8203;(scala.PartialFunction&lt;java.lang.Throwable,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;pf)</code></th>
<td class="colLast">
<div class="block">Recover allows to send last element on failure and gracefully complete the stream
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.</div>
</td>
</tr>
<tr id="i160" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recoverWith(java.lang.Class,java.util.function.Supplier)">recoverWith</a></span>&#8203;(java.lang.Class&lt;? extends java.lang.Throwable&gt;&nbsp;clazz,
           java.util.function.Supplier&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;supplier)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">use <code>recoverWithRetries</code> instead</div>
</div>
</td>
</tr>
<tr id="i161" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recoverWith(scala.PartialFunction)">recoverWith</a></span>&#8203;(scala.PartialFunction&lt;java.lang.Throwable,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;pf)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">use <code>recoverWithRetries</code> instead</div>
</div>
</td>
</tr>
<tr id="i162" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recoverWithRetries(int,java.lang.Class,java.util.function.Supplier)">recoverWithRetries</a></span>&#8203;(int&nbsp;attempts,
                  java.lang.Class&lt;? extends java.lang.Throwable&gt;&nbsp;clazz,
                  java.util.function.Supplier&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;supplier)</code></th>
<td class="colLast">
<div class="block">RecoverWithRetries allows to switch to alternative Source on flow failure.</div>
</td>
</tr>
<tr id="i163" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recoverWithRetries(int,scala.PartialFunction)">recoverWithRetries</a></span>&#8203;(int&nbsp;attempts,
                  scala.PartialFunction&lt;java.lang.Throwable,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;pf)</code></th>
<td class="colLast">
<div class="block">RecoverWithRetries allows to switch to alternative Source on flow failure.</div>
</td>
</tr>
<tr id="i164" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reduce(org.apache.pekko.japi.function.Function2)">reduce</a></span>&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Similar to <code>fold</code> but uses first element as zero element.</div>
</td>
</tr>
<tr id="i165" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeat(T)">repeat</a></span>&#8203;(T&nbsp;element)</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> that will continually emit the given element.</div>
</td>
</tr>
<tr id="i166" class="altColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#run(org.apache.pekko.actor.ClassicActorSystemProvider)">run</a></span>&#8203;(<a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</code></th>
<td class="colLast">
<div class="block">Connect this <code>Source</code> to the <code>Sink.ignore</code> and run it.</div>
</td>
</tr>
<tr id="i167" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#run(org.apache.pekko.stream.Materializer)">run</a></span>&#8203;(<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</code></th>
<td class="colLast">
<div class="block">Connect this <code>Source</code> to the <code>Sink.ignore</code> and run it.</div>
</td>
</tr>
<tr id="i168" class="altColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;java.util.concurrent.CompletionStage&lt;U&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runFold(U,org.apache.pekko.japi.function.Function2,org.apache.pekko.actor.ClassicActorSystemProvider)">runFold</a></span>&#8203;(U&nbsp;zero,
       <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;U&gt;&nbsp;f,
       <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</code></th>
<td class="colLast">
<div class="block">Shortcut for running this <code>Source</code> with a fold function.</div>
</td>
</tr>
<tr id="i169" class="rowColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;java.util.concurrent.CompletionStage&lt;U&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runFold(U,org.apache.pekko.japi.function.Function2,org.apache.pekko.stream.Materializer)">runFold</a></span>&#8203;(U&nbsp;zero,
       <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;U&gt;&nbsp;f,
       <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</code></th>
<td class="colLast">
<div class="block">Shortcut for running this <code>Source</code> with a fold function.</div>
</td>
</tr>
<tr id="i170" class="altColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;java.util.concurrent.CompletionStage&lt;U&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runFoldAsync(U,org.apache.pekko.japi.function.Function2,org.apache.pekko.actor.ClassicActorSystemProvider)">runFoldAsync</a></span>&#8203;(U&nbsp;zero,
            <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;U&gt;&gt;&nbsp;f,
            <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</code></th>
<td class="colLast">
<div class="block">Shortcut for running this <code>Source</code> with an asynchronous fold function.</div>
</td>
</tr>
<tr id="i171" class="rowColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;java.util.concurrent.CompletionStage&lt;U&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runFoldAsync(U,org.apache.pekko.japi.function.Function2,org.apache.pekko.stream.Materializer)">runFoldAsync</a></span>&#8203;(U&nbsp;zero,
            <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;U&gt;&gt;&nbsp;f,
            <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</code></th>
<td class="colLast">
<div class="block">Shortcut for running this <code>Source</code> with an asynchronous fold function.</div>
</td>
</tr>
<tr id="i172" class="altColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runForeach(org.apache.pekko.japi.function.Procedure,org.apache.pekko.actor.ClassicActorSystemProvider)">runForeach</a></span>&#8203;(<a href="../../japi/function/Procedure.html" title="interface in org.apache.pekko.japi.function">Procedure</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f,
          <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</code></th>
<td class="colLast">
<div class="block">Shortcut for running this <code>Source</code> with a foreach procedure.</div>
</td>
</tr>
<tr id="i173" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runForeach(org.apache.pekko.japi.function.Procedure,org.apache.pekko.stream.Materializer)">runForeach</a></span>&#8203;(<a href="../../japi/function/Procedure.html" title="interface in org.apache.pekko.japi.function">Procedure</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f,
          <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</code></th>
<td class="colLast">
<div class="block">Shortcut for running this <code>Source</code> with a foreach procedure.</div>
</td>
</tr>
<tr id="i174" class="altColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runReduce(org.apache.pekko.japi.function.Function2,org.apache.pekko.actor.ClassicActorSystemProvider)">runReduce</a></span>&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f,
         <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</code></th>
<td class="colLast">
<div class="block">Shortcut for running this <code>Source</code> with a reduce function.</div>
</td>
</tr>
<tr id="i175" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runReduce(org.apache.pekko.japi.function.Function2,org.apache.pekko.stream.Materializer)">runReduce</a></span>&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f,
         <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</code></th>
<td class="colLast">
<div class="block">Shortcut for running this <code>Source</code> with a reduce function.</div>
</td>
</tr>
<tr id="i176" class="altColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;M</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runWith(org.apache.pekko.stream.Graph,org.apache.pekko.actor.ClassicActorSystemProvider)">runWith</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;sink,
       <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</code></th>
<td class="colLast">
<div class="block">Connect this <code>Source</code> to a <code>Sink</code> and run it.</div>
</td>
</tr>
<tr id="i177" class="rowColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;M</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runWith(org.apache.pekko.stream.Graph,org.apache.pekko.stream.Materializer)">runWith</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;sink,
       <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</code></th>
<td class="colLast">
<div class="block">Connect this <code>Source</code> to a <code>Sink</code> and run it.</div>
</td>
</tr>
<tr id="i178" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scan(T,org.apache.pekko.japi.function.Function2)">scan</a></span>&#8203;(T&nbsp;zero,
    <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Similar to <code>fold</code> but is not a terminal operation,
 emits its current value which starts at <code>zero</code> and then
 applies the current and next value to the given function <code>f</code>,
 emitting the next current value.</div>
</td>
</tr>
<tr id="i179" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scanAsync(T,org.apache.pekko.japi.function.Function2)">scanAsync</a></span>&#8203;(T&nbsp;zero,
         <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Similar to <code>scan</code> but with a asynchronous function,
 emits its current value which starts at <code>zero</code> and then
 applies the current and next value to the given function <code>f</code>,
 emitting a <code>Future</code> that resolves to the next current value.</div>
</td>
</tr>
<tr id="i180" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setup(java.util.function.BiFunction)">setup</a></span>&#8203;(java.util.function.BiFunction&lt;<a href="../ActorMaterializer.html" title="class in org.apache.pekko.stream">ActorMaterializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'fromMaterializer' instead.</div>
</div>
</td>
</tr>
<tr id="i181" class="rowColor">
<td class="colFirst"><code><a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shape()">shape</a></span>()</code></th>
<td class="colLast">
<div class="block">The shape of a graph is all that is externally visible: its inlets and outlets.</div>
</td>
</tr>
<tr id="i182" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#single(T)">single</a></span>&#8203;(T&nbsp;element)</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> with one element.</div>
</td>
</tr>
<tr id="i183" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sliding(int,int)">sliding</a></span>&#8203;(int&nbsp;n,
       int&nbsp;step)</code></th>
<td class="colLast">
<div class="block">Apply a sliding window over the stream and return the windows as groups of elements, with the last group
 possibly smaller than requested due to end-of-stream.</div>
</td>
</tr>
<tr id="i184" class="altColor">
<td class="colFirst"><code><a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#splitAfter(org.apache.pekko.japi.function.Predicate)">splitAfter</a></span>&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</code></th>
<td class="colLast">
<div class="block">This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams.</div>
</td>
</tr>
<tr id="i185" class="rowColor">
<td class="colFirst"><code><a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#splitAfter(org.apache.pekko.stream.SubstreamCancelStrategy,org.apache.pekko.japi.function.Predicate)">splitAfter</a></span>&#8203;(<a href="../SubstreamCancelStrategy.html" title="class in org.apache.pekko.stream">SubstreamCancelStrategy</a>&nbsp;substreamCancelStrategy,
          <a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</code></th>
<td class="colLast">
<div class="block">This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams.</div>
</td>
</tr>
<tr id="i186" class="altColor">
<td class="colFirst"><code><a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#splitWhen(org.apache.pekko.japi.function.Predicate)">splitWhen</a></span>&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</code></th>
<td class="colLast">
<div class="block">This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams, always beginning a new one with
 the current element if the given predicate returns true for it.</div>
</td>
</tr>
<tr id="i187" class="rowColor">
<td class="colFirst"><code><a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#splitWhen(org.apache.pekko.stream.SubstreamCancelStrategy,org.apache.pekko.japi.function.Predicate)">splitWhen</a></span>&#8203;(<a href="../SubstreamCancelStrategy.html" title="class in org.apache.pekko.stream">SubstreamCancelStrategy</a>&nbsp;substreamCancelStrategy,
         <a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</code></th>
<td class="colLast">
<div class="block">This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams, always beginning a new one with
 the current element if the given predicate returns true for it.</div>
</td>
</tr>
<tr id="i188" class="altColor">
<td class="colFirst"><code>&lt;S,&#8203;T&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#statefulMap(org.apache.pekko.japi.function.Creator,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function)">statefulMap</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;S&gt;&nbsp;create,
           <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;S,&#8203;T&gt;&gt;&nbsp;f,
           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.Optional&lt;T&gt;&gt;&nbsp;onComplete)</code></th>
<td class="colLast">
<div class="block">Transform each stream element with the help of a state.</div>
</td>
</tr>
<tr id="i189" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#statefulMapConcat(org.apache.pekko.japi.function.Creator)">statefulMapConcat</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Iterable&lt;T&gt;&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Transform each input element into an <code>Iterable</code> of output elements that is
 then flattened into the output stream.</div>
</td>
</tr>
<tr id="i190" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#take(long)">take</a></span>&#8203;(long&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Terminate processing (and cancel the upstream publisher) after the given
 number of elements.</div>
</td>
</tr>
<tr id="i191" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#takeWhile(org.apache.pekko.japi.function.Predicate)">takeWhile</a></span>&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</code></th>
<td class="colLast">
<div class="block">Terminate processing (and cancel the upstream publisher) after predicate
 returns false for the first time.</div>
</td>
</tr>
<tr id="i192" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#takeWhile(org.apache.pekko.japi.function.Predicate,boolean)">takeWhile</a></span>&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p,
         boolean&nbsp;inclusive)</code></th>
<td class="colLast">
<div class="block">Terminate processing (and cancel the upstream publisher) after predicate
 returns false for the first time, including the first failed element if inclusive is true
 Due to input buffering some elements may have been requested from upstream publishers
 that will then not be processed downstream of this step.</div>
</td>
</tr>
<tr id="i193" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#takeWithin(java.time.Duration)">takeWithin</a></span>&#8203;(java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Terminate processing (and cancel the upstream publisher) after the given
 duration.</div>
</td>
</tr>
<tr id="i194" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#takeWithin(scala.concurrent.duration.FiniteDuration)">takeWithin</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i195" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttle(int,java.time.Duration)">throttle</a></span>&#8203;(int&nbsp;elements,
        java.time.Duration&nbsp;per)</code></th>
<td class="colLast">
<div class="block">Sends elements downstream with speed limited to <code>elements/per</code>.</div>
</td>
</tr>
<tr id="i196" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttle(int,java.time.Duration,int,org.apache.pekko.japi.function.Function,org.apache.pekko.stream.ThrottleMode)">throttle</a></span>&#8203;(int&nbsp;cost,
        java.time.Duration&nbsp;per,
        int&nbsp;maximumBurst,
        <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Integer&gt;&nbsp;costCalculation,
        <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</code></th>
<td class="colLast">
<div class="block">Sends elements downstream with speed limited to <code>cost/per</code>.</div>
</td>
</tr>
<tr id="i197" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttle(int,java.time.Duration,int,org.apache.pekko.stream.ThrottleMode)">throttle</a></span>&#8203;(int&nbsp;elements,
        java.time.Duration&nbsp;per,
        int&nbsp;maximumBurst,
        <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</code></th>
<td class="colLast">
<div class="block">Sends elements downstream with speed limited to <code>elements/per</code>.</div>
</td>
</tr>
<tr id="i198" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttle(int,java.time.Duration,org.apache.pekko.japi.function.Function)">throttle</a></span>&#8203;(int&nbsp;cost,
        java.time.Duration&nbsp;per,
        <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Integer&gt;&nbsp;costCalculation)</code></th>
<td class="colLast">
<div class="block">Sends elements downstream with speed limited to <code>cost/per</code>.</div>
</td>
</tr>
<tr id="i199" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttle(int,scala.concurrent.duration.FiniteDuration,int,org.apache.pekko.japi.function.Function,org.apache.pekko.stream.ThrottleMode)">throttle</a></span>&#8203;(int&nbsp;cost,
        scala.concurrent.duration.FiniteDuration&nbsp;per,
        int&nbsp;maximumBurst,
        <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Integer&gt;&nbsp;costCalculation,
        <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i200" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttle(int,scala.concurrent.duration.FiniteDuration,int,org.apache.pekko.stream.ThrottleMode)">throttle</a></span>&#8203;(int&nbsp;elements,
        scala.concurrent.duration.FiniteDuration&nbsp;per,
        int&nbsp;maximumBurst,
        <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i201" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttleEven(int,java.time.Duration,org.apache.pekko.stream.ThrottleMode)">throttleEven</a></span>&#8203;(int&nbsp;elements,
            java.time.Duration&nbsp;per,
            <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use throttle without `maximumBurst` parameter instead.</div>
</div>
</td>
</tr>
<tr id="i202" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttleEven(int,java.time.Duration,scala.Function1,org.apache.pekko.stream.ThrottleMode)">throttleEven</a></span>&#8203;(int&nbsp;cost,
            java.time.Duration&nbsp;per,
            scala.Function1&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;costCalculation,
            <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use throttle without `maximumBurst` parameter instead.</div>
</div>
</td>
</tr>
<tr id="i203" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttleEven(int,scala.concurrent.duration.FiniteDuration,org.apache.pekko.stream.ThrottleMode)">throttleEven</a></span>&#8203;(int&nbsp;elements,
            scala.concurrent.duration.FiniteDuration&nbsp;per,
            <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use throttle without `maximumBurst` parameter instead.</div>
</div>
</td>
</tr>
<tr id="i204" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throttleEven(int,scala.concurrent.duration.FiniteDuration,scala.Function1,org.apache.pekko.stream.ThrottleMode)">throttleEven</a></span>&#8203;(int&nbsp;cost,
            scala.concurrent.duration.FiniteDuration&nbsp;per,
            scala.Function1&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;costCalculation,
            <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use throttle without `maximumBurst` parameter instead.</div>
</div>
</td>
</tr>
<tr id="i205" class="rowColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../actor/Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tick(java.time.Duration,java.time.Duration,O)">tick</a></span>&#8203;(java.time.Duration&nbsp;initialDelay,
    java.time.Duration&nbsp;interval,
    O&nbsp;tick)</code></th>
<td class="colLast">
<div class="block">Elements are emitted periodically with the specified interval.</div>
</td>
</tr>
<tr id="i206" class="altColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../actor/Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tick(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,O)">tick</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
    scala.concurrent.duration.FiniteDuration&nbsp;interval,
    O&nbsp;tick)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead.</div>
</div>
</td>
</tr>
<tr id="i207" class="rowColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="RunnableGraph.html" title="class in org.apache.pekko.stream.javadsl">RunnableGraph</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#to(org.apache.pekko.stream.Graph)">to</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;sink)</code></th>
<td class="colLast">
<div class="block">Connect this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to a <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>, concatenating the processing steps of both.</div>
</td>
</tr>
<tr id="i208" class="altColor">
<td class="colFirst"><code>&lt;M,&#8203;M2&gt;<br><a href="RunnableGraph.html" title="class in org.apache.pekko.stream.javadsl">RunnableGraph</a>&lt;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">toMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;sink,
     <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Connect this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to a <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>, concatenating the processing steps of both.</div>
</td>
</tr>
<tr id="i209" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i210" class="altColor">
<td class="colFirst"><code>org.apache.pekko.stream.impl.LinearTraversalBuilder</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#traversalBuilder()">traversalBuilder</a></span>()</code></th>
<td class="colLast">
<div class="block">INTERNAL API.</div>
</td>
</tr>
<tr id="i211" class="rowColor">
<td class="colFirst"><code>static &lt;S,&#8203;E&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;E,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unfold(S,org.apache.pekko.japi.function.Function)">unfold</a></span>&#8203;(S&nbsp;s,
      <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.Optional&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;S,&#8203;E&gt;&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> that will unfold a value of type <code>S</code> into
 a pair of the next state <code>S</code> and output elements of type <code>E</code>.</div>
</td>
</tr>
<tr id="i212" class="altColor">
<td class="colFirst"><code>static &lt;S,&#8203;E&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;E,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unfoldAsync(S,org.apache.pekko.japi.function.Function)">unfoldAsync</a></span>&#8203;(S&nbsp;s,
           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.concurrent.CompletionStage&lt;java.util.Optional&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;S,&#8203;E&gt;&gt;&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Same as <a href="#unfold(S,org.apache.pekko.japi.function.Function)"><code>&lt;S,E&gt;unfold(S,org.apache.pekko.japi.function.Function&lt;S,java.util.Optional&lt;org.apache.pekko.japi.Pair&lt;S,E&gt;&gt;&gt;)</code></a>, but uses an async function to generate the next state-element tuple.</div>
</td>
</tr>
<tr id="i213" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;S&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unfoldResource(org.apache.pekko.japi.function.Creator,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Procedure)">unfoldResource</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;S&gt;&nbsp;create,
              <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.Optional&lt;T&gt;&gt;&nbsp;read,
              <a href="../../japi/function/Procedure.html" title="interface in org.apache.pekko.japi.function">Procedure</a>&lt;S&gt;&nbsp;close)</code></th>
<td class="colLast">
<div class="block">Start a new <code>Source</code> from some resource which can be opened, read and closed.</div>
</td>
</tr>
<tr id="i214" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;S&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unfoldResourceAsync(org.apache.pekko.japi.function.Creator,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function)">unfoldResourceAsync</a></span>&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.concurrent.CompletionStage&lt;S&gt;&gt;&nbsp;create,
                   <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.concurrent.CompletionStage&lt;java.util.Optional&lt;T&gt;&gt;&gt;&nbsp;read,
                   <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;&nbsp;close)</code></th>
<td class="colLast">
<div class="block">Start a new <code>Source</code> from some resource which can be opened, read and closed.</div>
</td>
</tr>
<tr id="i215" class="rowColor">
<td class="colFirst"><code>static &lt;SuperOut,&#8203;Out extends SuperOut,&#8203;Mat&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;SuperOut,&#8203;Mat&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#upcast(org.apache.pekko.stream.javadsl.Source)">upcast</a></span>&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out,&#8203;Mat&gt;&nbsp;source)</code></th>
<td class="colLast">
<div class="block">Upcast a stream of elements to a stream of supertypes of that element.</div>
</td>
</tr>
<tr id="i216" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#via(org.apache.pekko.stream.Graph)">via</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../FlowShape.html" title="class in org.apache.pekko.stream">FlowShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;M&gt;&nbsp;flow)</code></th>
<td class="colLast">
<div class="block">Transform this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> by appending the given processing operators.</div>
</td>
</tr>
<tr id="i217" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#viaMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">viaMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../FlowShape.html" title="class in org.apache.pekko.stream">FlowShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;M&gt;&nbsp;flow,
      <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Transform this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> by appending the given processing operators.</div>
</td>
</tr>
<tr id="i218" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#watch(org.apache.pekko.actor.ActorRef)">watch</a></span>&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref)</code></th>
<td class="colLast">
<div class="block">The operator fails with an <code>pekko.stream.WatchedActorTerminatedException</code> if the target actor is terminated.</div>
</td>
</tr>
<tr id="i219" class="rowColor">
<td class="colFirst"><code>&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#watchTermination(org.apache.pekko.japi.function.Function2)">watchTermination</a></span>&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;,&#8203;M&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Materializes to <code>Future[Done]</code> that completes on getting termination message.</div>
</td>
</tr>
<tr id="i220" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#wireTap(org.apache.pekko.japi.function.Procedure)">wireTap</a></span>&#8203;(<a href="../../japi/function/Procedure.html" title="interface in org.apache.pekko.japi.function">Procedure</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">This is a simplified version of <code>wireTap(Sink)</code> that takes only a simple procedure.</div>
</td>
</tr>
<tr id="i221" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#wireTap(org.apache.pekko.stream.Graph)">wireTap</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> as a wire tap, meaning that elements that pass
 through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.</div>
</td>
</tr>
<tr id="i222" class="altColor">
<td class="colFirst"><code>&lt;M2,&#8203;M3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M3&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#wireTapMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">wireTapMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M2&gt;&nbsp;that,
          <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M2,&#8203;M3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> as a wire tap, meaning that elements that pass
 through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.</div>
</td>
</tr>
<tr id="i223" class="rowColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withAttributes(org.apache.pekko.stream.Attributes)">withAttributes</a></span>&#8203;(<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>&nbsp;attr)</code></th>
<td class="colLast">
<div class="block">Replace the attributes of this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with the given ones.</div>
</td>
</tr>
<tr id="i224" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zip(org.apache.pekko.stream.Graph)">zip</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;?&gt;&nbsp;that)</code></th>
<td class="colLast">
<div class="block">Combine the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one into a stream of tuples.</div>
</td>
</tr>
<tr id="i225" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;A&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;A,&#8203;U&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipAll(org.apache.pekko.stream.Graph,A,U)">zipAll</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;?&gt;&nbsp;that,
      A&nbsp;thisElem,
      U&nbsp;thatElem)</code></th>
<td class="colLast">
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> into a stream of tuples.</div>
</td>
</tr>
<tr id="i226" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3,&#8203;A&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;A,&#8203;U&gt;,&#8203;Mat3&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipAllMat(org.apache.pekko.stream.Graph,A,U,scala.Function2)">zipAllMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
         A&nbsp;thisElem,
         U&nbsp;thatElem,
         scala.Function2&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> into a stream of tuples.</div>
</td>
</tr>
<tr id="i227" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipLatest(org.apache.pekko.stream.Graph)">zipLatest</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;?&gt;&nbsp;that)</code></th>
<td class="colLast">
<div class="block">Combine the elements of 2 streams into a stream of tuples, picking always the latest element of each.</div>
</td>
</tr>
<tr id="i228" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipLatestMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">zipLatestMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;that,
            <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Combine the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one into a stream of tuples, picking always the latest element of each.</div>
</td>
</tr>
<tr id="i229" class="rowColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Out3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipLatestWith(org.apache.pekko.stream.Graph,boolean,org.apache.pekko.japi.function.Function2)">zipLatestWith</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;?&gt;&nbsp;that,
             boolean&nbsp;eagerComplete,
             <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Combine the elements of multiple streams into a stream of combined elements using a combiner function,
 picking always the latest of the elements of each source.</div>
</td>
</tr>
<tr id="i230" class="altColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Out3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipLatestWith(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">zipLatestWith</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;?&gt;&nbsp;that,
             <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Combine the elements of multiple streams into a stream of combined elements using a combiner function,
 picking always the latest of the elements of each source.</div>
</td>
</tr>
<tr id="i231" class="rowColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Out3,&#8203;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipLatestWithMat(org.apache.pekko.stream.Graph,boolean,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function2)">zipLatestWithMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;M&gt;&nbsp;that,
                boolean&nbsp;eagerComplete,
                <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Put together the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one
 into a stream of combined elements using a combiner function,
 picking always the latest of the elements of each source.</div>
</td>
</tr>
<tr id="i232" class="altColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Out3,&#8203;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipLatestWithMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function2)">zipLatestWithMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;M&gt;&nbsp;that,
                <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Put together the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one
 into a stream of combined elements using a combiner function,
 picking always the latest of the elements of each source.</div>
</td>
</tr>
<tr id="i233" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">zipMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;that,
      <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Combine the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one into a stream of tuples.</div>
</td>
</tr>
<tr id="i234" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;T&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipN(java.util.List)">zipN</a></span>&#8203;(java.util.List&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;sources)</code></th>
<td class="colLast">
<div class="block">Combine the elements of multiple streams into a stream of lists.</div>
</td>
</tr>
<tr id="i235" class="rowColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Out3&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipWith(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">zipWith</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;?&gt;&nbsp;that,
       <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Put together the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one
 into a stream of combined elements using a combiner function.</div>
</td>
</tr>
<tr id="i236" class="altColor">
<td class="colFirst"><code><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipWithIndex()">zipWithIndex</a></span>()</code></th>
<td class="colLast">
<div class="block">Combine the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> into a stream of tuples consisting
 of all elements paired with their index.</div>
</td>
</tr>
<tr id="i237" class="rowColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Out3,&#8203;M,&#8203;M2&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;M2&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipWithMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function2)">zipWithMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;M&gt;&nbsp;that,
          <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
          <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Put together the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one
 into a stream of combined elements using a combiner function.</div>
</td>
</tr>
<tr id="i238" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;O&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipWithN(org.apache.pekko.japi.function.Function,java.util.List)">zipWithN</a></span>&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.util.List&lt;T&gt;,&#8203;O&gt;&nbsp;zipper,
        java.util.List&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;sources)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;(org.apache.pekko.stream.scaladsl.Source)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Source</h4>
<pre>public&nbsp;Source&#8203;(<a href="../scaladsl/Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;delegate)</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="empty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>empty</h4>
<pre class="methodSignature">public static&nbsp;&lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;empty()</pre>
<div class="block">Create a <code>Source</code> with no elements, i.e. an empty stream that is completed immediately
 for every connected <code>Sink</code>.</div>
</li>
</ul>
<a id="empty(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>empty</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;empty&#8203;(java.lang.Class&lt;T&gt;&nbsp;clazz)</pre>
<div class="block">Create a <code>Source</code> with no elements. The result is the same as calling <code>Source.<O>empty()</code></div>
</li>
</ul>
<a id="maybe()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maybe</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletableFuture&lt;java.util.Optional&lt;T&gt;&gt;&gt;&nbsp;maybe()</pre>
<div class="block">Create a <code>Source</code> which materializes a <code>CompletableFuture</code> which controls what element
 will be emitted by the Source.
 If the materialized promise is completed with a filled Optional, that value will be produced downstream,
 followed by completion.
 If the materialized promise is completed with an empty Optional, no value will be produced downstream and completion will
 be signalled immediately.
 If the materialized promise is completed with a failure, then the source will fail with that error.
 If the downstream of this source cancels or fails before the promise has been completed, then the promise will be completed
 with an empty Optional.</div>
</li>
</ul>
<a id="fromPublisher(org.reactivestreams.Publisher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromPublisher</h4>
<pre class="methodSignature">public static&nbsp;&lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromPublisher&#8203;(org.reactivestreams.Publisher&lt;O&gt;&nbsp;publisher)</pre>
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> from <code>Publisher</code>.
 <p>
 Construct a transformation starting with given publisher. The transformation steps
 are executed by a series of <code>Processor</code> instances
 that mediate the flow of elements downstream and the propagation of
 back-pressure upstream.</div>
</li>
</ul>
<a id="fromIterator(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromIterator</h4>
<pre class="methodSignature">public static&nbsp;&lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromIterator&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.Iterator&lt;O&gt;&gt;&nbsp;f)</pre>
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> from <code>Iterator</code>.
 Example usage:
 <p>
 <pre><code>
 List&lt;Integer&gt; data = new ArrayList&lt;Integer&gt;();
 data.add(1);
 data.add(2);
 data.add(3);
 Source.from(() -&gt; data.iterator());
 </code></pre>
 <p>
 Start a new <code>Source</code> from the given Iterator. The produced stream of elements
 will continue until the iterator runs empty or fails during evaluation of
 the <code>next()</code> method. Elements are pulled out of the iterator
 in accordance with the demand coming from the downstream transformation
 steps.</div>
</li>
</ul>
<a id="fromJavaStream(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromJavaStream</h4>
<pre class="methodSignature">public static&nbsp;&lt;O,&#8203;S extends java.util.stream.BaseStream&lt;O,&#8203;S&gt;&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromJavaStream&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.stream.BaseStream&lt;O,&#8203;S&gt;&gt;&nbsp;stream)</pre>
<div class="block">Creates a source that wraps a Java 8 <code></code>Stream<code></code>. <code></code>Source<code></code> uses a stream iterator to get all its
 elements and send them downstream on demand.
 <p>
 You can use <code>Source.async</code> to create asynchronous boundaries between synchronous java stream
 and the rest of flow.</div>
</li>
</ul>
<a id="cycle(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cycle</h4>
<pre class="methodSignature">public static&nbsp;&lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;cycle&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.Iterator&lt;O&gt;&gt;&nbsp;f)</pre>
<div class="block">Helper to create 'cycled' <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> from iterator provider.
 Example usage:
 <p>
 <pre><code>
 Source.cycle(() -&gt; Arrays.asList(1, 2, 3).iterator());
 </code></pre>
 <p>
 Start a new 'cycled' <code>Source</code> from the given elements. The producer stream of elements
 will continue infinitely by repeating the sequence of elements provided by function parameter.</div>
</li>
</ul>
<a id="from(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>from</h4>
<pre class="methodSignature">public static&nbsp;&lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;from&#8203;(java.lang.Iterable&lt;O&gt;&nbsp;iterable)</pre>
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> from <code>Iterable</code>.
 Example usage:
 <pre><code>
 List&lt;Integer&gt; data = new ArrayList&lt;Integer&gt;();
 data.add(1);
 data.add(2);
 data.add(3);
 Source.from(data);
 </code></pre>
 <p>
 Starts a new <code>Source</code> from the given <code>Iterable</code>. This is like starting from an
 Iterator, but every Subscriber directly attached to the Publisher of this
 stream will see an individual flow of elements (always starting from the
 beginning) regardless of when they subscribed.
 <p>
 Make sure that the <code>Iterable</code> is immutable or at least not modified after
 being used as a <code>Source</code>. Otherwise the stream may fail with
 <code>ConcurrentModificationException</code> or other more subtle errors may occur.</div>
</li>
</ul>
<a id="range(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>range</h4>
<pre class="methodSignature">public static&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.lang.Integer,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;range&#8203;(int&nbsp;start,
                                                            int&nbsp;end)</pre>
<div class="block">Creates <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> that represents integer values in range ''[start;end]'', step equals to 1.
 It allows to create <code>Source</code> out of range as simply as on Scala <code>Source(1 to N)</code>
 <p>
 Uses {@link scala.collection.immutable.Range.inclusive(Int, Int)} internally
 <p></div>
</li>
</ul>
<a id="range(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>range</h4>
<pre class="methodSignature">public static&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.lang.Integer,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;range&#8203;(int&nbsp;start,
                                                            int&nbsp;end,
                                                            int&nbsp;step)</pre>
<div class="block">Creates <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> that represents integer values in range ''[start;end]'', with the given step.
 It allows to create <code>Source</code> out of range as simply as on Scala <code>Source(1 to N)</code>
 <p>
 Uses {@link scala.collection.immutable.Range.inclusive(Int, Int, Int)} internally
 <p></div>
</li>
</ul>
<a id="fromFuture(scala.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromFuture&#8203;(scala.concurrent.Future&lt;O&gt;&nbsp;future)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.future' instead. Since 2.6.0.</div>
</div>
<div class="block">Start a new <code>Source</code> from the given <code>Future</code>. The stream will consist of
 one element when the <code>Future</code> is completed with a successful value, which
 may happen before or after materializing the <code>Flow</code>.
 The stream terminates with a failure if the <code>Future</code> is completed with a failure.</div>
</li>
</ul>
<a id="fromCompletionStage(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromCompletionStage</h4>
<pre class="methodSignature">public static&nbsp;&lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromCompletionStage&#8203;(java.util.concurrent.CompletionStage&lt;O&gt;&nbsp;future)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.completionStage' instead. Since 2.6.0.</div>
</div>
<div class="block">Starts a new <code>Source</code> from the given <code>CompletionStage</code>. The stream will consist of
 one element when the <code>CompletionStage</code> is completed with a successful value, which
 may happen before or after materializing the <code>Flow</code>.
 The stream terminates with a failure if the <code>CompletionStage</code> is completed with a failure.</div>
</li>
</ul>
<a id="fromFutureSource(scala.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromFutureSource</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;fromFutureSource&#8203;(scala.concurrent.Future&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;future)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.futureSource' (potentially together with `Source.fromGraph`) instead. Since 2.6.0.</div>
</div>
<div class="block">Streams the elements of the given future source once it successfully completes.
 If the <code>Future</code> fails the stream is failed with the exception from the future. If downstream cancels before the
 stream completes the materialized <code>Future</code> will be failed with a <code>StreamDetachedException</code>.</div>
</li>
</ul>
<a id="fromSourceCompletionStage(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromSourceCompletionStage</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;&nbsp;fromSourceCompletionStage&#8203;(java.util.concurrent.CompletionStage&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;completion)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.completionStageSource' (potentially together with `Source.fromGraph`) instead. Since 2.6.0.</div>
</div>
<div class="block">Streams the elements of an asynchronous source once its given <code>CompletionStage</code> completes.
 If the <code>CompletionStage</code> fails the stream is failed with the exception from the future.
 If downstream cancels before the stream completes the materialized <code>CompletionStage</code> will be failed
 with a <code>StreamDetachedException</code></div>
</li>
</ul>
<a id="tick(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Object)">
<!--   -->
</a><a id="tick(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,O)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tick</h4>
<pre class="methodSignature">public static&nbsp;&lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../actor/Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&gt;&nbsp;tick&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                                                   scala.concurrent.duration.FiniteDuration&nbsp;interval,
                                                   O&nbsp;tick)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Elements are emitted periodically with the specified interval.
 The tick element will be delivered to downstream consumers that has requested any elements.
 If a consumer has not requested any elements at the point in time when the tick
 element is produced it will not receive that tick element later. It will
 receive new tick elements as soon as it has requested more elements.</div>
</li>
</ul>
<a id="tick(java.time.Duration,java.time.Duration,java.lang.Object)">
<!--   -->
</a><a id="tick(java.time.Duration,java.time.Duration,O)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tick</h4>
<pre class="methodSignature">public static&nbsp;&lt;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../actor/Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&gt;&nbsp;tick&#8203;(java.time.Duration&nbsp;initialDelay,
                                                   java.time.Duration&nbsp;interval,
                                                   O&nbsp;tick)</pre>
<div class="block">Elements are emitted periodically with the specified interval.
 The tick element will be delivered to downstream consumers that has requested any elements.
 If a consumer has not requested any elements at the point in time when the tick
 element is produced it will not receive that tick element later. It will
 receive new tick elements as soon as it has requested more elements.</div>
</li>
</ul>
<a id="single(java.lang.Object)">
<!--   -->
</a><a id="single(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>single</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;single&#8203;(T&nbsp;element)</pre>
<div class="block">Create a <code>Source</code> with one element.
 Every connected <code>Sink</code> of this stream will see an individual stream consisting of one element.</div>
</li>
</ul>
<a id="repeat(java.lang.Object)">
<!--   -->
</a><a id="repeat(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;repeat&#8203;(T&nbsp;element)</pre>
<div class="block">Create a <code>Source</code> that will continually emit the given element.</div>
</li>
</ul>
<a id="unfold(java.lang.Object,org.apache.pekko.japi.function.Function)">
<!--   -->
</a><a id="unfold(S,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unfold</h4>
<pre class="methodSignature">public static&nbsp;&lt;S,&#8203;E&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;E,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;unfold&#8203;(S&nbsp;s,
                                                         <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.Optional&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;S,&#8203;E&gt;&gt;&gt;&nbsp;f)</pre>
<div class="block">Create a <code>Source</code> that will unfold a value of type <code>S</code> into
 a pair of the next state <code>S</code> and output elements of type <code>E</code>.</div>
</li>
</ul>
<a id="unfoldAsync(java.lang.Object,org.apache.pekko.japi.function.Function)">
<!--   -->
</a><a id="unfoldAsync(S,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unfoldAsync</h4>
<pre class="methodSignature">public static&nbsp;&lt;S,&#8203;E&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;E,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;unfoldAsync&#8203;(S&nbsp;s,
                                                              <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.concurrent.CompletionStage&lt;java.util.Optional&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;S,&#8203;E&gt;&gt;&gt;&gt;&nbsp;f)</pre>
<div class="block">Same as <a href="#unfold(S,org.apache.pekko.japi.function.Function)"><code>&lt;S,E&gt;unfold(S,org.apache.pekko.japi.function.Function&lt;S,java.util.Optional&lt;org.apache.pekko.japi.Pair&lt;S,E&gt;&gt;&gt;)</code></a>, but uses an async function to generate the next state-element tuple.</div>
</li>
</ul>
<a id="failed(java.lang.Throwable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>failed</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;failed&#8203;(java.lang.Throwable&nbsp;cause)</pre>
<div class="block">Create a <code>Source</code> that immediately ends the stream with the <code>cause</code> failure to every connected <code>Sink</code>.</div>
</li>
</ul>
<a id="lazily(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazily</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;&nbsp;lazily&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.lazySource' instead. Since 2.6.0.</div>
</div>
<div class="block">Creates a <code>Source</code> that is not materialized until there is downstream demand, when the source gets materialized
 the materialized future is completed with its value, if downstream cancels or fails without any demand the
 <code>create</code> factory is never called and the materialized <code>CompletionStage</code> is failed.</div>
</li>
</ul>
<a id="lazilyAsync(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazilyAsync</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;lazilyAsync&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;create)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.lazyCompletionStage' instead. Since 2.6.0.</div>
</div>
<div class="block">Creates a <code>Source</code> from supplied future factory that is not called until downstream demand. When source gets
 materialized the materialized future is completed with the value from the factory. If downstream cancels or fails
 without any demand the create factory is never called and the materialized <code>Future</code> is failed.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Source.lazily</code></dd>
</dl>
</li>
</ul>
<a id="future(scala.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>future</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;future&#8203;(scala.concurrent.Future&lt;T&gt;&nbsp;futureElement)</pre>
<div class="block">Emits a single value when the given Scala <code>Future</code> is successfully completed and then completes the stream.
 The stream fails if the <code>Future</code> is completed with a failure.
 <p>
 Here for Java interoperability, the normal use from Java should be <code>Source.completionStage</code></div>
</li>
</ul>
<a id="never()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>never</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;never()</pre>
<div class="block">Never emits any elements, never completes and never fails.
 This stream could be useful in tests.</div>
</li>
</ul>
<a id="completionStage(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completionStage</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;completionStage&#8203;(java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;completionStage)</pre>
<div class="block">Emits a single value when the given <code>CompletionStage</code> is successfully completed and then completes the stream.
 If the <code>CompletionStage</code> is completed with a failure the stream is failed.</div>
</li>
</ul>
<a id="completionStageSource(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completionStageSource</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;&nbsp;completionStageSource&#8203;(java.util.concurrent.CompletionStage&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;completionStageSource)</pre>
<div class="block">Turn a <code>CompletionStage[Source]</code> into a source that will emit the values of the source when the future completes successfully.
 If the <code>CompletionStage</code> is completed with a failure the stream is failed.</div>
</li>
</ul>
<a id="lazySingle(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazySingle</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;lazySingle&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;T&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a single element until there is downstream demand.
 <p>
 If the <code>create</code> function fails when invoked the stream is failed.
 <p>
 Note that asynchronous boundaries (and other operators) in the stream may do pre-fetching which counter acts
 the laziness and will trigger the factory immediately.
 <p>
 The materialized future <code>Done</code> value is completed when the <code>create</code> function has successfully been invoked,
 if the function throws the future materialized value is failed with that exception.
 If downstream cancels or fails before the function is invoked the materialized value
 is failed with a <code>pekko.stream.NeverMaterializedException</code></div>
</li>
</ul>
<a id="lazyCompletionStage(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazyCompletionStage</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;lazyCompletionStage&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a future element until there is downstream demand.
 <p>
 The returned future element will be emitted downstream when it completes, or fail the stream if the future
 is failed or the <code>create</code> function itself fails.
 <p>
 Note that asynchronous boundaries (and other operators) in the stream may do pre-fetching which counter acts
 the laziness and will trigger the factory immediately.
 <p>
 The materialized future <code>Done</code> value is completed when the <code>create</code> function has successfully been invoked and the future completes,
 if the function throws or the future fails the future materialized value is failed with that exception.
 If downstream cancels or fails before the function is invoked the materialized value
 is failed with a <code>pekko.stream.NeverMaterializedException</code></div>
</li>
</ul>
<a id="lazySource(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazySource</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;&nbsp;lazySource&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a future source until there is downstream demand.
 <p>
 The returned source will emit downstream and behave just like it was the outer source. Downstream completes
 when the created source completes and fails when the created source fails.
 <p>
 Note that asynchronous boundaries (and other operators) in the stream may do pre-fetching which counter acts
 the laziness and will trigger the factory immediately.
 <p>
 The materialized future value is completed with the materialized value of the created source when
 it has been materialized. If the function throws or the source materialization fails the future materialized value
 is failed with the thrown exception.
 <p>
 If downstream cancels or fails before the function is invoked the materialized value
 is failed with a <code>pekko.stream.NeverMaterializedException</code></div>
</li>
</ul>
<a id="lazyCompletionStageSource(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazyCompletionStageSource</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;&nbsp;lazyCompletionStageSource&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.concurrent.CompletionStage&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a future source until there is downstream demand.
 <p>
 The returned future source will emit downstream and behave just like it was the outer source when the <code>CompletionStage</code> completes
 successfully. Downstream completes when the created source completes and fails when the created source fails.
 If the <code>CompletionStage</code> or the <code>create</code> function fails the stream is failed.
 <p>
 Note that asynchronous boundaries (and other operators) in the stream may do pre-fetching which counter acts
 the laziness and triggers the factory immediately.
 <p>
 The materialized <code>CompletionStage</code> value is completed with the materialized value of the created source when
 it has been materialized. If the function throws or the source materialization fails the future materialized value
 is failed with the thrown exception.
 <p>
 If downstream cancels or fails before the function is invoked the materialized value
 is failed with a <code>pekko.stream.NeverMaterializedException</code></div>
</li>
</ul>
<a id="asSubscriber()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asSubscriber</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;org.reactivestreams.Subscriber&lt;T&gt;&gt;&nbsp;asSubscriber()</pre>
<div class="block">Creates a <code>Source</code> that is materialized as a <code>Subscriber</code></div>
</li>
</ul>
<a id="actorRef(org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function,int,org.apache.pekko.stream.OverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRef</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;actorRef&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&gt;&nbsp;completionMatcher,
                                                    <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;java.lang.Throwable&gt;&gt;&nbsp;failureMatcher,
                                                    int&nbsp;bufferSize,
                                                    <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received.
 <p>
 Depending on the defined <code>pekko.stream.OverflowStrategy</code> it might drop elements if
 there is no space available in the buffer.
 <p>
 The strategy <code>pekko.stream.OverflowStrategy.backpressure</code> is not supported, and an
 IllegalArgument("Backpressure overflowStrategy not supported") will be thrown if it is passed as argument.
 <p>
 The buffer can be disabled by using <code>bufferSize</code> of 0 and then received messages are dropped if there is no demand
 from downstream. When <code>bufferSize</code> is 0 the <code>overflowStrategy</code> does not matter.
 <p>
 The stream can be completed successfully by sending the actor reference a message that is matched by
 <code>completionMatcher</code> in which case already buffered elements will be signaled before signaling
 completion.
 <p>
 The stream can be completed with failure by sending a message that is matched by <code>failureMatcher</code>. The extracted
 <code>Throwable</code> will be used to fail the stream. In case the Actor is still draining its internal buffer (after having received
 a message matched by <code>completionMatcher</code>) before signaling completion and it receives a message matched by <code>failureMatcher</code>,
 the failure will be signaled downstream immediately (instead of the completion signal).
 <p>
 Note that terminating the actor without first completing it, either with a success or a
 failure, will prevent the actor triggering downstream completion and the stream will continue
 to run even though the source actor is dead. Therefore you should **not** attempt to
 manually terminate the actor such as with a <code>pekko.actor.PoisonPill</code>.
 <p>
 The actor will be stopped when the stream is completed, failed or canceled from downstream,
 i.e. you can watch it to get notified when that happens.
 <p>
 See also <code>pekko.stream.scaladsl.Source.queue</code>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completionMatcher</code> - catches the completion message to end the stream</dd>
<dd><code>failureMatcher</code> - catches the failure message to fail the stream</dd>
<dd><code>bufferSize</code> - The size of the buffer in element count</dd>
<dd><code>overflowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="actorRef(int,org.apache.pekko.stream.OverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRef</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;actorRef&#8203;(int&nbsp;bufferSize,
                                                    <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use variant accepting completion and failure matchers. Since 2.6.0.</div>
</div>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received.
 <p>
 Depending on the defined <code>pekko.stream.OverflowStrategy</code> it might drop elements if
 there is no space available in the buffer.
 <p>
 The strategy <code>pekko.stream.OverflowStrategy.backpressure</code> is not supported, and an
 IllegalArgument("Backpressure overflowStrategy not supported") will be thrown if it is passed as argument.
 <p>
 The buffer can be disabled by using <code>bufferSize</code> of 0 and then received messages are dropped if there is no demand
 from downstream. When <code>bufferSize</code> is 0 the <code>overflowStrategy</code> does not matter.
 <p>
 The stream can be completed successfully by sending the actor reference a <code>pekko.actor.Status.Success</code>
 (whose content will be ignored) in which case already buffered elements will be signaled before signaling
 completion.
 <p>
 The stream can be completed successfully by sending the actor reference a <code>pekko.actor.Status.Success</code>.
 If the content is <code>pekko.stream.CompletionStrategy.immediately</code> the completion will be signaled immediately,
 otherwise if the content is <code>pekko.stream.CompletionStrategy.draining</code> (or anything else)
 already buffered elements will be signaled before signaling completion.
 Sending <code>pekko.actor.PoisonPill</code> will signal completion immediately but this behavior is deprecated and scheduled to be removed.
 <p>
 The stream can be completed with failure by sending a <code>pekko.actor.Status.Failure</code> to the
 actor reference. In case the Actor is still draining its internal buffer (after having received
 a <code>pekko.actor.Status.Success</code>) before signaling completion and it receives a <code>pekko.actor.Status.Failure</code>,
 the failure will be signaled downstream immediately (instead of the completion signal).
 <p>
 Note that terminating the actor without first completing it, either with a success or a
 failure, will prevent the actor triggering downstream completion and the stream will continue
 to run even though the source actor is dead. Therefore you should **not** attempt to
 manually terminate the actor such as with a <code>pekko.actor.PoisonPill</code>.
 <p>
 The actor will be stopped when the stream is completed, failed or canceled from downstream,
 i.e. you can watch it to get notified when that happens.
 <p>
 See also <code>pekko.stream.javadsl.Source.queue</code>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bufferSize</code> - The size of the buffer in element count</dd>
<dd><code>overflowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="actorRefWithBackpressure(java.lang.Object,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithBackpressure</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;actorRefWithBackpressure&#8203;(java.lang.Object&nbsp;ackMessage,
                                                                    <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&gt;&nbsp;completionMatcher,
                                                                    <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;java.lang.Throwable&gt;&gt;&nbsp;failureMatcher)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 and a new message will only be accepted after the previous messages has been consumed and acknowledged back.
 The stream will complete with failure if a message is sent before the acknowledgement has been replied back.
 <p>
 The stream can be completed with failure by sending a message that is matched by <code>failureMatcher</code>. The extracted
 <code>Throwable</code> will be used to fail the stream. In case the Actor is still draining its internal buffer (after having received
 a message matched by <code>completionMatcher</code>) before signaling completion and it receives a message matched by <code>failureMatcher</code>,
 the failure will be signaled downstream immediately (instead of the completion signal).
 <p>
 The actor will be stopped when the stream is completed, failed or canceled from downstream,
 i.e. you can watch it to get notified when that happens.</div>
</li>
</ul>
<a id="actorRefWithAck(java.lang.Object,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithAck</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;actorRefWithAck&#8203;(java.lang.Object&nbsp;ackMessage,
                                                           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&gt;&nbsp;completionMatcher,
                                                           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Object,&#8203;java.util.Optional&lt;java.lang.Throwable&gt;&gt;&nbsp;failureMatcher)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use actorRefWithBackpressure instead</div>
</div>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 and a new message will only be accepted after the previous messages has been consumed and acknowledged back.
 The stream will complete with failure if a message is sent before the acknowledgement has been replied back.
 <p>
 The stream can be completed with failure by sending a message that is matched by <code>failureMatcher</code>. The extracted
 <code>Throwable</code> will be used to fail the stream. In case the Actor is still draining its internal buffer (after having received
 a message matched by <code>completionMatcher</code>) before signaling completion and it receives a message matched by <code>failureMatcher</code>,
 the failure will be signaled downstream immediately (instead of the completion signal).
 <p>
 The actor will be stopped when the stream is completed, failed or canceled from downstream,
 i.e. you can watch it to get notified when that happens.
 <p></div>
</li>
</ul>
<a id="actorRefWithAck(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithAck</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;actorRefWithAck&#8203;(java.lang.Object&nbsp;ackMessage)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use actorRefWithBackpressure accepting completion and failure matchers. Since 2.6.0.</div>
</div>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 and a new message will only be accepted after the previous messages has been consumed and acknowledged back.
 The stream will complete with failure if a message is sent before the acknowledgement has been replied back.
 <p>
 The stream can be completed successfully by sending the actor reference a <code>pekko.actor.Status.Success</code>.
 If the content is <code>pekko.stream.CompletionStrategy.immediately</code> the completion will be signaled immediately,
 otherwise if the content is <code>pekko.stream.CompletionStrategy.draining</code> (or anything else)
 already buffered element will be signaled before signaling completion.
 <p>
 The stream can be completed with failure by sending a <code>pekko.actor.Status.Failure</code> to the
 actor reference. In case the Actor is still draining its internal buffer (after having received
 a <code>pekko.actor.Status.Success</code>) before signaling completion and it receives a <code>pekko.actor.Status.Failure</code>,
 the failure will be signaled downstream immediately (instead of the completion signal).
 <p>
 The actor will be stopped when the stream is completed, failed or canceled from downstream,
 i.e. you can watch it to get notified when that happens.</div>
</li>
</ul>
<a id="fromGraph(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromGraph</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&nbsp;fromGraph&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;g)</pre>
<div class="block">A graph with the shape of a source logically is a source, this method makes
 it so also in type.</div>
</li>
</ul>
<a id="fromMaterializer(java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromMaterializer</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;&nbsp;fromMaterializer&#8203;(java.util.function.BiFunction&lt;<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</pre>
<div class="block">Defers the creation of a <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> until materialization. The <code>factory</code> function
 exposes <code>Materializer</code> which is going to be used during materialization and
 <code>Attributes</code> of the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> returned by this method.</div>
</li>
</ul>
<a id="setup(java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setup</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;&nbsp;setup&#8203;(java.util.function.BiFunction&lt;<a href="../ActorMaterializer.html" title="class in org.apache.pekko.stream">ActorMaterializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'fromMaterializer' instead. Since 2.6.0.</div>
</div>
<div class="block">Defers the creation of a <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> until materialization. The <code>factory</code> function
 exposes <code>ActorMaterializer</code> which is going to be used during materialization and
 <code>Attributes</code> of the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> returned by this method.</div>
</li>
</ul>
<a id="combine(org.apache.pekko.stream.javadsl.Source,org.apache.pekko.stream.javadsl.Source,java.util.List,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combine</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;U&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;U,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;combine&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&nbsp;first,
                                                          <a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&nbsp;second,
                                                          java.util.List&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;rest,
                                                          <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Integer,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanInShape.html" title="class in org.apache.pekko.stream">UniformFanInShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy)</pre>
<div class="block">Combines several sources with fan-in strategy like <a href="Merge.html" title="class in org.apache.pekko.stream.javadsl"><code>Merge</code></a> or <a href="Concat.html" title="class in org.apache.pekko.stream.javadsl"><code>Concat</code></a> into a single <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>.</div>
</li>
</ul>
<a id="combineMat(org.apache.pekko.stream.javadsl.Source,org.apache.pekko.stream.javadsl.Source,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineMat</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;U,&#8203;M1,&#8203;M2,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;U,&#8203;M&gt;&nbsp;combineMat&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M1&gt;&nbsp;first,
                                                                                 <a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M2&gt;&nbsp;second,
                                                                                 <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Integer,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanInShape.html" title="class in org.apache.pekko.stream">UniformFanInShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy,
                                                                                 <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;M1,&#8203;M2,&#8203;M&gt;&nbsp;combine)</pre>
<div class="block">Combines two sources with fan-in strategy like <code>Merge</code> or <code>Concat</code> and returns <code>Source</code> with a materialized value.</div>
</li>
</ul>
<a id="zipN(java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipN</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;T&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;zipN&#8203;(java.util.List&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;sources)</pre>
<div class="block">Combine the elements of multiple streams into a stream of lists.</div>
</li>
</ul>
<a id="zipWithN(org.apache.pekko.japi.function.Function,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWithN</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;zipWithN&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.util.List&lt;T&gt;,&#8203;O&gt;&nbsp;zipper,
                                                           java.util.List&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;sources)</pre>
</li>
</ul>
<a id="queue(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../BoundedSourceQueue.html" title="interface in org.apache.pekko.stream">BoundedSourceQueue</a>&lt;T&gt;&gt;&nbsp;queue&#8203;(int&nbsp;bufferSize)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.BoundedSourceQueue</code>.
 You can push elements to the queue and they will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received. The buffer size is passed in as a parameter.
 Elements in the buffer will be discarded if downstream is terminated.
 <p>
 Pushed elements may be dropped if there is no space available in the buffer. Elements will also be dropped if the
 queue is failed through the materialized <code>BoundedQueueSource</code> or the <code>Source</code> is cancelled by the downstream.
 An element that was reported to be <code>enqueued</code> is not guaranteed to be processed by the rest of the stream. If the
 queue is failed by calling <code>BoundedQueueSource.fail</code> or the downstream cancels the stream, elements in the buffer
 are discarded.
 <p>
 Acknowledgement of pushed elements is immediate.
 <code>pekko.stream.BoundedSourceQueue.offer</code> returns <code>pekko.stream.QueueOfferResult</code> which is implemented as:
 <p>
 <code>QueueOfferResult.enqueued()</code>     element was added to buffer, but may still be discarded later when the queue is
                                   failed or cancelled
 <code>QueueOfferResult.dropped()</code>      element was dropped
 <code>QueueOfferResult.QueueClosed</code>    the queue was completed with <code>pekko.stream.BoundedSourceQueue.complete</code>
 <code>QueueOfferResult.Failure</code>        the queue was failed with <code>pekko.stream.BoundedSourceQueue.fail</code> or if the
                                   stream failed
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bufferSize</code> - size of the buffer in number of elements</dd>
</dl>
</li>
</ul>
<a id="queue(int,org.apache.pekko.stream.OverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="SourceQueueWithComplete.html" title="interface in org.apache.pekko.stream.javadsl">SourceQueueWithComplete</a>&lt;T&gt;&gt;&nbsp;queue&#8203;(int&nbsp;bufferSize,
                                                                   <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.javadsl.SourceQueueWithComplete</code>.
 You can push elements to the queue and they will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received. Elements in the buffer will be discarded
 if downstream is terminated.
 <p>
 Depending on the defined <code>pekko.stream.OverflowStrategy</code> it might drop elements if
 there is no space available in the buffer.
 <p>
 Acknowledgement mechanism is available.
 <code>pekko.stream.javadsl.SourceQueueWithComplete.offer</code> returns <code>CompletionStage<QueueOfferResult></code> which completes with
 <code>QueueOfferResult.enqueued()</code> if element was added to buffer or sent downstream. It completes with
 <code>QueueOfferResult.dropped()</code> if element was dropped. Can also complete with <code>QueueOfferResult.Failure</code> -
 when stream failed or <code>QueueOfferResult.QueueClosed</code> when downstream is completed.
 <p>
 The strategy <code>pekko.stream.OverflowStrategy.backpressure</code> will not complete last <code>offer():CompletionStage</code>
 call when buffer is full.
 <p>
 Instead of using the strategy <code>pekko.stream.OverflowStrategy.dropNew</code> it's recommended to use
 <code>Source.queue(bufferSize)</code> instead which returns a <code>QueueOfferResult</code> synchronously.
 <p>
 You can watch accessibility of stream with <code>pekko.stream.javadsl.SourceQueueWithComplete.watchCompletion</code>.
 It returns a future that completes with success when this operator is completed or fails when stream is failed.
 <p>
 The buffer can be disabled by using <code>bufferSize</code> of 0 and then received message will wait
 for downstream demand unless there is another message waiting for downstream demand, in that case
 offer result will be completed according to the overflow strategy.
 <p>
 The materialized SourceQueue may only be used from a single producer.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bufferSize</code> - size of buffer in element count</dd>
<dd><code>overflowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="queue(int,org.apache.pekko.stream.OverflowStrategy,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="SourceQueueWithComplete.html" title="interface in org.apache.pekko.stream.javadsl">SourceQueueWithComplete</a>&lt;T&gt;&gt;&nbsp;queue&#8203;(int&nbsp;bufferSize,
                                                                   <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy,
                                                                   int&nbsp;maxConcurrentOffers)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.javadsl.SourceQueueWithComplete</code>.
 You can push elements to the queue and they will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received. Elements in the buffer will be discarded
 if downstream is terminated.
 <p>
 Depending on the defined <code>pekko.stream.OverflowStrategy</code> it might drop elements if
 there is no space available in the buffer.
 <p>
 Acknowledgement mechanism is available.
 <code>pekko.stream.javadsl.SourceQueueWithComplete.offer</code> returns <code>CompletionStage<QueueOfferResult></code> which completes with
 <code>QueueOfferResult.enqueued()</code> if element was added to buffer or sent downstream. It completes with
 <code>QueueOfferResult.dropped()</code> if element was dropped. Can also complete with <code>QueueOfferResult.Failure</code> -
 when stream failed or <code>QueueOfferResult.QueueClosed</code> when downstream is completed.
 <p>
 The strategy <code>pekko.stream.OverflowStrategy.backpressure</code> will not complete <code>maxConcurrentOffers</code> number of
 <code>offer():CompletionStage</code> call when buffer is full.
 <p>
 Instead of using the strategy <code>pekko.stream.OverflowStrategy.dropNew</code> it's recommended to use
 <code>Source.queue(bufferSize)</code> instead which returns a <code>QueueOfferResult</code> synchronously.
 <p>
 You can watch accessibility of stream with <code>pekko.stream.javadsl.SourceQueueWithComplete.watchCompletion</code>.
 It returns a future that completes with success when this operator is completed or fails when stream is failed.
 <p>
 The buffer can be disabled by using <code>bufferSize</code> of 0 and then received message will wait
 for downstream demand unless there is another message waiting for downstream demand, in that case
 offer result will be completed according to the overflow strategy.
 <p>
 The materialized SourceQueue may be used by up to maxConcurrentOffers concurrent producers.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bufferSize</code> - size of buffer in element count</dd>
<dd><code>overflowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
<dd><code>maxConcurrentOffers</code> - maximum number of pending offers when buffer is full, should be greater than 0, not
                            applicable when <code>OverflowStrategy.dropNew</code> is used</dd>
</dl>
</li>
</ul>
<a id="unfoldResource(org.apache.pekko.japi.function.Creator,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Procedure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unfoldResource</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;unfoldResource&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;S&gt;&nbsp;create,
                                                                 <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.Optional&lt;T&gt;&gt;&nbsp;read,
                                                                 <a href="../../japi/function/Procedure.html" title="interface in org.apache.pekko.japi.function">Procedure</a>&lt;S&gt;&nbsp;close)</pre>
<div class="block">Start a new <code>Source</code> from some resource which can be opened, read and closed.
 Interaction with resource happens in a blocking way.
 <p>
 Example:
 <pre><code>
 Source.unfoldResource(
   () -&gt; new BufferedReader(new FileReader("...")),
   reader -&gt; reader.readLine(),
   reader -&gt; reader.close())
 </code></pre>
 <p>
 You can use the supervision strategy to handle exceptions for <code>read</code> function. All exceptions thrown by <code>create</code>
 or <code>close</code> will fail the stream.
 <p>
 <code>Restart</code> supervision strategy will close and create blocking IO again. Default strategy is <code>Stop</code> which means
 that stream will be terminated on error in <code>read</code> function by default.
 <p>
 You can configure the default dispatcher for this Source by changing the <code>pekko.stream.materializer.blocking-io-dispatcher</code> or
 set it for a given Source by using <code>ActorAttributes</code>.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>create</code> - - function that is called on stream start and creates/opens resource.</dd>
<dd><code>read</code> - - function that reads data from opened resource. It is called each time backpressure signal
             is received. Stream calls close and completes when <code>read</code> returns None.</dd>
<dd><code>close</code> - - function that closes resource</dd>
</dl>
</li>
</ul>
<a id="unfoldResourceAsync(org.apache.pekko.japi.function.Creator,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unfoldResourceAsync</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;unfoldResourceAsync&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;java.util.concurrent.CompletionStage&lt;S&gt;&gt;&nbsp;create,
                                                                      <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.concurrent.CompletionStage&lt;java.util.Optional&lt;T&gt;&gt;&gt;&nbsp;read,
                                                                      <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;&nbsp;close)</pre>
<div class="block">Start a new <code>Source</code> from some resource which can be opened, read and closed.
 It's similar to <code>unfoldResource</code> but takes functions that return <code>CompletionStage</code> instead of plain values.
 <p>
 You can use the supervision strategy to handle exceptions for <code>read</code> function or failures of produced <code>Futures</code>.
 All exceptions thrown by <code>create</code> or <code>close</code> as well as fails of returned futures will fail the stream.
 <p>
 <code>Restart</code> supervision strategy will close and create resource. Default strategy is <code>Stop</code> which means
 that stream will be terminated on error in <code>read</code> function (or future) by default.
 <p>
 You can configure the default dispatcher for this Source by changing the <code>pekko.stream.materializer.blocking-io-dispatcher</code> or
 set it for a given Source by using <code>ActorAttributes</code>.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>create</code> - - function that is called on stream start and creates/opens resource.</dd>
<dd><code>read</code> - - function that reads data from opened resource. It is called each time backpressure signal
             is received. Stream calls close and completes when <code>CompletionStage</code> from read function returns None.</dd>
<dd><code>close</code> - - function that closes resource</dd>
</dl>
</li>
</ul>
<a id="upcast(org.apache.pekko.stream.javadsl.Source)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>upcast</h4>
<pre class="methodSignature">public static&nbsp;&lt;SuperOut,&#8203;Out extends SuperOut,&#8203;Mat&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;SuperOut,&#8203;Mat&gt;&nbsp;upcast&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out,&#8203;Mat&gt;&nbsp;source)</pre>
<div class="block">Upcast a stream of elements to a stream of supertypes of that element. Useful in combination with
 fan-in operators where you do not want to pay the cost of casting each element in a <code>map</code>.
 <p>
 Example:
 <p>
 <pre><code>
 Source&lt;Apple, NotUsed&gt; apples = Source.single(new Apple());
 Source&lt;Orange, NotUsed&gt; oranges = Source.single(new Orange());
 Source&lt;Fruit, NotUsed&gt; appleFruits = Source.upcast(apples);
 Source&lt;Fruit, NotUsed&gt; orangeFruits = Source.upcast(oranges);

 Source&lt;Fruit, NotUsed&gt; fruits = appleFruits.merge(orangeFruits);
 </code></pre>
 <p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A source with the supertype as elements</dd>
</dl>
</li>
</ul>
<a id="mergePrioritizedN(java.util.List,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePrioritizedN</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;mergePrioritizedN&#8203;(java.util.List&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;?&gt;,&#8203;java.lang.Integer&gt;&gt;&nbsp;sourcesAndPriorities,
                                                            boolean&nbsp;eagerComplete)</pre>
<div class="block">Merge multiple <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s. Prefer the sources depending on the 'priority' parameters.
 The provided sources and priorities must have the same size and order.
 <p>
 '''emits''' when one of the inputs has an element available, preferring inputs based on the 'priority' parameters if both have elements available
 <p>
 '''backpressures''' when downstream backpressures
 <p>
 '''completes''' when both upstreams complete (This behavior is changeable to completing when any upstream completes by setting <code>eagerComplete=true</code>.)
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="concatAllLazy(org.apache.pekko.stream.Graph...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatAllLazy</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;concatAllLazy&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;...&nbsp;those)</pre>
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s to this one, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s are materialized together with this Flow. If <code>lazy</code> materialization is what is needed
 the operator can be combined with for example <code>Source.lazySource</code> to defer materialization of <code>that</code> until the
 time when this source completes.
 <p>
 The second source is then kept from producing elements by asserting back-pressure until its time comes.
 <p>
 For a concat operator that is detached, use <a href="#concat(org.apache.pekko.stream.Graph)"><code>concat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;)</code></a>
 <p>
 If this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> gets upstream error - no elements from the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s will be pulled.
 <p>
 '''Emits when''' element is available from current stream or from the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s when current is completed
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' all the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="alsoToAll(org.apache.pekko.stream.Graph...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>alsoToAll</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;alsoToAll&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;...&nbsp;those)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, meaning that elements that passes
 through will also be sent to all those <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s.
 <p>
 It is similar to <a href="#wireTap(org.apache.pekko.stream.Graph)"><code>wireTap(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, ?&gt;)</code></a> but will backpressure instead of dropping elements when the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s is not ready.
 <p>
 '''Emits when''' element is available and demand exists both from the Sinks and the downstream.
 <p>
 '''Backpressures when''' downstream or any of the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream or any of the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s cancels</div>
</li>
</ul>
<a id="shape()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shape</h4>
<pre class="methodSignature">public&nbsp;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;shape()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../Graph.html#shape()">Graph</a></code></span></div>
<div class="block">The shape of a graph is all that is externally visible: its inlets and outlets.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../Graph.html#shape()">shape</a></code>&nbsp;in interface&nbsp;<code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="traversalBuilder()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>traversalBuilder</h4>
<pre class="methodSignature">public&nbsp;org.apache.pekko.stream.impl.LinearTraversalBuilder&nbsp;traversalBuilder()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../Graph.html#traversalBuilder()">Graph</a></code></span></div>
<div class="block">INTERNAL API.
 <p>
 Every materializable element must be backed by a stream layout module</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../Graph.html#traversalBuilder()">traversalBuilder</a></code>&nbsp;in interface&nbsp;<code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a id="asScala()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asScala</h4>
<pre class="methodSignature">public&nbsp;<a href="../scaladsl/Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;asScala()</pre>
<div class="block">Converts this Java DSL element to its Scala DSL counterpart.</div>
</li>
</ul>
<a id="mapMaterializedValue(org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapMaterializedValue</h4>
<pre class="methodSignature">public&nbsp;&lt;Mat2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Mat2&gt;&nbsp;mapMaterializedValue&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2&gt;&nbsp;f)</pre>
<div class="block">Transform only the materialized value of this Source, leaving all other properties as they were.</div>
</li>
</ul>
<a id="preMaterialize(org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preMaterialize</h4>
<pre class="methodSignature">public&nbsp;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;preMaterialize&#8203;(<a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</pre>
<div class="block">Materializes this Source, immediately returning (1) its materialized value, and (2) a new Source
 that can be used to consume elements from the newly materialized Source.
 <p>
 Note that the <code>ActorSystem</code> can be used as the <code>systemProvider</code> parameter.</div>
</li>
</ul>
<a id="preMaterialize(org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preMaterialize</h4>
<pre class="methodSignature">public&nbsp;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;preMaterialize&#8203;(<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</pre>
<div class="block">Materializes this Source, immediately returning (1) its materialized value, and (2) a new Source
 that can be used to consume elements from the newly materialized Source.
 <p>
 Prefer the method taking an <code>ActorSystem</code> unless you have special requirements.</div>
</li>
</ul>
<a id="via(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>via</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;via&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../FlowShape.html" title="class in org.apache.pekko.stream">FlowShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;M&gt;&nbsp;flow)</pre>
<div class="block">Transform this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> by appending the given processing operators.
 <pre><code>
     +----------------------------+
     | Resulting Source           |
     |                            |
     |  +------+        +------+  |
     |  |      |        |      |  |
     |  | this | ~Out~&gt; | flow | ~~&gt; T
     |  |      |        |      |  |
     |  +------+        +------+  |
     +----------------------------+
 </code></pre>
 The materialized value of the combined <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> will be the materialized
 value of the current flow (ignoring the other Flow&amp;rsquo;s value), use
 <code>viaMat</code> if a different strategy is needed.</div>
</li>
</ul>
<a id="viaMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>viaMat</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;M2&gt;&nbsp;viaMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../FlowShape.html" title="class in org.apache.pekko.stream">FlowShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;M&gt;&nbsp;flow,
                                                      <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;combine)</pre>
<div class="block">Transform this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> by appending the given processing operators.
 <pre><code>
     +----------------------------+
     | Resulting Source           |
     |                            |
     |  +------+        +------+  |
     |  |      |        |      |  |
     |  | this | ~Out~&gt; | flow | ~~&gt; T
     |  |      |        |      |  |
     |  +------+        +------+  |
     +----------------------------+
 </code></pre>
 The <code>combine</code> function is used to compose the materialized values of this flow and that
 flow into the materialized value of the resulting Flow.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.</div>
</li>
</ul>
<a id="to(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="RunnableGraph.html" title="class in org.apache.pekko.stream.javadsl">RunnableGraph</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;to&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;sink)</pre>
<div class="block">Connect this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to a <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>, concatenating the processing steps of both.
 <pre><code>
     +----------------------------+
     | Resulting RunnableGraph    |
     |                            |
     |  +------+        +------+  |
     |  |      |        |      |  |
     |  | this | ~Out~&gt; | sink |  |
     |  |      |        |      |  |
     |  +------+        +------+  |
     +----------------------------+
 </code></pre>
 The materialized value of the combined <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> will be the materialized
 value of the current flow (ignoring the given Sink&amp;rsquo;s value), use
 <code>toMat</code> if a different strategy is needed.</div>
</li>
</ul>
<a id="toMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="RunnableGraph.html" title="class in org.apache.pekko.stream.javadsl">RunnableGraph</a>&lt;M2&gt;&nbsp;toMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;sink,
                                            <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;combine)</pre>
<div class="block">Connect this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to a <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>, concatenating the processing steps of both.
 <pre><code>
     +----------------------------+
     | Resulting RunnableGraph    |
     |                            |
     |  +------+        +------+  |
     |  |      |        |      |  |
     |  | this | ~Out~&gt; | sink |  |
     |  |      |        |      |  |
     |  +------+        +------+  |
     +----------------------------+
 </code></pre>
 The <code>combine</code> function is used to compose the materialized values of this flow and that
 Sink into the materialized value of the resulting Sink.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.</div>
</li>
</ul>
<a id="run(org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>run</h4>
<pre class="methodSignature">public&nbsp;java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&nbsp;run&#8203;(<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</pre>
<div class="block">Connect this <code>Source</code> to the <code>Sink.ignore</code> and run it. Elements from the stream will be consumed and discarded.
 <p>
 Note that the <code>ActorSystem</code> can be used as the <code>materializer</code> parameter to use the
 <code>pekko.stream.SystemMaterializer</code> for running the stream.</div>
</li>
</ul>
<a id="run(org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>run</h4>
<pre class="methodSignature">public&nbsp;java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&nbsp;run&#8203;(<a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</pre>
<div class="block">Connect this <code>Source</code> to the <code>Sink.ignore</code> and run it. Elements from the stream will be consumed and discarded.
 <p>
 Note that the <code>ActorSystem</code> can be used as the <code>systemProvider</code> parameter to use the
 <code>pekko.stream.SystemMaterializer</code> for running the stream.</div>
</li>
</ul>
<a id="runWith(org.apache.pekko.stream.Graph,org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runWith</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;M&nbsp;runWith&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;sink,
                     <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</pre>
<div class="block">Connect this <code>Source</code> to a <code>Sink</code> and run it. The returned value is the materialized value
 of the <code>Sink</code>, e.g. the <code>Publisher</code> of a <code>Sink.asPublisher</code>.
 <p>
 Note that the classic or typed <code>ActorSystem</code> can be used as the <code>systemProvider</code> parameter.</div>
</li>
</ul>
<a id="runWith(org.apache.pekko.stream.Graph,org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runWith</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;M&nbsp;runWith&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;sink,
                     <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</pre>
<div class="block">Connect this <code>Source</code> to a <code>Sink</code> and run it. The returned value is the materialized value
 of the <code>Sink</code>, e.g. the <code>Publisher</code> of a <code>Sink.asPublisher</code>.
 <p>
 Prefer the method taking an <code>ActorSystem</code> unless you have special requirements</div>
</li>
</ul>
<a id="runFold(java.lang.Object,org.apache.pekko.japi.function.Function2,org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a><a id="runFold(U,org.apache.pekko.japi.function.Function2,org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runFold</h4>
<pre class="methodSignature">public&nbsp;&lt;U&gt;&nbsp;java.util.concurrent.CompletionStage&lt;U&gt;&nbsp;runFold&#8203;(U&nbsp;zero,
                                                           <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;U&gt;&nbsp;f,
                                                           <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</pre>
<div class="block">Shortcut for running this <code>Source</code> with a fold function.
 The given function is invoked for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.
 The returned <code>CompletionStage</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure is signaled in the stream.
 <p>
 Note that the classic or typed <code>ActorSystem</code> can be used as the <code>systemProvider</code> parameter.</div>
</li>
</ul>
<a id="runFold(java.lang.Object,org.apache.pekko.japi.function.Function2,org.apache.pekko.stream.Materializer)">
<!--   -->
</a><a id="runFold(U,org.apache.pekko.japi.function.Function2,org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runFold</h4>
<pre class="methodSignature">public&nbsp;&lt;U&gt;&nbsp;java.util.concurrent.CompletionStage&lt;U&gt;&nbsp;runFold&#8203;(U&nbsp;zero,
                                                           <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;U&gt;&nbsp;f,
                                                           <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</pre>
<div class="block">Shortcut for running this <code>Source</code> with a fold function.
 The given function is invoked for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.
 The returned <code>CompletionStage</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure is signaled in the stream.
 <p>
 Prefer the method taking an ActorSystem unless you have special requirements.</div>
</li>
</ul>
<a id="runFoldAsync(java.lang.Object,org.apache.pekko.japi.function.Function2,org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a><a id="runFoldAsync(U,org.apache.pekko.japi.function.Function2,org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runFoldAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;U&gt;&nbsp;java.util.concurrent.CompletionStage&lt;U&gt;&nbsp;runFoldAsync&#8203;(U&nbsp;zero,
                                                                <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;U&gt;&gt;&nbsp;f,
                                                                <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</pre>
<div class="block">Shortcut for running this <code>Source</code> with an asynchronous fold function.
 The given function is invoked for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.
 The returned <code>CompletionStage</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure is signaled in the stream.
 <p>
 Note that the classic or typed <code>ActorSystem</code> can be used as the <code>systemProvider</code> parameter.</div>
</li>
</ul>
<a id="runFoldAsync(java.lang.Object,org.apache.pekko.japi.function.Function2,org.apache.pekko.stream.Materializer)">
<!--   -->
</a><a id="runFoldAsync(U,org.apache.pekko.japi.function.Function2,org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runFoldAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;U&gt;&nbsp;java.util.concurrent.CompletionStage&lt;U&gt;&nbsp;runFoldAsync&#8203;(U&nbsp;zero,
                                                                <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;U&gt;&gt;&nbsp;f,
                                                                <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</pre>
<div class="block">Shortcut for running this <code>Source</code> with an asynchronous fold function.
 The given function is invoked for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.
 The returned <code>CompletionStage</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure is signaled in the stream.
 <p>
 Prefer the method taking an <code>ActorSystem</code> unless you have special requirements</div>
</li>
</ul>
<a id="runReduce(org.apache.pekko.japi.function.Function2,org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runReduce</h4>
<pre class="methodSignature">public&nbsp;java.util.concurrent.CompletionStage&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;runReduce&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f,
                                                           <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</pre>
<div class="block">Shortcut for running this <code>Source</code> with a reduce function.
 The given function is invoked for every received element, giving it its previous
 output (from the second ones) an the element as input.
 The returned <code>CompletionStage</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure is signaled in the stream.
 <p>
 If the stream is empty (i.e. completes before signalling any elements),
 the reduce operator will fail its downstream with a <code>NoSuchElementException</code>,
 which is semantically in-line with that Scala's standard library collections
 do in such situations.
 <p>
 Note that the classic or typed <code>ActorSystem</code> can be used as the <code>systemProvider</code> parameter.</div>
</li>
</ul>
<a id="runReduce(org.apache.pekko.japi.function.Function2,org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runReduce</h4>
<pre class="methodSignature">public&nbsp;java.util.concurrent.CompletionStage&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;runReduce&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f,
                                                           <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</pre>
<div class="block">Shortcut for running this <code>Source</code> with a reduce function.
 The given function is invoked for every received element, giving it its previous
 output (from the second ones) an the element as input.
 The returned <code>CompletionStage</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure is signaled in the stream.
 <p>
 If the stream is empty (i.e. completes before signalling any elements),
 the reduce operator will fail its downstream with a <code>NoSuchElementException</code>,
 which is semantically in-line with that Scala's standard library collections
 do in such situations.
 <p>
 Prefer the method taking an <code>ActorSystem</code> unless you have special requirements</div>
</li>
</ul>
<a id="concat(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;concat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that)</pre>
<div class="block">Concatenate this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with the given one, meaning that once current
 is exhausted and all result elements have been generated,
 the given source elements will be produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> is materialized together with this Flow and is "detached" meaning it will
 in effect behave as a one element buffer in front of both the sources, that eagerly demands an element on start
 (so it can not be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>).
 <p>
 The second source is then kept from producing elements by asserting back-pressure until its time comes.
 <p>
 When needing a concat operator that is not detached use <a href="#concatLazy(org.apache.pekko.stream.Graph)"><code>concatLazy(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;)</code></a>
 <p>
 '''Emits when''' element is available from current source or from the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> when current is completed
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="concatLazy(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatLazy</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;concatLazy&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that)</pre>
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> is materialized together with this Flow. If <code>lazy</code> materialization is what is needed
 the operator can be combined with for example <code>Source.lazySource</code> to defer materialization of <code>that</code> until the
 time when this source completes.
 <p>
 The second source is then kept from producing elements by asserting back-pressure until its time comes.
 <p>
 For a concat operator that is detached, use <a href="#concat(org.apache.pekko.stream.Graph)"><code>concat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;)</code></a>
 <p>
 If this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> gets upstream error - no elements from the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> will be pulled.
 <p>
 '''Emits when''' element is available from current stream or from the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> when current is completed
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="concatAllLazy(scala.collection.immutable.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatAllLazy</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;concatAllLazy&#8203;(scala.collection.immutable.Seq&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&gt;&nbsp;those)</pre>
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s to this one, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s are materialized together with this Flow. If <code>lazy</code> materialization is what is needed
 the operator can be combined with for example <code>Source.lazySource</code> to defer materialization of <code>that</code> until the
 time when this source completes.
 <p>
 The second source is then kept from producing elements by asserting back-pressure until its time comes.
 <p>
 For a concat operator that is detached, use <a href="#concat(org.apache.pekko.stream.Graph)"><code>concat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;)</code></a>
 <p>
 If this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> gets upstream error - no elements from the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s will be pulled.
 <p>
 '''Emits when''' element is available from current stream or from the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s when current is completed
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' all the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="concatMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;&nbsp;concatMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                   <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Concatenate this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with the given one, meaning that once current
 is exhausted and all result elements have been generated,
 the given source elements will be produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> is materialized together with this Flow and is "detached" meaning it will
 in effect behave as a one element buffer in front of both the sources, that eagerly demands an element on start
 (so it can not be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>).
 <p>
 The second source is then kept from producing elements by asserting back-pressure until its time comes.
 <p>
 When needing a concat operator that is not detached use <a href="#concatLazyMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)"><code>concatLazyMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;, org.apache.pekko.japi.function.Function2&lt;Mat, M, M2&gt;)</code></a>
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="concatLazyMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatLazyMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;&nbsp;concatLazyMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                       <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> is materialized together with this Flow, if <code>lazy</code> materialization is what is needed
 the operator can be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>.
 <p>
 The second source is then kept from producing elements by asserting back-pressure until its time comes.
 <p>
 For a concat operator that is detached, use <a href="#concatMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)"><code>concatMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;, org.apache.pekko.japi.function.Function2&lt;Mat, M, M2&gt;)</code></a>
 <p></div>
</li>
</ul>
<a id="prepend(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prepend</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;prepend&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that)</pre>
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this one, meaning that once the given source
 is exhausted and all result elements have been generated, the current source's
 elements will be produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> is materialized together with this Flow and is "detached" meaning
 in effect behave as a one element buffer in front of both the sources, that eagerly demands an element on start
 (so it can not be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>).
 <p>
 This flow will then be kept from producing elements by asserting back-pressure until its time comes.
 <p>
 When needing a prepend operator that is not detached use <a href="#prependLazy(org.apache.pekko.stream.Graph)"><code>prependLazy(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;)</code></a>
 <p>
 '''Emits when''' element is available from current source or from the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> when current is completed
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="prependLazy(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prependLazy</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;prependLazy&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that)</pre>
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that before elements
 are generated from this Flow, the Source's elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> is materialized together with this Flow and will then be kept from producing elements
 by asserting back-pressure until its time comes.
 <p>
 When needing a prepend operator that is also detached use <a href="#prepend(org.apache.pekko.stream.Graph)"><code>prepend(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;)</code></a>
 <p>
 If the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> gets upstream error - no elements from this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> will be pulled.
 <p>
 '''Emits when''' element is available from the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> or from current stream when the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> is completed
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="prependMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prependMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;&nbsp;prependMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                    <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this one, meaning that once the given source
 is exhausted and all result elements have been generated, the current source's
 elements will be produced.
 <p>
 Note that this Flow will be materialized together with the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and just kept
 from producing elements by asserting back-pressure until its time comes.
 <p>
 When needing a prepend operator that is not detached use <a href="#prependLazyMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)"><code>prependLazyMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;, org.apache.pekko.japi.function.Function2&lt;Mat, M, M2&gt;)</code></a>
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="prependLazyMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prependLazyMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;&nbsp;prependLazyMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                        <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that before elements
 are generated from this Flow, the Source's elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> is materialized together with this Flow.
 <p>
 This flow will then be kept from producing elements by asserting back-pressure until its time comes.
 <p>
 When needing a prepend operator that is detached use <a href="#prependMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)"><code>prependMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;, org.apache.pekko.japi.function.Function2&lt;Mat, M, M2&gt;)</code></a>
 <p></div>
</li>
</ul>
<a id="orElse(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orElse</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;orElse&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;secondary)</pre>
<div class="block">Provides a secondary source that will be consumed if this source completes without any
 elements passing by. As soon as the first element comes through this stream, the alternative
 will be cancelled.
 <p>
 Note that this Flow will be materialized together with the <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and just kept
 from producing elements by asserting back-pressure until its time comes or it gets
 cancelled.
 <p>
 On errors the operator is failed regardless of source of the error.
 <p>
 '''Emits when''' element is available from first stream or first stream closed without emitting any elements and an element
                  is available from the second stream
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' the primary stream completes after emitting at least one element, when the primary stream completes
                      without emitting and the secondary stream already has completed or when the secondary stream completes
 <p>
 '''Cancels when''' downstream cancels and additionally the alternative is cancelled as soon as an element passes
                    by from this stream.</div>
</li>
</ul>
<a id="orElseMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orElseMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;&nbsp;orElseMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;secondary,
                                                   <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Provides a secondary source that will be consumed if this source completes without any
 elements passing by. As soon as the first element comes through this stream, the alternative
 will be cancelled.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#orElse(org.apache.pekko.stream.Graph)"><code>orElse(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, M&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="alsoTo(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>alsoTo</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;alsoTo&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, meaning that elements that passes
 through will also be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>.
 <p>
 It is similar to <a href="#wireTap(org.apache.pekko.stream.Graph)"><code>wireTap(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, ?&gt;)</code></a> but will backpressure instead of dropping elements when the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> is not ready.
 <p>
 '''Emits when''' element is available and demand exists both from the Sink and the downstream.
 <p>
 '''Backpressures when''' downstream or Sink backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream or Sink cancels</div>
</li>
</ul>
<a id="alsoToAll(scala.collection.immutable.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>alsoToAll</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;alsoToAll&#8203;(scala.collection.immutable.Seq&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&gt;&nbsp;those)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, meaning that elements that passes
 through will also be sent to all those <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s.
 <p>
 It is similar to <a href="#wireTap(org.apache.pekko.stream.Graph)"><code>wireTap(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, ?&gt;)</code></a> but will backpressure instead of dropping elements when the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s is not ready.
 <p>
 '''Emits when''' element is available and demand exists both from the Sinks and the downstream.
 <p>
 '''Backpressures when''' downstream or any of the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream or any of the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>s cancels</div>
</li>
</ul>
<a id="alsoToMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>alsoToMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M2,&#8203;M3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M3&gt;&nbsp;alsoToMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M2&gt;&nbsp;that,
                                                    <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M2,&#8203;M3&gt;&nbsp;matF)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that elements that passes
 through will also be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>.
 <p>
 It is similar to <a href="#wireTapMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)"><code>wireTapMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, M2&gt;, org.apache.pekko.japi.function.Function2&lt;Mat, M2, M3&gt;)</code></a> but will backpressure instead of dropping elements when the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> is not ready.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#alsoTo(org.apache.pekko.stream.Graph)"><code>alsoTo(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, ?&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="divertTo(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divertTo</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;divertTo&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that,
                                      <a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;when)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that elements will be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>
 instead of being passed through if the predicate <code>when</code> returns <code>true</code>.
 <p>
 '''Emits when''' emits when an element is available from the input and the chosen output has demand
 <p>
 '''Backpressures when''' the currently chosen output back-pressures
 <p>
 '''Completes when''' upstream completes and no output is pending
 <p>
 '''Cancels when''' any of the downstreams cancel</div>
</li>
</ul>
<a id="divertToMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Predicate,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divertToMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M2,&#8203;M3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M3&gt;&nbsp;divertToMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M2&gt;&nbsp;that,
                                                      <a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;when,
                                                      <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M2,&#8203;M3&gt;&nbsp;matF)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>, meaning that elements will be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>
 instead of being passed through if the predicate <code>when</code> returns <code>true</code>.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#divertTo(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Predicate)"><code>
 It is recommended to use the internally optimized Keep.left and Keep.right combiners
 where appropriate instead of manually writing functions that pass through one of the values.</code></a></dd>
</dl>
</li>
</ul>
<a id="wireTap(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wireTap</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;wireTap&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> as a wire tap, meaning that elements that pass
 through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.
 If the wire-tap Sink backpressures, elements that would've been sent to it will be dropped instead.
 <p>
 It is similar to <a href="#alsoTo(org.apache.pekko.stream.Graph)"><code>alsoTo(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, ?&gt;)</code></a> which does backpressure instead of dropping elements.
 <p>
 '''Emits when''' element is available and demand exists from the downstream; the element will
 also be sent to the wire-tap Sink if there is demand.
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="wireTapMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wireTapMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M2,&#8203;M3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M3&gt;&nbsp;wireTapMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M2&gt;&nbsp;that,
                                                     <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M2,&#8203;M3&gt;&nbsp;matF)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> as a wire tap, meaning that elements that pass
 through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.
 If the wire-tap Sink backpressures, elements that would've been sent to it will be dropped instead.
 <p>
 It is similar to <a href="#alsoToMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)"><code>alsoToMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, M2&gt;, org.apache.pekko.japi.function.Function2&lt;Mat, M2, M3&gt;)</code></a> which does backpressure instead of dropping elements.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#wireTap(org.apache.pekko.stream.Graph)"><code>wireTap(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, ?&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="interleave(org.apache.pekko.stream.Graph,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interleave</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;interleave&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that,
                                        int&nbsp;segmentSize)</pre>
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>.
 It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code> source,
 then repeat process.
 <p>
 Example:
 <pre><code>
 Source.from(Arrays.asList(1, 2, 3)).interleave(Source.from(Arrays.asList(4, 5, 6, 7), 2)
 // 1, 2, 4, 5, 3, 6, 7
 </code></pre>
 <p>
 After one of sources is complete than all the rest elements will be emitted from the second one
 <p>
 If one of sources gets upstream error - stream completes with failure.
 <p>
 '''Emits when''' element is available from the currently consumed upstream
 <p>
 '''Backpressures when''' downstream backpressures. Signal to current
 upstream, switch to next upstream when received <code>segmentSize</code> elements
 <p>
 '''Completes when''' this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and given one completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="interleave(org.apache.pekko.stream.Graph,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interleave</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;interleave&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that,
                                        int&nbsp;segmentSize,
                                        boolean&nbsp;eagerClose)</pre>
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>.
 It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code> source,
 then repeat process.
 <p>
 If eagerClose is false and one of the upstreams complete the elements from the other upstream will continue passing
 through the interleave operator. If eagerClose is true and one of the upstream complete interleave will cancel the
 other upstream and complete itself.
 <p>
 If this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> or <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> gets upstream error - stream completes with failure.
 <p>
 '''Emits when''' element is available from the currently consumed upstream
 <p>
 '''Backpressures when''' downstream backpressures. Signal to current
 upstream, switch to next upstream when received <code>segmentSize</code> elements
 <p>
 '''Completes when''' the <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> and given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="interleaveMat(org.apache.pekko.stream.Graph,int,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interleaveMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;&nbsp;interleaveMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                       int&nbsp;segmentSize,
                                                       <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>.
 It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code> source,
 then repeat process.
 <p>
 After one of sources is complete than all the rest elements will be emitted from the second one
 <p>
 If one of sources gets upstream error - stream completes with failure.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="interleaveMat(org.apache.pekko.stream.Graph,int,boolean,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interleaveMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;&nbsp;interleaveMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                       int&nbsp;segmentSize,
                                                       boolean&nbsp;eagerClose,
                                                       <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>.
 It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code> source,
 then repeat process.
 <p>
 If eagerClose is false and one of the upstreams complete the elements from the other upstream will continue passing
 through the interleave operator. If eagerClose is true and one of the upstream complete interleave will cancel the
 other upstream and complete itself.
 <p>
 If this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> or <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> gets upstream error - stream completes with failure.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#interleave(org.apache.pekko.stream.Graph,int)"><code>interleave(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, ?&gt;, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="interleaveAll(java.util.List,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interleaveAll</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;interleaveAll&#8203;(java.util.List&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&gt;&nbsp;those,
                                           int&nbsp;segmentSize,
                                           boolean&nbsp;eagerClose)</pre>
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with elements of this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>.
 It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code> source,
 then repeat process.
 <p>
 If eagerClose is false and one of the upstreams complete the elements from the other upstream will continue passing
 through the interleave operator. If eagerClose is true and one of the upstream complete interleave will cancel the
 other upstream and complete itself.
 <p>
 If this <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> or <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> gets upstream error - stream completes with failure.
 <p>
 '''Emits when''' element is available from the currently consumed upstream
 <p>
 '''Backpressures when''' downstream backpressures. Signal to current
 upstream, switch to next upstream when received <code>segmentSize</code> elements
 <p>
 '''Completes when''' the <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a> and given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="merge(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;merge&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that)</pre>
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
 <p>
 '''Emits when''' one of the inputs has an element available
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' all upstreams complete
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="merge(org.apache.pekko.stream.Graph,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;merge&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&nbsp;that,
                                   boolean&nbsp;eagerComplete)</pre>
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
 <p>
 '''Emits when''' one of the inputs has an element available
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true), default value is <code>false</code>
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="mergeMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;&nbsp;mergeMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                  <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="mergeMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M2&gt;&nbsp;mergeMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                  <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF,
                                                  boolean&nbsp;eagerComplete)</pre>
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#merge(org.apache.pekko.stream.Graph)"><code>merge(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;Out&gt;, ?&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="mergeAll(java.util.List,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeAll</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mergeAll&#8203;(java.util.List&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;?&gt;&gt;&nbsp;those,
                                      boolean&nbsp;eagerComplete)</pre>
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>s to the current one, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
 <p>
 '''Emits when''' one of the inputs has an element available
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true), default value is <code>false</code>
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="mergeLatest(org.apache.pekko.stream.Graph,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeLatest</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mergeLatest&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                             boolean&nbsp;eagerComplete)</pre>
<div class="block">MergeLatest joins elements from N input streams into stream of lists of size N.
 i-th element in list is the latest emitted element from i-th input stream.
 MergeLatest emits list for each element emitted from some input stream,
 but only after each input stream emitted at least one element.
 <p>
 '''Emits when''' an element is available from some input and each input emits at least one element from stream start
 <p>
 '''Completes when''' all upstreams complete (eagerClose=false) or one upstream completes (eagerClose=true)</div>
</li>
</ul>
<a id="mergeLatestMat(org.apache.pekko.stream.Graph,boolean,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeLatestMat</h4>
<pre class="methodSignature">public&nbsp;&lt;Mat2,&#8203;Mat3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat3&gt;&nbsp;mergeLatestMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                                               boolean&nbsp;eagerComplete,
                                                                               <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">MergeLatest joins elements from N input streams into stream of lists of size N.
 i-th element in list is the latest emitted element from i-th input stream.
 MergeLatest emits list for each element emitted from some input stream,
 but only after each input stream emitted at least one element.
 <p></div>
</li>
</ul>
<a id="mergePreferred(org.apache.pekko.stream.Graph,boolean,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePreferred</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mergePreferred&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                boolean&nbsp;preferred,
                                                boolean&nbsp;eagerComplete)</pre>
<div class="block">Merge two sources. Prefer one source if both sources have elements ready.
 <p>
 '''emits''' when one of the inputs has an element available. If multiple have elements available, prefer the 'right' one when 'preferred' is 'true', or the 'left' one when 'preferred' is 'false'.
 <p>
 '''backpressures''' when downstream backpressures
 <p>
 '''completes''' when all upstreams complete (This behavior is changeable to completing when any upstream completes by setting <code>eagerComplete=true</code>.)</div>
</li>
</ul>
<a id="mergePreferredMat(org.apache.pekko.stream.Graph,boolean,boolean,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePreferredMat</h4>
<pre class="methodSignature">public&nbsp;&lt;Mat2,&#8203;Mat3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Mat3&gt;&nbsp;mergePreferredMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                                  boolean&nbsp;preferred,
                                                                  boolean&nbsp;eagerComplete,
                                                                  <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Merge two sources. Prefer one source if both sources have elements ready.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#mergePreferred(org.apache.pekko.stream.Graph,boolean,boolean)"><code>
 It is recommended to use the internally optimized Keep.left and Keep.right combiners
 where appropriate instead of manually writing functions that pass through one of the values.</code></a></dd>
</dl>
</li>
</ul>
<a id="mergePrioritized(org.apache.pekko.stream.Graph,int,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePrioritized</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mergePrioritized&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                                  int&nbsp;leftPriority,
                                                  int&nbsp;rightPriority,
                                                  boolean&nbsp;eagerComplete)</pre>
<div class="block">Merge two sources. Prefer the sources depending on the 'priority' parameters.
 <p>
 '''emits''' when one of the inputs has an element available, preferring inputs based on the 'priority' parameters if both have elements available
 <p>
 '''backpressures''' when downstream backpressures
 <p>
 '''completes''' when both upstreams complete (This behavior is changeable to completing when any upstream completes by setting <code>eagerComplete=true</code>.)</div>
</li>
</ul>
<a id="mergePrioritizedMat(org.apache.pekko.stream.Graph,int,int,boolean,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePrioritizedMat</h4>
<pre class="methodSignature">public&nbsp;&lt;Mat2,&#8203;Mat3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Mat3&gt;&nbsp;mergePrioritizedMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                                    int&nbsp;leftPriority,
                                                                    int&nbsp;rightPriority,
                                                                    boolean&nbsp;eagerComplete,
                                                                    <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Merge multiple sources. Prefer the sources depending on the 'priority' parameters.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.</div>
</li>
</ul>
<a id="mergeSorted(org.apache.pekko.stream.Graph,java.util.Comparator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSorted</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mergeSorted&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;that,
                                             java.util.Comparator&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;comp)</pre>
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, taking elements as they arrive from input streams,
 picking always the smallest of the available elements (waiting for one element from each side
 to be available). This means that possible contiguity of the input streams is not exploited to avoid
 waiting for elements, this merge will block when one of the inputs does not have more elements (and
 does not complete).
 <p>
 '''Emits when''' all of the inputs have an element available
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' all upstreams complete
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="mergeSortedMat(org.apache.pekko.stream.Graph,java.util.Comparator,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSortedMat</h4>
<pre class="methodSignature">public&nbsp;&lt;Mat2,&#8203;Mat3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Mat3&gt;&nbsp;mergeSortedMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                               java.util.Comparator&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;comp,
                                                               <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>, taking elements as they arrive from input streams,
 picking always the smallest of the available elements (waiting for one element from each side
 to be available). This means that possible contiguity of the input streams is not exploited to avoid
 waiting for elements, this merge will block when one of the inputs does not have more elements (and
 does not complete).
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="zip(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;zip&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;?&gt;&nbsp;that)</pre>
<div class="block">Combine the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one into a stream of tuples.
 <p>
 '''Emits when''' all of the inputs has an element available
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' any upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="zipMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipMat</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;M2&gt;&nbsp;zipMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;that,
                                                                      <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Combine the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one into a stream of tuples.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="zipAll(org.apache.pekko.stream.Graph,java.lang.Object,java.lang.Object)">
<!--   -->
</a><a id="zipAll(org.apache.pekko.stream.Graph,A,U)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipAll</h4>
<pre class="methodSignature">public&nbsp;&lt;U,&#8203;A&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;A,&#8203;U&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;zipAll&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;?&gt;&nbsp;that,
                                                            A&nbsp;thisElem,
                                                            U&nbsp;thatElem)</pre>
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> into a stream of tuples.
 <p>
 '''Emits when''' at first emits when both inputs emit, and then as long as any input emits (coupled to the default value of the completed input).
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' all upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="zipAllMat(org.apache.pekko.stream.Graph,java.lang.Object,java.lang.Object,scala.Function2)">
<!--   -->
</a><a id="zipAllMat(org.apache.pekko.stream.Graph,A,U,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipAllMat</h4>
<pre class="methodSignature">public&nbsp;&lt;U,&#8203;Mat2,&#8203;Mat3,&#8203;A&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;A,&#8203;U&gt;,&#8203;Mat3&gt;&nbsp;zipAllMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                                                      A&nbsp;thisElem,
                                                                                      U&nbsp;thatElem,
                                                                                      scala.Function2&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> into a stream of tuples.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#zipAll(org.apache.pekko.stream.Graph,A,U)"><code>
 '''Emits when''' at first emits when both inputs emit, and then as long as any input emits (coupled to the default value of the completed input).
 
 '''Backpressures when''' downstream backpressures
 
 '''Completes when''' all upstream completes
 
 '''Cancels when''' downstream cancels</code></a></dd>
</dl>
</li>
</ul>
<a id="zipLatest(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;zipLatest&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;?&gt;&nbsp;that)</pre>
<div class="block">Combine the elements of 2 streams into a stream of tuples, picking always the latest element of each.
 <p>
 A <code>ZipLatest</code> has a <code>left</code> and a <code>right</code> input port and one <code>out</code> port.
 <p>
 No element is emitted until at least one element from each Source becomes available.
 <p>
 '''Emits when''' all of the inputs have at least an element available, and then each time an element becomes
 *   available on either of the inputs
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' any upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="zipLatestMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatestMat</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;,&#8203;M2&gt;&nbsp;zipLatestMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;that,
                                                                            <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Combine the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one into a stream of tuples, picking always the latest element of each.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="zipWith(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWith</h4>
<pre class="methodSignature">public&nbsp;&lt;Out2,&#8203;Out3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;zipWith&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;?&gt;&nbsp;that,
                                                        <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine)</pre>
<div class="block">Put together the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one
 into a stream of combined elements using a combiner function.
 <p>
 '''Emits when''' all of the inputs has an element available
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' any upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="zipWithMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWithMat</h4>
<pre class="methodSignature">public&nbsp;&lt;Out2,&#8203;Out3,&#8203;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;M2&gt;&nbsp;zipWithMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;M&gt;&nbsp;that,
                                                                           <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                                                                           <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Put together the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one
 into a stream of combined elements using a combiner function.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="zipLatestWith(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatestWith</h4>
<pre class="methodSignature">public&nbsp;&lt;Out2,&#8203;Out3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;zipLatestWith&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;?&gt;&nbsp;that,
                                                              <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine)</pre>
<div class="block">Combine the elements of multiple streams into a stream of combined elements using a combiner function,
 picking always the latest of the elements of each source.
 <p>
 No element is emitted until at least one element from each Source becomes available. Whenever a new
 element appears, the zipping function is invoked with a tuple containing the new element
 and the other last seen elements.
 <p>
   '''Emits when''' all of the inputs have at least an element available, and then each time an element becomes
   available on either of the inputs
 <p>
   '''Backpressures when''' downstream backpressures
 <p>
   '''Completes when''' any of the upstreams completes
 <p>
   '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="zipLatestWith(org.apache.pekko.stream.Graph,boolean,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatestWith</h4>
<pre class="methodSignature">public&nbsp;&lt;Out2,&#8203;Out3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;zipLatestWith&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;?&gt;&nbsp;that,
                                                              boolean&nbsp;eagerComplete,
                                                              <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine)</pre>
<div class="block">Combine the elements of multiple streams into a stream of combined elements using a combiner function,
 picking always the latest of the elements of each source.
 <p>
 No element is emitted until at least one element from each Source becomes available. Whenever a new
 element appears, the zipping function is invoked with a tuple containing the new element
 and the other last seen elements.
 <p>
   '''Emits when''' all of the inputs have at least an element available, and then each time an element becomes
   available on either of the inputs
 <p>
   '''Backpressures when''' downstream backpressures
 <p>
   '''Completes when''' any upstream completes if <code>eagerComplete</code> is enabled or wait for all upstreams to complete
 <p>
   '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="zipLatestWithMat(org.apache.pekko.stream.Graph,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatestWithMat</h4>
<pre class="methodSignature">public&nbsp;&lt;Out2,&#8203;Out3,&#8203;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;M2&gt;&nbsp;zipLatestWithMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;M&gt;&nbsp;that,
                                                                                 <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                                                                                 <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Put together the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one
 into a stream of combined elements using a combiner function,
 picking always the latest of the elements of each source.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="zipLatestWithMat(org.apache.pekko.stream.Graph,boolean,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatestWithMat</h4>
<pre class="methodSignature">public&nbsp;&lt;Out2,&#8203;Out3,&#8203;M,&#8203;M2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out3,&#8203;M2&gt;&nbsp;zipLatestWithMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;M&gt;&nbsp;that,
                                                                                 boolean&nbsp;eagerComplete,
                                                                                 <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                                                                                 <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;M,&#8203;M2&gt;&nbsp;matF)</pre>
<div class="block">Put together the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> and the given one
 into a stream of combined elements using a combiner function,
 picking always the latest of the elements of each source.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.
 <p></div>
</li>
</ul>
<a id="zipWithIndex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWithIndex</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;zipWithIndex()</pre>
<div class="block">Combine the elements of current <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> into a stream of tuples consisting
 of all elements paired with their index. Indices start at 0.
 <p>
 '''Emits when''' upstream emits an element and is paired with their index
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="runForeach(org.apache.pekko.japi.function.Procedure,org.apache.pekko.actor.ClassicActorSystemProvider)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runForeach</h4>
<pre class="methodSignature">public&nbsp;java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&nbsp;runForeach&#8203;(<a href="../../japi/function/Procedure.html" title="interface in org.apache.pekko.japi.function">Procedure</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f,
                                                             <a href="../../actor/ClassicActorSystemProvider.html" title="interface in org.apache.pekko.actor">ClassicActorSystemProvider</a>&nbsp;systemProvider)</pre>
<div class="block">Shortcut for running this <code>Source</code> with a foreach procedure. The given procedure is invoked
 for each received element.
 The returned <code>CompletionStage</code> will be completed normally when reaching the
 normal end of the stream, or completed exceptionally if there is a failure is signaled in
 the stream.
 <p>
 Note that the classic or typed <code>ActorSystem</code> can be used as the <code>systemProvider</code> parameter.</div>
</li>
</ul>
<a id="runForeach(org.apache.pekko.japi.function.Procedure,org.apache.pekko.stream.Materializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runForeach</h4>
<pre class="methodSignature">public&nbsp;java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&nbsp;runForeach&#8203;(<a href="../../japi/function/Procedure.html" title="interface in org.apache.pekko.japi.function">Procedure</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f,
                                                             <a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>&nbsp;materializer)</pre>
<div class="block">Shortcut for running this <code>Source</code> with a foreach procedure. The given procedure is invoked
 for each received element.
 The returned <code>CompletionStage</code> will be completed normally when reaching the
 normal end of the stream, or completed exceptionally if there is a failure is signaled in
 the stream.
 <p>
 Prefer the method taking an <code>ActorSystem</code> unless you have special requirements</div>
</li>
</ul>
<a id="map(org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>map</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;map&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;&nbsp;f)</pre>
<div class="block">Transform this stream by applying the given function to each of the elements
 as they pass through this processing step.
 <p>
 '''Emits when''' the mapping function returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="wireTap(org.apache.pekko.japi.function.Procedure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wireTap</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;wireTap&#8203;(<a href="../../japi/function/Procedure.html" title="interface in org.apache.pekko.japi.function">Procedure</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f)</pre>
<div class="block">This is a simplified version of <code>wireTap(Sink)</code> that takes only a simple procedure.
 Elements will be passed into this "side channel" function, and any of its results will be ignored.
 <p>
 If the wire-tap operation is slow (it backpressures), elements that would've been sent to it will be dropped instead.
 <p>
 It is similar to <a href="#alsoTo(org.apache.pekko.stream.Graph)"><code>alsoTo(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, ?&gt;)</code></a> which does backpressure instead of dropping elements.
 <p>
 This operation is useful for inspecting the passed through element, usually by means of side-effecting
 operations (such as <code>println</code>, or emitting metrics), for each element without having to modify it.
 <p>
 For logging signals (elements, completion, error) consider using the <a href="#log(java.lang.String,org.apache.pekko.japi.function.Function,org.apache.pekko.event.LoggingAdapter)"><code>log(java.lang.String,org.apache.pekko.japi.function.Function&lt;Out,java.lang.Object&gt;,org.apache.pekko.event.LoggingAdapter)</code></a> operator instead,
 along with appropriate <code>ActorAttributes.createLogLevels</code>.
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels; Note that failures of the <code>f</code> function will not cause cancellation</div>
</li>
</ul>
<a id="recover(scala.PartialFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recover</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;recover&#8203;(scala.PartialFunction&lt;java.lang.Throwable,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;pf)</pre>
<div class="block">Recover allows to send last element on failure and gracefully complete the stream
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This operator can recover the failure signal, but not the skipped elements, which will be dropped.
 <p>
 Throwing an exception inside <code>recover</code> _will_ be logged on ERROR level automatically.
 <p>
 '''Emits when''' element is available from the upstream or upstream is failed and pf returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or upstream failed with exception pf can handle
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="recover(java.lang.Class,java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recover</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;recover&#8203;(java.lang.Class&lt;? extends java.lang.Throwable&gt;&nbsp;clazz,
                                     java.util.function.Supplier&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;supplier)</pre>
<div class="block">Recover allows to send last element on failure and gracefully complete the stream
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This operator can recover the failure signal, but not the skipped elements, which will be dropped.
 <p>
 Throwing an exception inside <code>recover</code> _will_ be logged on ERROR level automatically.
 <p>
 '''Emits when''' element is available from the upstream or upstream is failed and pf returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or upstream failed with exception pf can handle
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="mapError(scala.PartialFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapError</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mapError&#8203;(scala.PartialFunction&lt;java.lang.Throwable,&#8203;java.lang.Throwable&gt;&nbsp;pf)</pre>
<div class="block">While similar to <a href="#recover(scala.PartialFunction)"><code>recover(scala.PartialFunction&lt;java.lang.Throwable,Out&gt;)</code></a> this operator can be used to transform an error signal to a different one *without* logging
 it as an error in the process. So in that sense it is NOT exactly equivalent to <code>recover(t =&gt; throw t2)</code> since recover
 would log the <code>t2</code> error.
 <p>
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This operator can recover the failure signal, but not the skipped elements, which will be dropped.
 <p>
 Similarly to <a href="#recover(scala.PartialFunction)"><code>recover(scala.PartialFunction&lt;java.lang.Throwable,Out&gt;)</code></a> throwing an exception inside <code>mapError</code> _will_ be logged.
 <p>
 '''Emits when''' element is available from the upstream or upstream is failed and pf returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or upstream failed with exception pf can handle
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="mapError(java.lang.Class,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapError</h4>
<pre class="methodSignature">public&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mapError&#8203;(java.lang.Class&lt;E&gt;&nbsp;clazz,
                                                                      <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;E,&#8203;java.lang.Throwable&gt;&nbsp;f)</pre>
<div class="block">While similar to <a href="#recover(scala.PartialFunction)"><code>recover(scala.PartialFunction&lt;java.lang.Throwable,Out&gt;)</code></a> this operator can be used to transform an error signal to a different one *without* logging
 it as an error in the process. So in that sense it is NOT exactly equivalent to <code>recover(t =&gt; throw t2)</code> since recover
 would log the <code>t2</code> error.
 <p>
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This operator can recover the failure signal, but not the skipped elements, which will be dropped.
 <p>
 Similarly to <a href="#recover(scala.PartialFunction)"><code>recover(scala.PartialFunction&lt;java.lang.Throwable,Out&gt;)</code></a> throwing an exception inside <code>mapError</code> _will_ be logged.
 <p>
 '''Emits when''' element is available from the upstream or upstream is failed and pf returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or upstream failed with exception pf can handle
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="recoverWith(scala.PartialFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverWith</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;recoverWith&#8203;(scala.PartialFunction&lt;java.lang.Throwable,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;pf)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">use <code>recoverWithRetries</code> instead</div>
</div>
<div class="block">RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
 a failure has been recovered so that each time there is a failure it is fed into the <code>pf</code> and a new
 Source may be materialized.
 <p>
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This operator can recover the failure signal, but not the skipped elements, which will be dropped.
 <p>
 Throwing an exception inside <code>recoverWith</code> _will_ be logged on ERROR level automatically.
 <p>
 '''Emits when''' element is available from the upstream or upstream is failed and element is available
 from alternative Source
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or upstream failed with exception pf can handle
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
</li>
</ul>
<a id="recoverWith(java.lang.Class,java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverWith</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;recoverWith&#8203;(java.lang.Class&lt;? extends java.lang.Throwable&gt;&nbsp;clazz,
                                         java.util.function.Supplier&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;supplier)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">use <code>recoverWithRetries</code> instead</div>
</div>
<div class="block">RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
 a failure has been recovered so that each time there is a failure it is fed into the <code>pf</code> and a new
 Source may be materialized.
 <p>
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This operator can recover the failure signal, but not the skipped elements, which will be dropped.
 <p>
 Throwing an exception inside <code>recoverWith</code> _will_ be logged on ERROR level automatically.
 <p>
 '''Emits when''' element is available from the upstream or upstream is failed and element is available
 from alternative Source
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or upstream failed with exception pf can handle
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
</li>
</ul>
<a id="recoverWithRetries(int,scala.PartialFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverWithRetries</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;recoverWithRetries&#8203;(int&nbsp;attempts,
                                                scala.PartialFunction&lt;java.lang.Throwable,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;pf)</pre>
<div class="block">RecoverWithRetries allows to switch to alternative Source on flow failure. It will stay in effect after
 a failure has been recovered up to <code>attempts</code> number of times so that each time there is a failure
 it is fed into the <code>pf</code> and a new Source may be materialized. Note that if you pass in 0, this won't
 attempt to recover at all.
 <p>
 A negative <code>attempts</code> number is interpreted as "infinite", which results in the exact same behavior as <code>recoverWith</code>.
 <p>
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This operator can recover the failure signal, but not the skipped elements, which will be dropped.
 <p>
 Throwing an exception inside <code>recoverWithRetries</code> _will_ be logged on ERROR level automatically.
 <p>
 '''Emits when''' element is available from the upstream or upstream is failed and element is available
 from alternative Source
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or upstream failed with exception pf can handle
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="recoverWithRetries(int,java.lang.Class,java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverWithRetries</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;recoverWithRetries&#8203;(int&nbsp;attempts,
                                                java.lang.Class&lt;? extends java.lang.Throwable&gt;&nbsp;clazz,
                                                java.util.function.Supplier&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;supplier)</pre>
<div class="block">RecoverWithRetries allows to switch to alternative Source on flow failure. It will stay in effect after
 a failure has been recovered up to <code>attempts</code> number of times so that each time there is a failure
 it is fed into the <code>pf</code> and a new Source may be materialized. Note that if you pass in 0, this won't
 attempt to recover at all.
 <p>
 A negative <code>attempts</code> number is interpreted as "infinite", which results in the exact same behavior as <code>recoverWith</code>.
 <p>
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This operator can recover the failure signal, but not the skipped elements, which will be dropped.
 <p>
 Throwing an exception inside <code>recoverWithRetries</code> _will_ be logged on ERROR level automatically.
 <p>
 '''Emits when''' element is available from the upstream or upstream is failed and element is available
 from alternative Source
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or upstream failed with exception pf can handle
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>attempts</code> - Maximum number of retries or -1 to retry indefinitely</dd>
<dd><code>clazz</code> - the class object of the failure cause</dd>
<dd><code>supplier</code> - supply the new Source to be materialized</dd>
</dl>
</li>
</ul>
<a id="mapConcat(org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapConcat</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mapConcat&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;? extends java.lang.Iterable&lt;T&gt;&gt;&nbsp;f)</pre>
<div class="block">Transform each input element into an <code>Iterable</code> of output elements that is
 then flattened into the output stream.
 <p>
 Make sure that the <code>Iterable</code> is immutable or at least not modified after
 being used as an output sequence. Otherwise the stream may fail with
 <code>ConcurrentModificationException</code> or other more subtle errors may occur.
 <p>
 The returned <code>Iterable</code> MUST NOT contain <code>null</code> values,
 as they are illegal as stream elements - according to the Reactive Streams specification.
 <p>
 '''Emits when''' the mapping function returns an element or there are still remaining elements
 from the previously calculated collection
 <p>
 '''Backpressures when''' downstream backpressures or there are still remaining elements from the
 previously calculated collection
 <p>
 '''Completes when''' upstream completes and all remaining elements has been emitted
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="statefulMap(org.apache.pekko.japi.function.Creator,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>statefulMap</h4>
<pre class="methodSignature">public&nbsp;&lt;S,&#8203;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;statefulMap&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;S&gt;&nbsp;create,
                                                   <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;S,&#8203;T&gt;&gt;&nbsp;f,
                                                   <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;S,&#8203;java.util.Optional&lt;T&gt;&gt;&nbsp;onComplete)</pre>
<div class="block">Transform each stream element with the help of a state.
 <p>
 The state creation function is invoked once when the stream is materialized and the returned state is passed to
 the mapping function for mapping the first element. The mapping function returns a mapped element to emit
 downstream and a state to pass to the next mapping function. The state can be the same for each mapping return,
 be a new immutable state but it is also safe to use a mutable state. The returned <code>T</code> MUST NOT be <code>null</code> as it is
 illegal as stream element - according to the Reactive Streams specification.
 <p>
 For stateless variant see <a href="#map(org.apache.pekko.japi.function.Function)"><code>&lt;T&gt;map(org.apache.pekko.japi.function.Function&lt;Out,T&gt;)</code></a>.
 <p>
 The <code>onComplete</code> function is called only once when the upstream or downstream finished, You can do some clean-up here,
 and if the returned value is not empty, it will be emitted to the downstream if available, otherwise the value will be dropped.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the mapping function returns an element and downstream is ready to consume it
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>create</code> - a function that creates the initial state</dd>
<dd><code>f</code> - a function that transforms the upstream element and the state into a pair of next state and output element</dd>
<dd><code>onComplete</code> - a function that transforms the ongoing state into an optional output element</dd>
</dl>
</li>
</ul>
<a id="statefulMapConcat(org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>statefulMapConcat</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;statefulMapConcat&#8203;(<a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Iterable&lt;T&gt;&gt;&gt;&nbsp;f)</pre>
<div class="block">Transform each input element into an <code>Iterable</code> of output elements that is
 then flattened into the output stream. The transformation is meant to be stateful,
 which is enabled by creating the transformation function anew for every materialization &#x2014;
 the returned function will typically close over mutable objects to store state between
 invocations. For the stateless variant see <a href="#mapConcat(org.apache.pekko.japi.function.Function)"><code>mapConcat(org.apache.pekko.japi.function.Function&lt;Out, ? extends java.lang.Iterable&lt;T&gt;&gt;)</code></a>.
 <p>
 Make sure that the <code>Iterable</code> is immutable or at least not modified after
 being used as an output sequence. Otherwise the stream may fail with
 <code>ConcurrentModificationException</code> or other more subtle errors may occur.
 <p>
 The returned <code>Iterable</code> MUST NOT contain <code>null</code> values,
 as they are illegal as stream elements - according to the Reactive Streams specification.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the mapping function returns an element or there are still remaining elements
 from the previously calculated collection
 <p>
 '''Backpressures when''' downstream backpressures or there are still remaining elements from the
 previously calculated collection
 <p>
 '''Completes when''' upstream completes and all remaining elements has been emitted
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="mapAsync(int,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mapAsync&#8203;(int&nbsp;parallelism,
                                        <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;f)</pre>
<div class="block">Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns a <code>CompletionStage</code> and the
 value of that future will be emitted downstream. The number of CompletionStages
 that shall run in parallel is given as the first argument to <code></code>mapAsync<code></code>.
 These CompletionStages may complete in any order, but the elements that
 are emitted downstream are in the same order as received from upstream.
 <p>
 If the function <code>f</code> throws an exception or if the <code>CompletionStage</code> is completed
 with failure and the supervision decision is <code>pekko.stream.Supervision#stop</code>
 the stream will be completed with failure.
 <p>
 If the function <code>f</code> throws an exception or if the <code>CompletionStage</code> is completed
 with failure and the supervision decision is <code>pekko.stream.Supervision#resume</code> or
 <code>pekko.stream.Supervision#restart</code> the element is dropped and the stream continues.
 <p>
 The function <code>f</code> is always invoked on the elements in the order they arrive.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the CompletionStage returned by the provided function finishes for the next element in sequence
 <p>
 '''Backpressures when''' the number of CompletionStages reaches the configured parallelism and the downstream
 backpressures or the first CompletionStage is not completed
 <p>
 '''Completes when''' upstream completes and all CompletionStages has been completed and all elements has been emitted
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#mapAsyncUnordered(int,org.apache.pekko.japi.function.Function)"><code>mapAsyncUnordered(int, org.apache.pekko.japi.function.Function&lt;Out, java.util.concurrent.CompletionStage&lt;T&gt;&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="mapAsyncUnordered(int,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapAsyncUnordered</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;mapAsyncUnordered&#8203;(int&nbsp;parallelism,
                                                 <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;f)</pre>
<div class="block">Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns a <code>CompletionStage</code> and the
 value of that future will be emitted downstream. The number of CompletionStages
 that shall run in parallel is given as the first argument to <code></code>mapAsyncUnordered<code></code>.
 Each processed element will be emitted downstream as soon as it is ready, i.e. it is possible
 that the elements are not emitted downstream in the same order as received from upstream.
 <p>
 If the function <code>f</code> throws an exception or if the <code>CompletionStage</code> is completed
 with failure and the supervision decision is <code>pekko.stream.Supervision#stop</code>
 the stream will be completed with failure.
 <p>
 If the function <code>f</code> throws an exception or if the <code>CompletionStage</code> is completed
 with failure and the supervision decision is <code>pekko.stream.Supervision#resume</code> or
 <code>pekko.stream.Supervision#restart</code> the element is dropped and the stream continues.
 <p>
 The function <code>f</code> is always invoked on the elements in the order they arrive (even though the result of the CompletionStages
 returned by <code>f</code> might be emitted in a different order).
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' any of the CompletionStages returned by the provided function complete
 <p>
 '''Backpressures when''' the number of CompletionStages reaches the configured parallelism and the downstream backpressures
 <p>
 '''Completes when''' upstream completes and all CompletionStages has been completed and all elements has been emitted
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#mapAsync(int,org.apache.pekko.japi.function.Function)"><code>mapAsync(int, org.apache.pekko.japi.function.Function&lt;Out, java.util.concurrent.CompletionStage&lt;T&gt;&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="ask(org.apache.pekko.actor.ActorRef,java.lang.Class,org.apache.pekko.util.Timeout)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre class="methodSignature">public&nbsp;&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;ask&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
                                   java.lang.Class&lt;S&gt;&nbsp;mapTo,
                                   <a href="../../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</pre>
<div class="block">Use the <code>ask</code> pattern to send a request-reply message to the target <code>ref</code> actor.
 If any of the asks times out it will fail the stream with a <code>pekko.pattern.AskTimeoutException</code>.
 <p>
 The <code>mapTo</code> class parameter is used to cast the incoming responses to the expected response type.
 <p>
 Similar to the plain ask pattern, the target actor is allowed to reply with <code>org.apache.pekko.util.Status</code>.
 An <code>org.apache.pekko.util.Status#Failure</code> will cause the operator to fail with the cause carried in the <code>Failure</code> message.
 <p>
 Defaults to parallelism of 2 messages in flight, since while one ask message may be being worked on, the second one
 still be in the mailbox, so defaulting to sending the second one a bit earlier than when first ask has replied maintains
 a slightly healthier throughput.
 <p>
 The operator fails with an <code>pekko.stream.WatchedActorTerminatedException</code> if the target actor is terminated.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' any of the CompletionStages returned by the provided function complete
 <p>
 '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream backpressures
 <p>
 '''Completes when''' upstream completes and all futures have been completed and all elements have been emitted
 <p>
 '''Fails when''' the passed in actor terminates, or a timeout is exceeded in any of the asks performed
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="ask(int,org.apache.pekko.actor.ActorRef,java.lang.Class,org.apache.pekko.util.Timeout)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre class="methodSignature">public&nbsp;&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;ask&#8203;(int&nbsp;parallelism,
                                   <a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
                                   java.lang.Class&lt;S&gt;&nbsp;mapTo,
                                   <a href="../../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout)</pre>
<div class="block">Use the <code>ask</code> pattern to send a request-reply message to the target <code>ref</code> actor.
 If any of the asks times out it will fail the stream with a <code>pekko.pattern.AskTimeoutException</code>.
 <p>
 The <code>mapTo</code> class parameter is used to cast the incoming responses to the expected response type.
 <p>
 Similar to the plain ask pattern, the target actor is allowed to reply with <code>org.apache.pekko.util.Status</code>.
 An <code>org.apache.pekko.util.Status#Failure</code> will cause the operator to fail with the cause carried in the <code>Failure</code> message.
 <p>
 Parallelism limits the number of how many asks can be "in flight" at the same time.
 Please note that the elements emitted by this operator are in-order with regards to the asks being issued
 (i.e. same behaviour as mapAsync).
 <p>
 The operator fails with an <code>pekko.stream.WatchedActorTerminatedException</code> if the target actor is terminated.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' any of the CompletionStages returned by the provided function complete
 <p>
 '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream backpressures
 <p>
 '''Completes when''' upstream completes and all futures have been completed and all elements have been emitted
 <p>
 '''Fails when''' the passed in actor terminates, or a timeout is exceeded in any of the asks performed
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="watch(org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>watch</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;watch&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref)</pre>
<div class="block">The operator fails with an <code>pekko.stream.WatchedActorTerminatedException</code> if the target actor is terminated.
 <p>
 '''Emits when''' upstream emits
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Fails when''' the watched actor terminates
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="filter(org.apache.pekko.japi.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;filter&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</pre>
<div class="block">Only pass on those elements that satisfy the given predicate.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the given predicate returns true for the element
 <p>
 '''Backpressures when''' the given predicate returns true for the element and downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="filterNot(org.apache.pekko.japi.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterNot</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;filterNot&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</pre>
<div class="block">Only pass on those elements that NOT satisfy the given predicate.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the given predicate returns false for the element
 <p>
 '''Backpressures when''' the given predicate returns false for the element and downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="collect(scala.PartialFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collect</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;collect&#8203;(scala.PartialFunction&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;&nbsp;pf)</pre>
<div class="block">Transform this stream by applying the given partial function to each of the elements
 on which the function is defined as they pass through this processing step.
 Non-matching elements are filtered out.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the provided partial function is defined for the element
 <p>
 '''Backpressures when''' the partial function is defined for the element and downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="collectType(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectType</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;collectType&#8203;(java.lang.Class&lt;T&gt;&nbsp;clazz)</pre>
<div class="block">Transform this stream by testing the type of each of the elements
 on which the element is an instance of the provided type as they pass through this processing step.
 Non-matching elements are filtered out.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the element is an instance of the provided type
 <p>
 '''Backpressures when''' the element is an instance of the provided type and downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="grouped(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grouped</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;grouped&#8203;(int&nbsp;n)</pre>
<div class="block">Chunk up this stream into groups of the given size, with the last group
 possibly smaller than requested due to end-of-stream.
 <p>
 <code>n</code> must be positive, otherwise IllegalArgumentException is thrown.
 <p>
 '''Emits when''' the specified number of elements has been accumulated or upstream completed
 <p>
 '''Backpressures when''' a group has been assembled and downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="groupedWeighted(long,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupedWeighted</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;groupedWeighted&#8203;(long&nbsp;minWeight,
                                                             java.util.function.Function&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn)</pre>
<div class="block">Chunk up this stream into groups of elements that have a cumulative weight greater than or equal to
 the <code>minWeight</code>, with the last group possibly smaller than requested <code>minWeight</code> due to end-of-stream.
 <p>
 <code>minWeight</code> must be positive, otherwise IllegalArgumentException is thrown.
 <code>costFn</code> must return a non-negative result for all inputs, otherwise the stage will fail
 with an IllegalArgumentException.
 <p>
 '''Emits when''' the cumulative weight of elements is greater than or equal to the <code>minWeight</code> or upstream completed
 <p>
 '''Backpressures when''' a buffered group weighs more than <code>minWeight</code> and downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="limit(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limit</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;limit&#8203;(int&nbsp;n)</pre>
<div class="block">Ensure stream boundedness by limiting the number of elements from upstream.
 If the number of incoming elements exceeds max, it will signal
 upstream failure <code>StreamLimitException</code> downstream.
 <p>
 Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
 <p>
 The stream will be completed without producing any elements if <code>n</code> is zero
 or negative.
 <p>
 '''Emits when''' the specified number of elements to take has not yet been reached
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' the defined number of elements has been taken or upstream completes
 <p>
 '''Cancels when''' the defined number of elements has been taken or downstream cancels
 <p>
 See also <code>Flow.take</code>, <code>Flow.takeWithin</code>, <code>Flow.takeWhile</code></div>
</li>
</ul>
<a id="limitWeighted(long,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitWeighted</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;limitWeighted&#8203;(long&nbsp;n,
                                           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn)</pre>
<div class="block">Ensure stream boundedness by evaluating the cost of incoming elements
 using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
 evaluated cost of each element. If the accumulated cost exceeds max, it will signal
 upstream failure <code>StreamLimitException</code> downstream.
 <p>
 Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
 <p>
 The stream will be completed without producing any elements if <code>n</code> is zero
 or negative.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the specified number of elements to take has not yet been reached
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' the defined number of elements has been taken or upstream completes
 <p>
 '''Cancels when''' the defined number of elements has been taken or downstream cancels
 <p>
 See also <code>Flow.take</code>, <code>Flow.takeWithin</code>, <code>Flow.takeWhile</code></div>
</li>
</ul>
<a id="sliding(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sliding</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;sliding&#8203;(int&nbsp;n,
                                                     int&nbsp;step)</pre>
<div class="block">Apply a sliding window over the stream and return the windows as groups of elements, with the last group
 possibly smaller than requested due to end-of-stream.
 <p>
 <code>n</code> must be positive, otherwise IllegalArgumentException is thrown.
 <code>step</code> must be positive, otherwise IllegalArgumentException is thrown.
 <p>
 '''Emits when''' enough elements have been collected within the window or upstream completed
 <p>
 '''Backpressures when''' a window has been assembled and downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="scan(java.lang.Object,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a><a id="scan(T,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scan</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;scan&#8203;(T&nbsp;zero,
                                    <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;&nbsp;f)</pre>
<div class="block">Similar to <code>fold</code> but is not a terminal operation,
 emits its current value which starts at <code>zero</code> and then
 applies the current and next value to the given function <code>f</code>,
 emitting the next current value.
 <p>
 If the function <code>f</code> throws an exception and the supervision decision is
 <code>pekko.stream.Supervision#restart</code> current value starts at <code>zero</code> again
 the stream will continue.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 Note that the <code>zero</code> value must be immutable.
 <p>
 '''Emits when''' the function scanning the element returns a new element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="scanAsync(java.lang.Object,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a><a id="scanAsync(T,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scanAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;scanAsync&#8203;(T&nbsp;zero,
                                         <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;f)</pre>
<div class="block">Similar to <code>scan</code> but with a asynchronous function,
 emits its current value which starts at <code>zero</code> and then
 applies the current and next value to the given function <code>f</code>,
 emitting a <code>Future</code> that resolves to the next current value.
 <p>
 If the function <code>f</code> throws an exception and the supervision decision is
 <code>pekko.stream.Supervision.Restart</code> current value starts at <code>zero</code> again
 the stream will continue.
 <p>
 If the function <code>f</code> throws an exception and the supervision decision is
 <code>pekko.stream.Supervision.Resume</code> current value starts at the previous
 current value, or zero when it doesn't have one, and the stream will continue.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 Note that the <code>zero</code> value must be immutable.
 <p>
 '''Emits when''' the future returned by f<code> completes</code>
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes and the last future returned by <code>f</code> completes
 <p>
 '''Cancels when''' downstream cancels
 <p>
 See also <code>FlowOps#scan</code></div>
</li>
</ul>
<a id="fold(java.lang.Object,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a><a id="fold(T,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fold</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;fold&#8203;(T&nbsp;zero,
                                    <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;T&gt;&nbsp;f)</pre>
<div class="block">Similar to <code>scan</code> but only emits its result when the upstream completes,
 after which it also completes. Applies the given function <code>f</code> towards its current and next value,
 yielding the next current value.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 If the function <code>f</code> throws an exception and the supervision decision is
 <code>pekko.stream.Supervision#restart</code> current value starts at <code>zero</code> again
 the stream will continue.
 <p>
 Note that the <code>zero</code> value must be immutable.
 <p>
 '''Emits when''' upstream completes
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="foldAsync(java.lang.Object,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a><a id="foldAsync(T,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foldAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;foldAsync&#8203;(T&nbsp;zero,
                                         <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.concurrent.CompletionStage&lt;T&gt;&gt;&nbsp;f)</pre>
<div class="block">Similar to <code>fold</code> but with an asynchronous function.
 Applies the given function towards its current and next value,
 yielding the next current value.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 If the function <code>f</code> returns a failure and the supervision decision is
 <code>pekko.stream.Supervision.Restart</code> current value starts at <code>zero</code> again
 the stream will continue.
 <p>
 Note that the <code>zero</code> value must be immutable.
 <p>
 '''Emits when''' upstream completes
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="reduce(org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;reduce&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;f)</pre>
<div class="block">Similar to <code>fold</code> but uses first element as zero element.
 Applies the given function towards its current and next value,
 yielding the next current value.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' upstream completes
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="intersperse(java.lang.Object,java.lang.Object,java.lang.Object)">
<!--   -->
</a><a id="intersperse(Out,Out,Out)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersperse</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;intersperse&#8203;(<a href="Source.html" title="type parameter in Source">Out</a>&nbsp;start,
                                         <a href="Source.html" title="type parameter in Source">Out</a>&nbsp;inject,
                                         <a href="Source.html" title="type parameter in Source">Out</a>&nbsp;end)</pre>
<div class="block">Intersperses stream with provided element, similar to how <code>scala.collection.immutable.List.mkString</code>
 injects a separator between a List's elements.
 <p>
 Additionally can inject start and end marker elements to stream.
 <p>
 Examples:
 <p>
 <pre><code>
 Source&lt;Integer, ?&gt; nums = Source.from(Arrays.asList(0, 1, 2, 3));
 nums.intersperse(",");            //   1 , 2 , 3
 nums.intersperse("[", ",", "]");  // [ 1 , 2 , 3 ]
 </code></pre>
 <p>
 In case you want to only prepend or only append an element (yet still use the <code>intercept</code> feature
 to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
 version of intersperse (See <code>Source.concat</code> for semantics details):
 <p>
 <pre><code>
 Source.single("&gt;&gt; ").concat(list.intersperse(","))
 list.intersperse(",").concat(Source.single("END"))
 </code></pre>
 '''Emits when''' upstream emits (or before with the <code>start</code> element if provided)
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="intersperse(java.lang.Object)">
<!--   -->
</a><a id="intersperse(Out)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersperse</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;intersperse&#8203;(<a href="Source.html" title="type parameter in Source">Out</a>&nbsp;inject)</pre>
<div class="block">Intersperses stream with provided element, similar to how <code>scala.collection.immutable.List.mkString</code>
 injects a separator between a List's elements.
 <p>
 Additionally can inject start and end marker elements to stream.
 <p>
 Examples:
 <p>
 <pre><code>
 Source&lt;Integer, ?&gt; nums = Source.from(Arrays.asList(0, 1, 2, 3));
 nums.intersperse(",");            //   1 , 2 , 3
 nums.intersperse("[", ",", "]");  // [ 1 , 2 , 3 ]
 </code></pre>
 <p>
 '''Emits when''' upstream emits (or before with the <code>start</code> element if provided)
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="groupedWithin(int,scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupedWithin</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;groupedWithin&#8203;(int&nbsp;maxNumber,
                                                           scala.concurrent.duration.FiniteDuration&nbsp;duration)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Chunk up this stream into groups of elements received within a time window,
 or limited by the given number of elements, whatever happens first.
 Empty groups will not be emitted if no elements are received from upstream.
 The last group before end-of-stream will contain the buffered elements
 since the previously emitted group.
 <p>
 '''Emits when''' the configured time elapses since the last group has been emitted or <code>n</code> elements is buffered
 <p>
 '''Backpressures when''' downstream backpressures, and there are <code>n+1</code> buffered elements
 <p>
 '''Completes when''' upstream completes (emits last group)
 <p>
 '''Cancels when''' downstream completes
 <p>
 <code>maxNumber</code> must be positive, and <code>duration</code> must be greater than 0 seconds, otherwise
 IllegalArgumentException is thrown.</div>
</li>
</ul>
<a id="groupedWithin(int,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupedWithin</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;groupedWithin&#8203;(int&nbsp;maxNumber,
                                                           java.time.Duration&nbsp;duration)</pre>
<div class="block">Chunk up this stream into groups of elements received within a time window,
 or limited by the given number of elements, whatever happens first.
 Empty groups will not be emitted if no elements are received from upstream.
 The last group before end-of-stream will contain the buffered elements
 since the previously emitted group.
 <p>
 '''Emits when''' the configured time elapses since the last group has been emitted or <code>n</code> elements is buffered
 <p>
 '''Backpressures when''' downstream backpressures, and there are <code>n+1</code> buffered elements
 <p>
 '''Completes when''' upstream completes (emits last group)
 <p>
 '''Cancels when''' downstream completes
 <p>
 <code>maxNumber</code> must be positive, and <code>duration</code> must be greater than 0 seconds, otherwise
 IllegalArgumentException is thrown.</div>
</li>
</ul>
<a id="groupedWeightedWithin(long,org.apache.pekko.japi.function.Function,scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupedWeightedWithin</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;groupedWeightedWithin&#8203;(long&nbsp;maxWeight,
                                                                   <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn,
                                                                   scala.concurrent.duration.FiniteDuration&nbsp;duration)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Chunk up this stream into groups of elements received within a time window,
 or limited by the weight of the elements, whatever happens first.
 Empty groups will not be emitted if no elements are received from upstream.
 The last group before end-of-stream will contain the buffered elements
 since the previously emitted group.
 <p>
 '''Emits when''' the configured time elapses since the last group has been emitted or weight limit reached
 <p>
 '''Backpressures when''' downstream backpressures, and buffered group (+ pending element) weighs more than <code>maxWeight</code>
 <p>
 '''Completes when''' upstream completes (emits last group)
 <p>
 '''Cancels when''' downstream completes
 <p>
 <code>maxWeight</code> must be positive, and <code>duration</code> must be greater than 0 seconds, otherwise
 IllegalArgumentException is thrown.</div>
</li>
</ul>
<a id="groupedWeightedWithin(long,org.apache.pekko.japi.function.Function,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupedWeightedWithin</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;groupedWeightedWithin&#8203;(long&nbsp;maxWeight,
                                                                   <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn,
                                                                   java.time.Duration&nbsp;duration)</pre>
<div class="block">Chunk up this stream into groups of elements received within a time window,
 or limited by the weight of the elements, whatever happens first.
 Empty groups will not be emitted if no elements are received from upstream.
 The last group before end-of-stream will contain the buffered elements
 since the previously emitted group.
 <p>
 '''Emits when''' the configured time elapses since the last group has been emitted or weight limit reached
 <p>
 '''Backpressures when''' downstream backpressures, and buffered group (+ pending element) weighs more than <code>maxWeight</code>
 <p>
 '''Completes when''' upstream completes (emits last group)
 <p>
 '''Cancels when''' downstream completes
 <p>
 <code>maxWeight</code> must be positive, and <code>duration</code> must be greater than 0 seconds, otherwise
 IllegalArgumentException is thrown.</div>
</li>
</ul>
<a id="groupedWeightedWithin(long,int,org.apache.pekko.japi.function.Function,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupedWeightedWithin</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;groupedWeightedWithin&#8203;(long&nbsp;maxWeight,
                                                                   int&nbsp;maxNumber,
                                                                   <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn,
                                                                   java.time.Duration&nbsp;duration)</pre>
<div class="block">Chunk up this stream into groups of elements received within a time window,
 or limited by the weight and number of the elements, whatever happens first.
 Empty groups will not be emitted if no elements are received from upstream.
 The last group before end-of-stream will contain the buffered elements
 since the previously emitted group.
 <p>
 '''Emits when''' the configured time elapses since the last group has been emitted or weight limit reached
 <p>
 '''Backpressures when''' downstream backpressures, and buffered group (+ pending element) weighs more than
 <code>maxWeight</code> or has more than <code>maxNumber</code> elements
 <p>
 '''Completes when''' upstream completes (emits last group)
 <p>
 '''Cancels when''' downstream completes
 <p>
 <code>maxWeight</code> must be positive, <code>maxNumber</code> must be positive, and <code>duration</code> must be greater than 0 seconds,
 otherwise IllegalArgumentException is thrown.</div>
</li>
</ul>
<a id="delay(scala.concurrent.duration.FiniteDuration,org.apache.pekko.stream.DelayOverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delay</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;delay&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;of,
                                   <a href="../DelayOverflowStrategy.html" title="class in org.apache.pekko.stream">DelayOverflowStrategy</a>&nbsp;strategy)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Shifts elements emission in time by a specified amount. It allows to store elements
 in internal buffer while waiting for next element to be emitted. Depending on the defined
 <code>pekko.stream.DelayOverflowStrategy</code> it might drop elements or backpressure the upstream if
 there is no space available in the buffer.
 <p>
 Delay precision is 10ms to avoid unnecessary timer scheduling cycles
 <p>
 Internal buffer has default capacity 16. You can set buffer size by calling <code>withAttributes(inputBuffer)</code>
 <p>
 '''Emits when''' there is a pending element in the buffer and configured time for this element elapsed
  * EmitEarly - strategy do not wait to emit element if buffer is full
 <p>
 '''Backpressures when''' depending on OverflowStrategy
  * Backpressure - backpressures when buffer is full
  * DropHead, DropTail, DropBuffer - never backpressures
  * Fail - fails the stream if buffer gets full
 <p>
 '''Completes when''' upstream completes and buffered elements has been drained
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>of</code> - time to shift all messages</dd>
<dd><code>strategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="delay(java.time.Duration,org.apache.pekko.stream.DelayOverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delay</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;delay&#8203;(java.time.Duration&nbsp;of,
                                   <a href="../DelayOverflowStrategy.html" title="class in org.apache.pekko.stream">DelayOverflowStrategy</a>&nbsp;strategy)</pre>
<div class="block">Shifts elements emission in time by a specified amount. It allows to store elements
 in internal buffer while waiting for next element to be emitted. Depending on the defined
 <code>pekko.stream.DelayOverflowStrategy</code> it might drop elements or backpressure the upstream if
 there is no space available in the buffer.
 <p>
 Delay precision is 10ms to avoid unnecessary timer scheduling cycles
 <p>
 Internal buffer has default capacity 16. You can set buffer size by calling <code>withAttributes(inputBuffer)</code>
 <p>
 '''Emits when''' there is a pending element in the buffer and configured time for this element elapsed
  * EmitEarly - strategy do not wait to emit element if buffer is full
 <p>
 '''Backpressures when''' depending on OverflowStrategy
  * Backpressure - backpressures when buffer is full
  * DropHead, DropTail, DropBuffer - never backpressures
  * Fail - fails the stream if buffer gets full
 <p>
 '''Completes when''' upstream completes and buffered elements has been drained
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>of</code> - time to shift all messages</dd>
<dd><code>strategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="delayWith(java.util.function.Supplier,org.apache.pekko.stream.DelayOverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delayWith</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;delayWith&#8203;(java.util.function.Supplier&lt;<a href="DelayStrategy.html" title="interface in org.apache.pekko.stream.javadsl">DelayStrategy</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&gt;&nbsp;delayStrategySupplier,
                                       <a href="../DelayOverflowStrategy.html" title="class in org.apache.pekko.stream">DelayOverflowStrategy</a>&nbsp;overFlowStrategy)</pre>
<div class="block">Shifts elements emission in time by an amount individually determined through delay strategy a specified amount.
 It allows to store elements in internal buffer while waiting for next element to be emitted. Depending on the defined
 <code>pekko.stream.DelayOverflowStrategy</code> it might drop elements or backpressure the upstream if
 there is no space available in the buffer.
 <p>
 It determines delay for each ongoing element invoking <code>DelayStrategy.nextDelay(elem: T): FiniteDuration</code>.
 <p>
 Note that elements are not re-ordered: if an element is given a delay much shorter than its predecessor,
 it will still have to wait for the preceding element before being emitted.
 It is also important to notice that <a href="DelayStrategy.html" title="interface in org.apache.pekko.stream.javadsl"><code>DelayStrategy</code></a> can be stateful.
 <p>
 Delay precision is 10ms to avoid unnecessary timer scheduling cycles.
 <p>
 Internal buffer has default capacity 16. You can set buffer size by calling <code>addAttributes(inputBuffer)</code>
 <p>
 '''Emits when''' there is a pending element in the buffer and configured time for this element elapsed
  * EmitEarly - strategy do not wait to emit element if buffer is full
 <p>
 '''Backpressures when''' depending on OverflowStrategy
  * Backpressure - backpressures when buffer is full
  * DropHead, DropTail, DropBuffer - never backpressures
  * Fail - fails the stream if buffer gets full
 <p>
 '''Completes when''' upstream completes and buffered elements have been drained
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>delayStrategySupplier</code> - creates new <a href="DelayStrategy.html" title="interface in org.apache.pekko.stream.javadsl"><code>DelayStrategy</code></a> object for each materialization</dd>
<dd><code>overFlowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="drop(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drop</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;drop&#8203;(long&nbsp;n)</pre>
<div class="block">Discard the given number of elements at the beginning of the stream.
 No elements will be dropped if <code>n</code> is zero or negative.
 <p>
 '''Emits when''' the specified number of elements has been dropped already
 <p>
 '''Backpressures when''' the specified number of elements has been dropped and downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="dropWithin(scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dropWithin</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;dropWithin&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;duration)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Discard the elements received within the given duration at beginning of the stream.
 <p>
 '''Emits when''' the specified time elapsed and a new upstream element arrives
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="dropWithin(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dropWithin</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;dropWithin&#8203;(java.time.Duration&nbsp;duration)</pre>
<div class="block">Discard the elements received within the given duration at beginning of the stream.
 <p>
 '''Emits when''' the specified time elapsed and a new upstream element arrives
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="takeWhile(org.apache.pekko.japi.function.Predicate,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeWhile</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;takeWhile&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p,
                                       boolean&nbsp;inclusive)</pre>
<div class="block">Terminate processing (and cancel the upstream publisher) after predicate
 returns false for the first time, including the first failed element if inclusive is true
 Due to input buffering some elements may have been requested from upstream publishers
 that will then not be processed downstream of this step.
 <p>
 The stream will be completed without producing any elements if predicate is false for
 the first stream element.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the predicate is true
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' predicate returned false (or 1 after predicate returns false if <code>inclusive</code> or upstream completes
 <p>
 '''Cancels when''' predicate returned false or downstream cancels
 <p>
 See also <code>Source.limit</code>, <code>Source.limitWeighted</code></div>
</li>
</ul>
<a id="takeWhile(org.apache.pekko.japi.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeWhile</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;takeWhile&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</pre>
<div class="block">Terminate processing (and cancel the upstream publisher) after predicate
 returns false for the first time. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
 <p>
 The stream will be completed without producing any elements if predicate is false for
 the first stream element.
 <p>
 '''Emits when''' the predicate is true
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' predicate returned false or upstream completes
 <p>
 '''Cancels when''' predicate returned false or downstream cancels
 <p>
 See also <code>Source.limit</code>, <code>Source.limitWeighted</code></div>
</li>
</ul>
<a id="dropWhile(org.apache.pekko.japi.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dropWhile</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;dropWhile&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</pre>
<div class="block">Discard elements at the beginning of the stream while predicate is true.
 No elements will be dropped after predicate first time returned false.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' predicate returned false and for all following stream elements
 <p>
 '''Backpressures when''' predicate returned false and downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p</code> - predicate is evaluated for each new element until first time returns false</dd>
</dl>
</li>
</ul>
<a id="take(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>take</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;take&#8203;(long&nbsp;n)</pre>
<div class="block">Terminate processing (and cancel the upstream publisher) after the given
 number of elements. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
 <p>
 The stream will be completed without producing any elements if <code>n</code> is zero
 or negative.
 <p>
 '''Emits when''' the specified number of elements to take has not yet been reached
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' the defined number of elements has been taken or upstream completes
 <p>
 '''Cancels when''' the defined number of elements has been taken or downstream cancels</div>
</li>
</ul>
<a id="takeWithin(scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeWithin</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;takeWithin&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;duration)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Terminate processing (and cancel the upstream publisher) after the given
 duration. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
 <p>
 Note that this can be combined with <a href="#take(long)"><code>take(long)</code></a> to limit the number of elements
 within the duration.
 <p>
 '''Emits when''' an upstream element arrives
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or timer fires
 <p>
 '''Cancels when''' downstream cancels or timer fires</div>
</li>
</ul>
<a id="takeWithin(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeWithin</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;takeWithin&#8203;(java.time.Duration&nbsp;duration)</pre>
<div class="block">Terminate processing (and cancel the upstream publisher) after the given
 duration. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
 <p>
 Note that this can be combined with <a href="#take(long)"><code>take(long)</code></a> to limit the number of elements
 within the duration.
 <p>
 '''Emits when''' an upstream element arrives
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or timer fires
 <p>
 '''Cancels when''' downstream cancels or timer fires</div>
</li>
</ul>
<a id="conflateWithSeed(org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>conflateWithSeed</h4>
<pre class="methodSignature">public&nbsp;&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;conflateWithSeed&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;seed,
                                                <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;aggregate)</pre>
<div class="block">Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
 upstream publisher is faster.
 <p>
 This version of conflate allows to derive a seed from the first element and change the aggregated type to be
 different than the input type. See <code>Flow.conflate</code> for a simpler version that does not change types.
 <p>
 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' downstream stops backpressuring and there is a conflated element available
 <p>
 '''Backpressures when''' never
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels
 <p>
 see also <code>Source.conflate</code>  <code>Source.batch</code> <code>Source.batchWeighted</code>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>seed</code> - Provides the first state for a conflated value using the first unconsumed element as a start</dd>
<dd><code>aggregate</code> - Takes the currently aggregated value and the current pending element to produce a new aggregate</dd>
</dl>
</li>
</ul>
<a id="conflate(org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>conflate</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;conflate&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;aggregate)</pre>
<div class="block">Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
 upstream publisher is faster.
 This version of conflate does not change the output type of the stream. See <code>Source.conflateWithSeed</code> for a
 more flexible version that can take a seed function and transform elements while rolling up.
 <p>
 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' downstream stops backpressuring and there is a conflated element available
 <p>
 '''Backpressures when''' never
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels
 <p>
 see also <code>Source.conflateWithSeed</code>  <code>Source.batch</code> <code>Source.batchWeighted</code>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>aggregate</code> - Takes the currently aggregated value and the current pending element to produce a new aggregate</dd>
</dl>
</li>
</ul>
<a id="batch(long,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>batch</h4>
<pre class="methodSignature">public&nbsp;&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;batch&#8203;(long&nbsp;max,
                                     <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;seed,
                                     <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;aggregate)</pre>
<div class="block">Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them. For example a batch step might store received elements in
 an array up to the allowed max limit if the upstream publisher is faster.
 <p>
 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' downstream stops backpressuring and there is an aggregated element available
 <p>
 '''Backpressures when''' there are <code>max</code> batched elements and 1 pending element and downstream backpressures
 <p>
 '''Completes when''' upstream completes and there is no batched/pending element waiting
 <p>
 '''Cancels when''' downstream cancels
 <p>
 See also <code>Source.conflate</code>, <code>Source.batchWeighted</code>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>max</code> - maximum number of elements to batch before backpressuring upstream (must be positive non-zero)</dd>
<dd><code>seed</code> - Provides the first state for a batched value using the first unconsumed element as a start</dd>
<dd><code>aggregate</code> - Takes the currently batched value and the current pending element to produce a new aggregate</dd>
</dl>
</li>
</ul>
<a id="batchWeighted(long,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>batchWeighted</h4>
<pre class="methodSignature">public&nbsp;&lt;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;batchWeighted&#8203;(long&nbsp;max,
                                             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Long&gt;&nbsp;costFn,
                                             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;seed,
                                             <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;S,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;S&gt;&nbsp;aggregate)</pre>
<div class="block">Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them. For example a batch step might concatenate <code>ByteString</code>
 elements up to the allowed max limit if the upstream publisher is faster.
 <p>
 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
 <p>
 Batching will apply for all elements, even if a single element cost is greater than the total allowed limit.
 In this case, previous batched elements will be emitted, then the "heavy" element will be emitted (after
 being applied with the <code>seed</code> function) without batching further elements with it, and then the rest of the
 incoming elements are batched.
 <p>
 '''Emits when''' downstream stops backpressuring and there is a batched element available
 <p>
 '''Backpressures when''' there are <code>max</code> weighted batched elements + 1 pending element and downstream backpressures
 <p>
 '''Completes when''' upstream completes and there is no batched/pending element waiting
 <p>
 '''Cancels when''' downstream cancels
 <p>
 See also <code>Source.conflate</code>, <code>Source.batch</code>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>max</code> - maximum weight of elements to batch before backpressuring upstream (must be positive non-zero)</dd>
<dd><code>costFn</code> - a function to compute a single element weight</dd>
<dd><code>seed</code> - Provides the first state for a batched value using the first unconsumed element as a start</dd>
<dd><code>aggregate</code> - Takes the currently batched value and the current pending element to produce a new batch</dd>
</dl>
</li>
</ul>
<a id="expand(org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>expand</h4>
<pre class="methodSignature">public&nbsp;&lt;U&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;U,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;expand&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.Iterator&lt;U&gt;&gt;&nbsp;expander)</pre>
<div class="block">Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
 element until new element comes from the upstream. For example an expand step might repeat the last element for
 the subscriber until it receives an update from upstream.
 <p>
 This element will never "drop" upstream elements as all elements go through at least one extrapolation step.
 This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
 subscriber.
 <p>
 Expand does not support <code>pekko.stream.Supervision#restart</code> and <code>pekko.stream.Supervision#resume</code>.
 Exceptions from the <code>expander</code> function will complete the stream with failure.
 <p>
 See also <a href="#extrapolate(org.apache.pekko.japi.function.Function)"><code>extrapolate(org.apache.pekko.japi.function.Function&lt;Out, java.util.Iterator&lt;Out&gt;&gt;)</code></a> for a version that always preserves the original element and allows for an initial "startup" element.
 <p>
 '''Emits when''' downstream stops backpressuring
 <p>
 '''Backpressures when''' downstream backpressures or iterator runs empty
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expander</code> - Takes the current extrapolation state to produce an output element and the next extrapolation
                       state.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#extrapolate(org.apache.pekko.japi.function.Function)"><code>extrapolate(org.apache.pekko.japi.function.Function&lt;Out, java.util.Iterator&lt;Out&gt;&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="extrapolate(org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extrapolate</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;extrapolate&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.Iterator&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&gt;&nbsp;extrapolator)</pre>
<div class="block">Allows a faster downstream to progress independent of a slower upstream.
 <p>
 This is achieved by introducing "extrapolated" elements - based on those from upstream - whenever downstream
 signals demand.
 <p>
 Extrapolate does not support <code>pekko.stream.Supervision#restart</code> and <code>pekko.stream.Supervision#resume</code>.
 Exceptions from the <code>extrapolate</code> function will complete the stream with failure.
 <p>
 See also <a href="#expand(org.apache.pekko.japi.function.Function)"><code>expand(org.apache.pekko.japi.function.Function&lt;Out, java.util.Iterator&lt;U&gt;&gt;)</code></a> for a version that can overwrite the original element.
 <p>
 '''Emits when''' downstream stops backpressuring, AND EITHER upstream emits OR initial element is present OR
 <code>extrapolate</code> is non-empty and applicable
 <p>
 '''Backpressures when''' downstream backpressures or current <code>extrapolate</code> runs empty
 <p>
 '''Completes when''' upstream completes and current <code>extrapolate</code> runs empty
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>extrapolator</code> - Takes the current upstream element and provides a sequence of "extrapolated" elements based
                    on the original, to be emitted in case downstream signals demand.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#expand(org.apache.pekko.japi.function.Function)"><code>expand(org.apache.pekko.japi.function.Function&lt;Out, java.util.Iterator&lt;U&gt;&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="extrapolate(org.apache.pekko.japi.function.Function,java.lang.Object)">
<!--   -->
</a><a id="extrapolate(org.apache.pekko.japi.function.Function,Out)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extrapolate</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;extrapolate&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.util.Iterator&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&gt;&nbsp;extrapolator,
                                         <a href="Source.html" title="type parameter in Source">Out</a>&nbsp;initial)</pre>
<div class="block">Allows a faster downstream to progress independent of a slower upstream.
 <p>
 This is achieved by introducing "extrapolated" elements - based on those from upstream - whenever downstream
 signals demand.
 <p>
 Extrapolate does not support <code>pekko.stream.Supervision#restart</code> and <code>pekko.stream.Supervision#resume</code>.
 Exceptions from the <code>extrapolate</code> function will complete the stream with failure.
 <p>
 See also <a href="#expand(org.apache.pekko.japi.function.Function)"><code>expand(org.apache.pekko.japi.function.Function&lt;Out, java.util.Iterator&lt;U&gt;&gt;)</code></a> for a version that can overwrite the original element.
 <p>
 '''Emits when''' downstream stops backpressuring, AND EITHER upstream emits OR initial element is present OR
 <code>extrapolate</code> is non-empty and applicable
 <p>
 '''Backpressures when''' downstream backpressures or current <code>extrapolate</code> runs empty
 <p>
 '''Completes when''' upstream completes and current <code>extrapolate</code> runs empty
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>extrapolator</code> - takes the current upstream element and provides a sequence of "extrapolated" elements based
                     on the original, to be emitted in case downstream signals demand.</dd>
<dd><code>initial</code> - the initial element to be emitted, in case upstream is able to stall the entire stream.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#expand(org.apache.pekko.japi.function.Function)"><code>expand(org.apache.pekko.japi.function.Function&lt;Out, java.util.Iterator&lt;U&gt;&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="buffer(int,org.apache.pekko.stream.OverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;buffer&#8203;(int&nbsp;size,
                                    <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</pre>
<div class="block">Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
 Depending on the defined <code>pekko.stream.OverflowStrategy</code> it might drop elements or backpressure the upstream if
 there is no space available
 <p>
 '''Emits when''' downstream stops backpressuring and there is a pending element in the buffer
 <p>
 '''Backpressures when''' downstream backpressures or depending on OverflowStrategy:
  <ul>
    <li>Backpressure - backpressures when buffer is full</li>
    <li>DropHead, DropTail, DropBuffer - never backpressures</li>
    <li>Fail - fails the stream if buffer gets full</li>
  </ul>
 <p>
 '''Completes when''' upstream completes and buffered elements has been drained
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - The size of the buffer in element count</dd>
<dd><code>overflowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="prefixAndTail(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prefixAndTail</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;java.util.List&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;prefixAndTail&#8203;(int&nbsp;n)</pre>
<div class="block">Takes up to <code>n</code> elements from the stream (less than <code>n</code> if the upstream completes before emitting <code>n</code> elements)
 and returns a pair containing a strict sequence of the taken element
 and a stream representing the remaining elements. If ''n'' is zero or negative, then this will return a pair
 of an empty collection and a stream containing the whole upstream unchanged.
 <p>
 In case of an upstream error, depending on the current state
  - the master stream signals the error if less than <code>n</code> elements has been seen, and therefore the substream
    has not yet been emitted
  - the tail substream signals the error after the prefix and tail has been emitted by the main stream
    (at that point the main stream has already completed)
 <p>
 '''Emits when''' the configured number of prefix elements are available. Emits this prefix, and the rest
 as a substream
 <p>
 '''Backpressures when''' downstream backpressures or substream backpressures
 <p>
 '''Completes when''' prefix elements has been consumed and substream has been consumed
 <p>
 '''Cancels when''' downstream cancels or substream cancels</div>
</li>
</ul>
<a id="flatMapPrefix(int,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapPrefix</h4>
<pre class="methodSignature">public&nbsp;&lt;Out2,&#8203;Mat2&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out2,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;flatMapPrefix&#8203;(int&nbsp;n,
                                                              <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Iterable&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Flow.html" title="class in org.apache.pekko.stream.javadsl">Flow</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Mat2&gt;&gt;&nbsp;f)</pre>
<div class="block">Takes up to <code>n</code> elements from the stream (less than <code>n</code> only if the upstream completes before emitting <code>n</code> elements),
 then apply <code>f</code> on these elements in order to obtain a flow, this flow is then materialized and the rest of the input is processed by this flow (similar to via).
 This method returns a flow consuming the rest of the stream producing the materialized flow's output.
 <p>
 '''Emits when''' the materialized flow emits.
  Notice the first <code>n</code> elements are buffered internally before materializing the flow and connecting it to the rest of the upstream - producing elements at its own discretion (might 'swallow' or multiply elements).
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' the materialized flow completes.
  If upstream completes before producing <code>n</code> elements, <code>f</code> will be applied with the provided elements,
  the resulting flow will be materialized and signalled for upstream completion, it can then complete or continue to emit elements at its own discretion.
 <p>
 '''Cancels when''' the materialized flow cancels.
  Notice that when downstream cancels prior to prefix completion, the cancellation cause is stashed until prefix completion (or upstream completion) and then handed to the materialized flow.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - the number of elements to accumulate before materializing the downstream flow.</dd>
<dd><code>f</code> - a function that produces the downstream flow based on the upstream's prefix.</dd>
</dl>
</li>
</ul>
<a id="flatMapPrefixMat(int,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapPrefixMat</h4>
<pre class="methodSignature">public&nbsp;&lt;Out2,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Out2,&#8203;Mat3&gt;&nbsp;flatMapPrefixMat&#8203;(int&nbsp;n,
                                                                             <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;java.lang.Iterable&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;<a href="Flow.html" title="class in org.apache.pekko.stream.javadsl">Flow</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Out2,&#8203;Mat2&gt;&gt;&nbsp;f,
                                                                             <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;java.util.concurrent.CompletionStage&lt;Mat2&gt;,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">mat version of <a href="#flatMapPrefix(int,org.apache.pekko.japi.function.Function)"><code>flatMapPrefix(int, org.apache.pekko.japi.function.Function&lt;java.lang.Iterable&lt;Out&gt;, org.apache.pekko.stream.javadsl.Flow&lt;Out, Out2, Mat2&gt;&gt;)</code></a>, this method gives access to a future materialized value of the downstream flow (as a completion stage).
 see <a href="#flatMapPrefix(int,org.apache.pekko.japi.function.Function)"><code>flatMapPrefix(int, org.apache.pekko.japi.function.Function&lt;java.lang.Iterable&lt;Out&gt;, org.apache.pekko.stream.javadsl.Flow&lt;Out, Out2, Mat2&gt;&gt;)</code></a> for details.</div>
</li>
</ul>
<a id="groupBy(int,org.apache.pekko.japi.function.Function,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre class="methodSignature">public&nbsp;&lt;K&gt;&nbsp;<a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;groupBy&#8203;(int&nbsp;maxSubstreams,
                                            <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;K&gt;&nbsp;f,
                                            boolean&nbsp;allowClosedSubstreamRecreation)</pre>
<div class="block">This operation demultiplexes the incoming stream into separate output
 streams, one for each element key. The key is computed for each element
 using the given function. When a new key is encountered for the first time
 a new substream is opened and subsequently fed with all elements belonging to
 that key.
 <p>
 WARNING: If <code>allowClosedSubstreamRecreation</code> is set to <code>false</code> (default behavior) the operator
 keeps track of all keys of streams that have already been closed. If you expect an infinite
 number of keys this can cause memory issues. Elements belonging to those keys are drained
 directly and not send to the substream.
 <p>
 Note: If <code>allowClosedSubstreamRecreation</code> is set to <code>true</code> substream completion and incoming
 elements are subject to race-conditions. If elements arrive for a stream that is in the process
 of closing these elements might get lost.
 <p>
 The object returned from this method is not a normal <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>,
 it is a <a href="SubFlow.html" title="class in org.apache.pekko.stream.javadsl"><code>SubFlow</code></a>. This means that after this operator all transformations
 are applied to all encountered substreams in the same fashion. Substream mode
 is exited either by closing the substream (i.e. connecting it to a <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>)
 or by merging the substreams back together; see the <code>to</code> and <code>mergeBack</code> methods
 on <a href="SubFlow.html" title="class in org.apache.pekko.stream.javadsl"><code>SubFlow</code></a> for more information.
 <p>
 It is important to note that the substreams also propagate back-pressure as
 any other stream, which means that blocking one substream will block the <code>groupBy</code>
 operator itself&#x2014;and thereby all substreams&#x2014;once all internal or
 explicit buffers are filled.
 <p>
 If the group by function <code>f</code> throws an exception and the supervision decision
 is <code>pekko.stream.Supervision#stop</code> the stream and substreams will be completed
 with failure.
 <p>
 If the group by function <code>f</code> throws an exception and the supervision decision
 is <code>pekko.stream.Supervision#resume</code> or <code>pekko.stream.Supervision#restart</code>
 the element is dropped and the stream and substreams continue.
 <p>
 Function <code>f</code>  MUST NOT return <code>null</code>. This will throw exception and trigger supervision decision mechanism.
 <p>
 '''Emits when''' an element for which the grouping function returns a group that has not yet been created.
 Emits the new group
 <p>
 '''Backpressures when''' there is an element pending for a group whose substream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels and all substreams cancel
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxSubstreams</code> - configures the maximum number of substreams (keys)
        that are supported; if more distinct keys are encountered then the stream fails</dd>
<dd><code>f</code> - computes the key for each element</dd>
<dd><code>allowClosedSubstreamRecreation</code> - enables recreation of already closed substreams if elements with their
        corresponding keys arrive after completion</dd>
</dl>
</li>
</ul>
<a id="groupBy(int,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre class="methodSignature">public&nbsp;&lt;K&gt;&nbsp;<a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;groupBy&#8203;(int&nbsp;maxSubstreams,
                                            <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;K&gt;&nbsp;f)</pre>
<div class="block">This operation demultiplexes the incoming stream into separate output
 streams, one for each element key. The key is computed for each element
 using the given function. When a new key is encountered for the first time
 a new substream is opened and subsequently fed with all elements belonging to
 that key.
 <p>
 The object returned from this method is not a normal <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>,
 it is a <a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl"><code>SubSource</code></a>. This means that after this operator all transformations
 are applied to all encountered substreams in the same fashion. Substream mode
 is exited either by closing the substream (i.e. connecting it to a <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>)
 or by merging the substreams back together; see the <code>to</code> and <code>mergeBack</code> methods
 on <a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl"><code>SubSource</code></a> for more information.
 <p>
 It is important to note that the substreams also propagate back-pressure as
 any other stream, which means that blocking one substream will block the <code>groupBy</code>
 operator itself&#x2014;and thereby all substreams&#x2014;once all internal or
 explicit buffers are filled.
 <p>
 If the group by function <code>f</code> throws an exception and the supervision decision
 is <code>pekko.stream.Supervision#stop</code> the stream and substreams will be completed
 with failure.
 <p>
 If the group by function <code>f</code> throws an exception and the supervision decision
 is <code>pekko.stream.Supervision#resume</code> or <code>pekko.stream.Supervision#restart</code>
 the element is dropped and the stream and substreams continue.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' an element for which the grouping function returns a group that has not yet been created.
 Emits the new group
 <p>
 '''Backpressures when''' there is an element pending for a group whose substream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels and all substreams cancel
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxSubstreams</code> - configures the maximum number of substreams (keys)
        that are supported; if more distinct keys are encountered then the stream fails</dd>
</dl>
</li>
</ul>
<a id="splitWhen(org.apache.pekko.japi.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>splitWhen</h4>
<pre class="methodSignature">public&nbsp;<a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;splitWhen&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</pre>
<div class="block">This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams, always beginning a new one with
 the current element if the given predicate returns true for it. This means
 that for the following series of predicate values, three substreams will
 be produced with lengths 1, 2, and 3:
 <p>
 <pre><code>
 false,             // element goes into first substream
 true, false,       // elements go into second substream
 true, false, false // elements go into third substream
 </code></pre>
 <p>
 In case the *first* element of the stream matches the predicate, the first
 substream emitted by splitWhen will start from that element. For example:
 <p>
 <pre><code>
 true, false, false // first substream starts from the split-by element
 true, false        // subsequent substreams operate the same way
 </code></pre>
 <p>
 The object returned from this method is not a normal <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>,
 it is a <a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl"><code>SubSource</code></a>. This means that after this operator all transformations
 are applied to all encountered substreams in the same fashion. Substream mode
 is exited either by closing the substream (i.e. connecting it to a <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>)
 or by merging the substreams back together; see the <code>to</code> and <code>mergeBack</code> methods
 on <a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl"><code>SubSource</code></a> for more information.
 <p>
 It is important to note that the substreams also propagate back-pressure as
 any other stream, which means that blocking one substream will block the <code>splitWhen</code>
 operator itself&#x2014;and thereby all substreams&#x2014;once all internal or
 explicit buffers are filled.
 <p>
 If the split predicate <code>p</code> throws an exception and the supervision decision
 is <code>pekko.stream.Supervision.Stop</code> the stream and substreams will be completed
 with failure.
 <p>
 If the split predicate <code>p</code> throws an exception and the supervision decision
 is <code>pekko.stream.Supervision.Resume</code> or <code>pekko.stream.Supervision.Restart</code>
 the element is dropped and the stream and substreams continue.
 <p>
 '''Emits when''' an element for which the provided predicate is true, opening and emitting a new substream for subsequent element
 <p>
 '''Backpressures when''' there is an element pending for the next substream, but the previous is not fully consumed yet, or the substream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels and substreams cancel
 <p>
 See also <code>Source.splitAfter</code>.</div>
</li>
</ul>
<a id="splitWhen(org.apache.pekko.stream.SubstreamCancelStrategy,org.apache.pekko.japi.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>splitWhen</h4>
<pre class="methodSignature">public&nbsp;<a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;splitWhen&#8203;(<a href="../SubstreamCancelStrategy.html" title="class in org.apache.pekko.stream">SubstreamCancelStrategy</a>&nbsp;substreamCancelStrategy,
                                          <a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</pre>
<div class="block">This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams, always beginning a new one with
 the current element if the given predicate returns true for it.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#splitWhen(org.apache.pekko.japi.function.Predicate)"><code>splitWhen(org.apache.pekko.japi.function.Predicate&lt;Out&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="splitAfter(org.apache.pekko.japi.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>splitAfter</h4>
<pre class="methodSignature">public&nbsp;<a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;splitAfter&#8203;(<a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</pre>
<div class="block">This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams. It *ends* the current substream when the
 predicate is true. This means that for the following series of predicate values,
 three substreams will be produced with lengths 2, 2, and 3:
 <p>
 <pre><code>
 false, true,        // elements go into first substream
 false, true,        // elements go into second substream
 false, false, true  // elements go into third substream
 </code></pre>
 <p>
 The object returned from this method is not a normal <a href="Flow.html" title="class in org.apache.pekko.stream.javadsl"><code>Flow</code></a>,
 it is a <a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl"><code>SubSource</code></a>. This means that after this operator all transformations
 are applied to all encountered substreams in the same fashion. Substream mode
 is exited either by closing the substream (i.e. connecting it to a <a href="Sink.html" title="class in org.apache.pekko.stream.javadsl"><code>Sink</code></a>)
 or by merging the substreams back together; see the <code>to</code> and <code>mergeBack</code> methods
 on <a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl"><code>SubSource</code></a> for more information.
 <p>
 It is important to note that the substreams also propagate back-pressure as
 any other stream, which means that blocking one substream will block the <code>splitAfter</code>
 operator itself&#x2014;and thereby all substreams&#x2014;once all internal or
 explicit buffers are filled.
 <p>
 If the split predicate <code>p</code> throws an exception and the supervision decision
 is <code>pekko.stream.Supervision.Stop</code> the stream and substreams will be completed
 with failure.
 <p>
 If the split predicate <code>p</code> throws an exception and the supervision decision
 is <code>pekko.stream.Supervision.Resume</code> or <code>pekko.stream.Supervision.Restart</code>
 the element is dropped and the stream and substreams continue.
 <p>
 '''Emits when''' an element passes through. When the provided predicate is true it emits the element
 and opens a new substream for subsequent element
 <p>
 '''Backpressures when''' there is an element pending for the next substream, but the previous
 is not fully consumed yet, or the substream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels and substreams cancel
 <p>
 See also <code>Source.splitWhen</code>.</div>
</li>
</ul>
<a id="splitAfter(org.apache.pekko.stream.SubstreamCancelStrategy,org.apache.pekko.japi.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>splitAfter</h4>
<pre class="methodSignature">public&nbsp;<a href="SubSource.html" title="class in org.apache.pekko.stream.javadsl">SubSource</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;splitAfter&#8203;(<a href="../SubstreamCancelStrategy.html" title="class in org.apache.pekko.stream">SubstreamCancelStrategy</a>&nbsp;substreamCancelStrategy,
                                           <a href="../../japi/function/Predicate.html" title="interface in org.apache.pekko.japi.function">Predicate</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;p)</pre>
<div class="block">This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams. It *ends* the current substream when the
 predicate is true.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#splitAfter(org.apache.pekko.japi.function.Predicate)"><code>splitAfter(org.apache.pekko.japi.function.Predicate&lt;Out&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="flatMapConcat(org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapConcat</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;flatMapConcat&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;f)</pre>
<div class="block">Transform each input element into a <code>Source</code> of output elements that is
 then flattened into the output stream by concatenation,
 fully consuming one Source after the other.
 <p>
 '''Emits when''' a currently consumed substream has an element available
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes and all consumed substreams complete
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="flatMapMerge(int,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMerge</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;T,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;flatMapMerge&#8203;(int&nbsp;breadth,
                                                    <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;f)</pre>
<div class="block">Transform each input element into a <code>Source</code> of output elements that is
 then flattened into the output stream by merging, where at most <code>breadth</code>
 substreams are being consumed at any given time.
 <p>
 '''Emits when''' a currently consumed substream has an element available
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes and all consumed substreams complete
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="initialTimeout(scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initialTimeout</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;initialTimeout&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;timeout)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">If the first element has not passed through this operator before the provided timeout, the stream is failed
 with a <code>TimeoutException</code>.
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or fails if timeout elapses before first element arrives
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="initialTimeout(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initialTimeout</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;initialTimeout&#8203;(java.time.Duration&nbsp;timeout)</pre>
<div class="block">If the first element has not passed through this operator before the provided timeout, the stream is failed
 with a <code>TimeoutException</code>.
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or fails if timeout elapses before first element arrives
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="completionTimeout(scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completionTimeout</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;completionTimeout&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;timeout)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">If the completion of the stream does not happen until the provided timeout, the stream is failed
 with a <code>TimeoutException</code>.
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or fails if timeout elapses before upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="completionTimeout(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completionTimeout</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;completionTimeout&#8203;(java.time.Duration&nbsp;timeout)</pre>
<div class="block">If the completion of the stream does not happen until the provided timeout, the stream is failed
 with a <code>TimeoutException</code>.
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or fails if timeout elapses before upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="idleTimeout(scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;idleTimeout&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;timeout)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">If the time between two processed elements exceeds the provided timeout, the stream is failed
 with a <code>TimeoutException</code>. The timeout is checked periodically,
 so the resolution of the check is one period (equals to timeout value).
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or fails if timeout elapses between two emitted elements
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="idleTimeout(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;idleTimeout&#8203;(java.time.Duration&nbsp;timeout)</pre>
<div class="block">If the time between two processed elements exceeds the provided timeout, the stream is failed
 with a <code>TimeoutException</code>. The timeout is checked periodically,
 so the resolution of the check is one period (equals to timeout value).
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or fails if timeout elapses between two emitted elements
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="backpressureTimeout(scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>backpressureTimeout</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;backpressureTimeout&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;timeout)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
 the stream is failed with a <code>TimeoutException</code>. The timeout is checked periodically,
 so the resolution of the check is one period (equals to timeout value).
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or fails if timeout elapses between element emission and downstream demand.
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="backpressureTimeout(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>backpressureTimeout</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;backpressureTimeout&#8203;(java.time.Duration&nbsp;timeout)</pre>
<div class="block">If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
 the stream is failed with a <code>TimeoutException</code>. The timeout is checked periodically,
 so the resolution of the check is one period (equals to timeout value).
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes or fails if timeout elapses between element emission and downstream demand.
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="keepAlive(scala.concurrent.duration.FiniteDuration,org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>keepAlive</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;keepAlive&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;maxIdle,
                                       <a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;injectedElem)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Injects additional elements if upstream does not emit for a configured amount of time. In other words, this
 operator attempts to maintains a base rate of emitted elements towards the downstream.
 <p>
 If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
 do not accumulate during this period.
 <p>
 Upstream elements are always preferred over injected elements.
 <p>
 '''Emits when''' upstream emits an element or if the upstream was idle for the configured period
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="keepAlive(java.time.Duration,org.apache.pekko.japi.function.Creator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>keepAlive</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;keepAlive&#8203;(java.time.Duration&nbsp;maxIdle,
                                       <a href="../../japi/function/Creator.html" title="interface in org.apache.pekko.japi.function">Creator</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&nbsp;injectedElem)</pre>
<div class="block">Injects additional elements if upstream does not emit for a configured amount of time. In other words, this
 operator attempts to maintains a base rate of emitted elements towards the downstream.
 <p>
 If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
 do not accumulate during this period.
 <p>
 Upstream elements are always preferred over injected elements.
 <p>
 '''Emits when''' upstream emits an element or if the upstream was idle for the configured period
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="throttle(int,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttle</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttle&#8203;(int&nbsp;elements,
                                      java.time.Duration&nbsp;per)</pre>
<div class="block">Sends elements downstream with speed limited to <code>elements/per</code>. In other words, this operator set the maximum rate
 for emitting messages. This operator works for streams where all elements have the same cost or length.
 <p>
 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size).
 Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
 to allow some burstiness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as element costs. If there isn't any, throttle waits until the
 bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
 to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and
 started.
 <p>
 The burst size is calculated based on the given rate (<code>cost/per</code>) as 0.1 * rate, for example:
 - rate < 20/second =&gt; burst size 1
 - rate 20/second =&gt; burst size 2
 - rate 100/second =&gt; burst size 10
 - rate 200/second =&gt; burst size 20
 <p>
 The throttle <code>mode</code> is <code>pekko.stream.ThrottleMode.Shaping</code>, which makes pauses before emitting messages to
 meet throttle rate.
 <p>
 '''Emits when''' upstream emits an element and configured time per each element elapsed
 <p>
 '''Backpressures when''' downstream backpressures or the incoming rate is higher than the speed limit
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="throttle(int,scala.concurrent.duration.FiniteDuration,int,org.apache.pekko.stream.ThrottleMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttle</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttle&#8203;(int&nbsp;elements,
                                      scala.concurrent.duration.FiniteDuration&nbsp;per,
                                      int&nbsp;maximumBurst,
                                      <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Sends elements downstream with speed limited to <code>elements/per</code>. In other words, this operator set the maximum rate
 for emitting messages. This operator works for streams where all elements have the same cost or length.
 <p>
 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
 to allow some burstiness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as element costs. If there isn't any, throttle waits until the
 bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
 to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and started.
 <p>
 Parameter <code>mode</code> manages behavior when upstream is faster than throttle rate:
  - <code>pekko.stream.ThrottleMode.Shaping</code> makes pauses before emitting messages to meet throttle rate
  - <code>pekko.stream.ThrottleMode.Enforcing</code> fails with exception when upstream is faster than throttle rate
 <p>
 It is recommended to use non-zero burst sizes as they improve both performance and throttling precision by allowing
 the implementation to avoid using the scheduler when input rates fall below the enforced limit and to reduce
 most of the inaccuracy caused by the scheduler resolution (which is in the range of milliseconds).
 <p>
  WARNING: Be aware that throttle is using scheduler to slow down the stream. This scheduler has minimal time of triggering
  next push. Consequently it will slow down the stream as it has minimal pause for emitting. This can happen in
  case burst is 0 and speed is higher than 30 events per second. You need to increase the <code>maximumBurst</code>  if
  elements arrive with small interval (30 milliseconds or less). Use the overloaded <code>throttle</code> method without
  <code>maximumBurst</code> parameter to automatically calculate the <code>maximumBurst</code> based on the given rate (<code>cost/per</code>).
  In other words the throttler always enforces the rate limit when <code>maximumBurst</code> parameter is given, but in
  certain cases (mostly due to limited scheduler resolution) it enforces a tighter bound than what was prescribed.
 <p>
 '''Emits when''' upstream emits an element and configured time per each element elapsed
 <p>
 '''Backpressures when''' downstream backpressures or the incoming rate is higher than the speed limit
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="throttle(int,java.time.Duration,int,org.apache.pekko.stream.ThrottleMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttle</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttle&#8203;(int&nbsp;elements,
                                      java.time.Duration&nbsp;per,
                                      int&nbsp;maximumBurst,
                                      <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</pre>
<div class="block">Sends elements downstream with speed limited to <code>elements/per</code>. In other words, this operator set the maximum rate
 for emitting messages. This operator works for streams where all elements have the same cost or length.
 <p>
 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
 to allow some burstiness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as element costs. If there isn't any, throttle waits until the
 bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
 to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and started.
 <p>
 Parameter <code>mode</code> manages behavior when upstream is faster than throttle rate:
  - <code>pekko.stream.ThrottleMode.Shaping</code> makes pauses before emitting messages to meet throttle rate
  - <code>pekko.stream.ThrottleMode.Enforcing</code> fails with exception when upstream is faster than throttle rate
 <p>
 It is recommended to use non-zero burst sizes as they improve both performance and throttling precision by allowing
 the implementation to avoid using the scheduler when input rates fall below the enforced limit and to reduce
 most of the inaccuracy caused by the scheduler resolution (which is in the range of milliseconds).
 <p>
  WARNING: Be aware that throttle is using scheduler to slow down the stream. This scheduler has minimal time of triggering
  next push. Consequently it will slow down the stream as it has minimal pause for emitting. This can happen in
  case burst is 0 and speed is higher than 30 events per second. You need to increase the <code>maximumBurst</code>  if
  elements arrive with small interval (30 milliseconds or less). Use the overloaded <code>throttle</code> method without
  <code>maximumBurst</code> parameter to automatically calculate the <code>maximumBurst</code> based on the given rate (<code>cost/per</code>).
  In other words the throttler always enforces the rate limit when <code>maximumBurst</code> parameter is given, but in
  certain cases (mostly due to limited scheduler resolution) it enforces a tighter bound than what was prescribed.
 <p>
 '''Emits when''' upstream emits an element and configured time per each element elapsed
 <p>
 '''Backpressures when''' downstream backpressures or the incoming rate is higher than the speed limit
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="throttle(int,java.time.Duration,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttle</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttle&#8203;(int&nbsp;cost,
                                      java.time.Duration&nbsp;per,
                                      <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Integer&gt;&nbsp;costCalculation)</pre>
<div class="block">Sends elements downstream with speed limited to <code>cost/per</code>. Cost is
 calculating for each element individually by calling <code>calculateCost</code> function.
 This operator works for streams when elements have different cost(length).
 Streams of <code>ByteString</code> for example.
 <p>
 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size).
 Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
 to allow some burstiness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as element costs. If there isn't any, throttle waits until the
 bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
 to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and
 started.
 <p>
 The burst size is calculated based on the given rate (<code>cost/per</code>) as 0.1 * rate, for example:
 - rate < 20/second =&gt; burst size 1
 - rate 20/second =&gt; burst size 2
 - rate 100/second =&gt; burst size 10
 - rate 200/second =&gt; burst size 20
 <p>
 The throttle <code>mode</code> is <code>pekko.stream.ThrottleMode.Shaping</code>, which makes pauses before emitting messages to
 meet throttle rate.
 <p>
 '''Emits when''' upstream emits an element and configured time per each element elapsed
 <p>
 '''Backpressures when''' downstream backpressures or the incoming rate is higher than the speed limit
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="throttle(int,scala.concurrent.duration.FiniteDuration,int,org.apache.pekko.japi.function.Function,org.apache.pekko.stream.ThrottleMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttle</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttle&#8203;(int&nbsp;cost,
                                      scala.concurrent.duration.FiniteDuration&nbsp;per,
                                      int&nbsp;maximumBurst,
                                      <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Integer&gt;&nbsp;costCalculation,
                                      <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Sends elements downstream with speed limited to <code>cost/per</code>. Cost is
 calculating for each element individually by calling <code>calculateCost</code> function.
 This operator works for streams when elements have different cost(length).
 Streams of <code>ByteString</code> for example.
 <p>
 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
 to allow some burstiness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as element costs. If there isn't any, throttle waits until the
 bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
 to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and started.
 <p>
 Parameter <code>mode</code> manages behavior when upstream is faster than throttle rate:
  - <code>pekko.stream.ThrottleMode.Shaping</code> makes pauses before emitting messages to meet throttle rate
  - <code>pekko.stream.ThrottleMode.Enforcing</code> fails with exception when upstream is faster than throttle rate. Enforcing
  cannot emit elements that cost more than the maximumBurst
 <p>
 It is recommended to use non-zero burst sizes as they improve both performance and throttling precision by allowing
 the implementation to avoid using the scheduler when input rates fall below the enforced limit and to reduce
 most of the inaccuracy caused by the scheduler resolution (which is in the range of milliseconds).
 <p>
  WARNING: Be aware that throttle is using scheduler to slow down the stream. This scheduler has minimal time of triggering
  next push. Consequently it will slow down the stream as it has minimal pause for emitting. This can happen in
  case burst is 0 and speed is higher than 30 events per second. You need to increase the <code>maximumBurst</code>  if
  elements arrive with small interval (30 milliseconds or less). Use the overloaded <code>throttle</code> method without
  <code>maximumBurst</code> parameter to automatically calculate the <code>maximumBurst</code> based on the given rate (<code>cost/per</code>).
  In other words the throttler always enforces the rate limit when <code>maximumBurst</code> parameter is given, but in
  certain cases (mostly due to limited scheduler resolution) it enforces a tighter bound than what was prescribed.
 <p>
 '''Emits when''' upstream emits an element and configured time per each element elapsed
 <p>
 '''Backpressures when''' downstream backpressures or the incoming rate is higher than the speed limit
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="throttle(int,java.time.Duration,int,org.apache.pekko.japi.function.Function,org.apache.pekko.stream.ThrottleMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttle</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttle&#8203;(int&nbsp;cost,
                                      java.time.Duration&nbsp;per,
                                      int&nbsp;maximumBurst,
                                      <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Integer&gt;&nbsp;costCalculation,
                                      <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</pre>
<div class="block">Sends elements downstream with speed limited to <code>cost/per</code>. Cost is
 calculating for each element individually by calling <code>calculateCost</code> function.
 This operator works for streams when elements have different cost(length).
 Streams of <code>ByteString</code> for example.
 <p>
 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
 to allow some burstiness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as element costs. If there isn't any, throttle waits until the
 bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
 to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and started.
 <p>
 Parameter <code>mode</code> manages behavior when upstream is faster than throttle rate:
  - <code>pekko.stream.ThrottleMode.Shaping</code> makes pauses before emitting messages to meet throttle rate
  - <code>pekko.stream.ThrottleMode.Enforcing</code> fails with exception when upstream is faster than throttle rate. Enforcing
  cannot emit elements that cost more than the maximumBurst
 <p>
 It is recommended to use non-zero burst sizes as they improve both performance and throttling precision by allowing
 the implementation to avoid using the scheduler when input rates fall below the enforced limit and to reduce
 most of the inaccuracy caused by the scheduler resolution (which is in the range of milliseconds).
 <p>
  WARNING: Be aware that throttle is using scheduler to slow down the stream. This scheduler has minimal time of triggering
  next push. Consequently it will slow down the stream as it has minimal pause for emitting. This can happen in
  case burst is 0 and speed is higher than 30 events per second. You need to increase the <code>maximumBurst</code>  if
  elements arrive with small interval (30 milliseconds or less). Use the overloaded <code>throttle</code> method without
  <code>maximumBurst</code> parameter to automatically calculate the <code>maximumBurst</code> based on the given rate (<code>cost/per</code>).
  In other words the throttler always enforces the rate limit when <code>maximumBurst</code> parameter is given, but in
  certain cases (mostly due to limited scheduler resolution) it enforces a tighter bound than what was prescribed.
 <p>
 '''Emits when''' upstream emits an element and configured time per each element elapsed
 <p>
 '''Backpressures when''' downstream backpressures or the incoming rate is higher than the speed limit
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="throttleEven(int,scala.concurrent.duration.FiniteDuration,org.apache.pekko.stream.ThrottleMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttleEven</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttleEven&#8203;(int&nbsp;elements,
                                          scala.concurrent.duration.FiniteDuration&nbsp;per,
                                          <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use throttle without `maximumBurst` parameter instead. Since 2.5.12.</div>
</div>
<div class="block">This is a simplified version of throttle that spreads events evenly across the given time interval.
 <p>
 Use this operator when you need just slow down a stream without worrying about exact amount
 of time between events.
 <p>
 If you want to be sure that no time interval has no more than specified number of events you need to use
 <a href="#throttle(int,java.time.Duration)"><code>throttle(int,java.time.Duration)</code></a> with maximumBurst attribute.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#throttle(int,java.time.Duration)"><code>throttle(int, java.time.Duration)</code></a></dd>
</dl>
</li>
</ul>
<a id="throttleEven(int,java.time.Duration,org.apache.pekko.stream.ThrottleMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttleEven</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttleEven&#8203;(int&nbsp;elements,
                                          java.time.Duration&nbsp;per,
                                          <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use throttle without `maximumBurst` parameter instead. Since 2.5.12.</div>
</div>
<div class="block">This is a simplified version of throttle that spreads events evenly across the given time interval.
 <p>
 Use this operator when you need just slow down a stream without worrying about exact amount
 of time between events.
 <p>
 If you want to be sure that no time interval has no more than specified number of events you need to use
 <a href="#throttle(int,java.time.Duration)"><code>throttle(int,java.time.Duration)</code></a> with maximumBurst attribute.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#throttle(int,java.time.Duration)"><code>throttle(int, java.time.Duration)</code></a></dd>
</dl>
</li>
</ul>
<a id="throttleEven(int,scala.concurrent.duration.FiniteDuration,scala.Function1,org.apache.pekko.stream.ThrottleMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttleEven</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttleEven&#8203;(int&nbsp;cost,
                                          scala.concurrent.duration.FiniteDuration&nbsp;per,
                                          scala.Function1&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;costCalculation,
                                          <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use throttle without `maximumBurst` parameter instead. Since 2.5.12.</div>
</div>
<div class="block">This is a simplified version of throttle that spreads events evenly across the given time interval.
 <p>
 Use this operator when you need just slow down a stream without worrying about exact amount
 of time between events.
 <p>
 If you want to be sure that no time interval has no more than specified number of events you need to use
 <a href="#throttle(int,java.time.Duration)"><code>throttle(int,java.time.Duration)</code></a> with maximumBurst attribute.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#throttle(int,java.time.Duration)"><code>throttle(int, java.time.Duration)</code></a></dd>
</dl>
</li>
</ul>
<a id="throttleEven(int,java.time.Duration,scala.Function1,org.apache.pekko.stream.ThrottleMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>throttleEven</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;throttleEven&#8203;(int&nbsp;cost,
                                          java.time.Duration&nbsp;per,
                                          scala.Function1&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;costCalculation,
                                          <a href="../ThrottleMode.html" title="class in org.apache.pekko.stream">ThrottleMode</a>&nbsp;mode)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use throttle without `maximumBurst` parameter instead. Since 2.5.12.</div>
</div>
<div class="block">This is a simplified version of throttle that spreads events evenly across the given time interval.
 <p>
 Use this operator when you need just slow down a stream without worrying about exact amount
 of time between events.
 <p>
 If you want to be sure that no time interval has no more than specified number of events you need to use
 <a href="#throttle(int,java.time.Duration)"><code>throttle(int,java.time.Duration)</code></a> with maximumBurst attribute.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#throttle(int,java.time.Duration)"><code>throttle(int, java.time.Duration)</code></a></dd>
</dl>
</li>
</ul>
<a id="detach()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>detach</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;detach()</pre>
<div class="block">Detaches upstream demand from downstream demand without detaching the
 stream rates; in other words acts like a buffer of size 1.
 <p>
 '''Emits when''' upstream emits an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="watchTermination(org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>watchTermination</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M&gt;&nbsp;watchTermination&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;java.util.concurrent.CompletionStage&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;,&#8203;M&gt;&nbsp;matF)</pre>
<div class="block">Materializes to <code>Future[Done]</code> that completes on getting termination message.
 The Future completes with success when received complete message from upstream or cancel
 from downstream. It fails with the same error when received error message from
 downstream.</div>
</li>
</ul>
<a id="monitor(org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monitor</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M&gt;&nbsp;monitor&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;combine)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use monitor() or monitorMat(combine) instead. Since 2.5.17.</div>
</div>
<div class="block">Materializes to <code>FlowMonitor<Out></code> that allows monitoring of the current flow. All events are propagated
 by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
 event, and may therefor affect performance.
 The <code>combine</code> function is used to combine the <code>FlowMonitor</code> with this flow's materialized value.</div>
</li>
</ul>
<a id="monitorMat(org.apache.pekko.japi.function.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monitorMat</h4>
<pre class="methodSignature">public&nbsp;&lt;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;M&gt;&nbsp;monitorMat&#8203;(<a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;,&#8203;M&gt;&nbsp;combine)</pre>
<div class="block">Materializes to <code>FlowMonitor[Out]</code> that allows monitoring of the current flow. All events are propagated
 by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
 event, and may therefor affect performance.
 The <code>combine</code> function is used to combine the <code>FlowMonitor</code> with this flow's materialized value.</div>
</li>
</ul>
<a id="monitor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monitor</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;<a href="Source.html" title="type parameter in Source">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>&gt;&gt;&gt;&nbsp;monitor()</pre>
<div class="block">Materializes to <code>Pair<Mat, FlowMonitor<<Out>></code>, which is unlike most other operators (!),
 in which usually the default materialized value keeping semantics is to keep the left value
 (by passing <code>Keep.left()</code> to a <code>*Mat</code> version of a method). This operator is an exception from
 that rule and keeps both values since dropping its sole purpose is to introduce that materialized value.
 <p>
 The <code>FlowMonitor</code> allows monitoring of the current flow. All events are propagated
 by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
 event, and may therefor affect performance.</div>
</li>
</ul>
<a id="initialDelay(scala.concurrent.duration.FiniteDuration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initialDelay</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;initialDelay&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use the overloaded one which accepts java.time.Duration instead. Since 2.5.12.</div>
</div>
<div class="block">Delays the initial element by the specified duration.
 <p>
 '''Emits when''' upstream emits an element if the initial delay is already elapsed
 <p>
 '''Backpressures when''' downstream backpressures or initial delay is not yet elapsed
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="initialDelay(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initialDelay</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;initialDelay&#8203;(java.time.Duration&nbsp;delay)</pre>
<div class="block">Delays the initial element by the specified duration.
 <p>
 '''Emits when''' upstream emits an element if the initial delay is already elapsed
 <p>
 '''Backpressures when''' downstream backpressures or initial delay is not yet elapsed
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="withAttributes(org.apache.pekko.stream.Attributes)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withAttributes</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;withAttributes&#8203;(<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>&nbsp;attr)</pre>
<div class="block">Replace the attributes of this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a> with the given ones. If this Source is a composite
 of multiple graphs, new attributes on the composite will be less specific than attributes
 set directly on the individual graphs of the composite.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../Graph.html#withAttributes(org.apache.pekko.stream.Attributes)">withAttributes</a></code>&nbsp;in interface&nbsp;<code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="addAttributes(org.apache.pekko.stream.Attributes)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addAttributes</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;addAttributes&#8203;(<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>&nbsp;attr)</pre>
<div class="block">Add the given attributes to this <a href="Source.html" title="class in org.apache.pekko.stream.javadsl"><code>Source</code></a>. If the specific attribute was already present
 on this graph this means the added attribute will be more specific than the existing one.
 If this Source is a composite of multiple graphs, new attributes on the composite will be
 less specific than attributes set directly on the individual graphs of the composite.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../Graph.html#addAttributes(org.apache.pekko.stream.Attributes)">addAttributes</a></code>&nbsp;in interface&nbsp;<code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="named(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>named</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;named&#8203;(java.lang.String&nbsp;name)</pre>
<div class="block">Add a <code></code>name<code></code> attribute to this Source.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../Graph.html#named(java.lang.String)">named</a></code>&nbsp;in interface&nbsp;<code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="async()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>async</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;async()</pre>
<div class="block">Put an asynchronous boundary around this <code>Source</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../Graph.html#async()">async</a></code>&nbsp;in interface&nbsp;<code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="async(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>async</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;async&#8203;(java.lang.String&nbsp;dispatcher)</pre>
<div class="block">Put an asynchronous boundary around this <code>Source</code>
 <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../Graph.html#async(java.lang.String)">async</a></code>&nbsp;in interface&nbsp;<code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dispatcher</code> - Run the graph on this dispatcher</dd>
</dl>
</li>
</ul>
<a id="async(java.lang.String,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>async</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;async&#8203;(java.lang.String&nbsp;dispatcher,
                                   int&nbsp;inputBufferSize)</pre>
<div class="block">Put an asynchronous boundary around this <code>Source</code>
 <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../Graph.html#async(java.lang.String,int)">async</a></code>&nbsp;in interface&nbsp;<code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dispatcher</code> - Run the graph on this dispatcher</dd>
<dd><code>inputBufferSize</code> - Set the input buffer to this size for the graph</dd>
</dl>
</li>
</ul>
<a id="log(java.lang.String,org.apache.pekko.japi.function.Function,org.apache.pekko.event.LoggingAdapter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;log&#8203;(java.lang.String&nbsp;name,
                                 <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;extract,
                                 <a href="../../event/LoggingAdapter.html" title="interface in org.apache.pekko.event">LoggingAdapter</a>&nbsp;log)</pre>
<div class="block">Logs elements flowing through the stream as well as completion and erroring.
 <p>
 By default element and completion signals are logged on debug level, and errors are logged on Error level.
 This can be adjusted according to your needs by providing a custom <code>Attributes.LogLevels</code> attribute on the given Flow:
 <p>
 The <code>extract</code> function will be applied to each element before logging, so it is possible to log only those fields
 of a complex object flowing through this element.
 <p>
 Uses the given <code>LoggingAdapter</code> for logging.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the mapping function returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="log(java.lang.String,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;log&#8203;(java.lang.String&nbsp;name,
                                 <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;extract)</pre>
<div class="block">Logs elements flowing through the stream as well as completion and erroring.
 <p>
 By default element and completion signals are logged on debug level, and errors are logged on Error level.
 This can be adjusted according to your needs by providing a custom <code>Attributes.LogLevels</code> attribute on the given Flow:
 <p>
 The <code>extract</code> function will be applied to each element before logging, so it is possible to log only those fields
 of a complex object flowing through this element.
 <p>
 Uses an internally created <code>LoggingAdapter</code> which uses <code>org.apache.pekko.stream.Log</code> as it's source (use this class to configure slf4j loggers).
 <p>
 '''Emits when''' the mapping function returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="log(java.lang.String,org.apache.pekko.event.LoggingAdapter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;log&#8203;(java.lang.String&nbsp;name,
                                 <a href="../../event/LoggingAdapter.html" title="interface in org.apache.pekko.event">LoggingAdapter</a>&nbsp;log)</pre>
<div class="block">Logs elements flowing through the stream as well as completion and erroring.
 <p>
 By default element and completion signals are logged on debug level, and errors are logged on Error level.
 This can be adjusted according to your needs by providing a custom <code>Attributes.LogLevels</code> attribute on the given Flow:
 <p>
 Uses the given <code>LoggingAdapter</code> for logging.
 <p>
 '''Emits when''' the mapping function returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="log(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;log&#8203;(java.lang.String&nbsp;name)</pre>
<div class="block">Logs elements flowing through the stream as well as completion and erroring.
 <p>
 By default element and completion signals are logged on debug level, and errors are logged on Error level.
 This can be adjusted according to your needs by providing a custom <code>Attributes.LogLevels</code> attribute on the given Flow:
 <p>
 Uses an internally created <code>LoggingAdapter</code> which uses <code>org.apache.pekko.stream.Log</code> as it's source (use this class to configure slf4j loggers).
 <p>
 '''Emits when''' the mapping function returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="logWithMarker(java.lang.String,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function,org.apache.pekko.event.MarkerLoggingAdapter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>logWithMarker</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;logWithMarker&#8203;(java.lang.String&nbsp;name,
                                           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../event/LogMarker.html" title="class in org.apache.pekko.event">LogMarker</a>&gt;&nbsp;marker,
                                           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;extract,
                                           <a href="../../event/MarkerLoggingAdapter.html" title="class in org.apache.pekko.event">MarkerLoggingAdapter</a>&nbsp;log)</pre>
<div class="block">Logs elements flowing through the stream as well as completion and erroring.
 <p>
 By default element and completion signals are logged on debug level, and errors are logged on Error level.
 This can be adjusted according to your needs by providing a custom <code>Attributes.LogLevels</code> attribute on the given Flow:
 <p>
 The <code>extract</code> function will be applied to each element before logging, so it is possible to log only those fields
 of a complex object flowing through this element.
 <p>
 Uses the given <code>MarkerLoggingAdapter</code> for logging.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p>
 '''Emits when''' the mapping function returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="logWithMarker(java.lang.String,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>logWithMarker</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;logWithMarker&#8203;(java.lang.String&nbsp;name,
                                           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../event/LogMarker.html" title="class in org.apache.pekko.event">LogMarker</a>&gt;&nbsp;marker,
                                           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;java.lang.Object&gt;&nbsp;extract)</pre>
<div class="block">Logs elements flowing through the stream as well as completion and erroring.
 <p>
 By default element and completion signals are logged on debug level, and errors are logged on Error level.
 This can be adjusted according to your needs by providing a custom <code>Attributes.LogLevels</code> attribute on the given Flow:
 <p>
 The <code>extract</code> function will be applied to each element before logging, so it is possible to log only those fields
 of a complex object flowing through this element.
 <p>
 Uses an internally created <code>MarkerLoggingAdapter</code> which uses <code>org.apache.pekko.stream.Log</code> as it's source (use this class to configure slf4j loggers).
 <p>
 '''Emits when''' the mapping function returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="logWithMarker(java.lang.String,org.apache.pekko.japi.function.Function,org.apache.pekko.event.MarkerLoggingAdapter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>logWithMarker</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;logWithMarker&#8203;(java.lang.String&nbsp;name,
                                           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../event/LogMarker.html" title="class in org.apache.pekko.event">LogMarker</a>&gt;&nbsp;marker,
                                           <a href="../../event/MarkerLoggingAdapter.html" title="class in org.apache.pekko.event">MarkerLoggingAdapter</a>&nbsp;log)</pre>
<div class="block">Logs elements flowing through the stream as well as completion and erroring.
 <p>
 By default element and completion signals are logged on debug level, and errors are logged on Error level.
 This can be adjusted according to your needs by providing a custom <code>Attributes.LogLevels</code> attribute on the given Flow:
 <p>
 Uses the given <code>MarkerLoggingAdapter</code> for logging.
 <p>
 '''Emits when''' the mapping function returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="logWithMarker(java.lang.String,org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>logWithMarker</h4>
<pre class="methodSignature">public&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;logWithMarker&#8203;(java.lang.String&nbsp;name,
                                           <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../event/LogMarker.html" title="class in org.apache.pekko.event">LogMarker</a>&gt;&nbsp;marker)</pre>
<div class="block">Logs elements flowing through the stream as well as completion and erroring.
 <p>
 By default element and completion signals are logged on debug level, and errors are logged on Error level.
 This can be adjusted according to your needs by providing a custom <code>Attributes.LogLevels</code> attribute on the given Flow:
 <p>
 Uses an internally created <code>MarkerLoggingAdapter</code> which uses <code>org.apache.pekko.stream.Log</code> as it's source (use this class to configure slf4j loggers).
 <p>
 '''Emits when''' the mapping function returns an element
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' upstream completes
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
<a id="asSourceWithContext(org.apache.pekko.japi.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asSourceWithContext</h4>
<pre class="methodSignature">public&nbsp;&lt;Ctx&gt;&nbsp;<a href="SourceWithContext.html" title="class in org.apache.pekko.stream.javadsl">SourceWithContext</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Ctx,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;asSourceWithContext&#8203;(<a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;Ctx&gt;&nbsp;extractContext)</pre>
<div class="block">Transform this source whose element is <code></code>e<code></code> into a source producing tuple <code></code>(e, f(e))<code></code></div>
</li>
</ul>
<a id="aggregateWithBoundary(java.util.function.Supplier,org.apache.pekko.japi.function.Function2,org.apache.pekko.japi.function.Function,org.apache.pekko.japi.Pair)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregateWithBoundary</h4>
<pre class="methodSignature">public&nbsp;&lt;Agg,&#8203;Emit&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.javadsl">Source</a>&lt;Emit,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;&nbsp;aggregateWithBoundary&#8203;(java.util.function.Supplier&lt;Agg&gt;&nbsp;allocate,
                                                                     <a href="../../japi/function/Function2.html" title="interface in org.apache.pekko.japi.function">Function2</a>&lt;Agg,&#8203;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;Agg,&#8203;java.lang.Object&gt;&gt;&nbsp;aggregate,
                                                                     <a href="../../japi/function/Function.html" title="interface in org.apache.pekko.japi.function">Function</a>&lt;Agg,&#8203;Emit&gt;&nbsp;harvest,
                                                                     <a href="../../japi/Pair.html" title="class in org.apache.pekko.japi">Pair</a>&lt;java.util.function.Predicate&lt;Agg&gt;,&#8203;java.time.Duration&gt;&nbsp;emitOnTimer)</pre>
<div class="block">Aggregate input elements into an arbitrary data structure that can be completed and emitted downstream
 when custom condition is met which can be triggered by aggregate or timer.
 It can be thought of a more general <a href="#groupedWeightedWithin(long,org.apache.pekko.japi.function.Function,scala.concurrent.duration.FiniteDuration)"><code>groupedWeightedWithin(long,org.apache.pekko.japi.function.Function&lt;Out,java.lang.Long&gt;,scala.concurrent.duration.FiniteDuration)</code></a>.
 <p>
 '''Emits when''' the aggregation function decides the aggregate is complete or the timer function returns true
 <p>
 '''Backpressures when''' downstream backpressures and the aggregate is complete
 <p>
 '''Completes when''' upstream completes and the last aggregate has been emitted downstream
 <p>
 '''Cancels when''' downstream cancels
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocate</code> - allocate the initial data structure for aggregated elements</dd>
<dd><code>aggregate</code> - update the aggregated elements, return true if ready to emit after update.</dd>
<dd><code>harvest</code> - this is invoked before emit within the current stage/operator</dd>
<dd><code>emitOnTimer</code> - decide whether the current aggregated elements can be emitted, the custom function is invoked on every interval</dd>
</dl>
</li>
</ul>
<a id="getAttributes()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getAttributes</h4>
<pre class="methodSignature">public&nbsp;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>&nbsp;getAttributes()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../Graph.html#getAttributes()">getAttributes</a></code>&nbsp;in interface&nbsp;<code><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="Source.html" title="type parameter in Source">Out</a>,&#8203;<a href="Source.html" title="type parameter in Source">Mat</a>&gt;</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
