<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.17) on Mon Jan 23 00:00:27 GMT 2023 -->
<title>Scheduler</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-01-23">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Scheduler";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":38,"i2":38,"i3":38,"i4":38,"i5":38,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.pekko.actor</a></div>
<h2 title="Interface Scheduler" class="title">Interface Scheduler</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="AbstractScheduler.html" title="class in org.apache.pekko.actor">AbstractScheduler</a></code>, <code><a href="AbstractSchedulerBase.html" title="class in org.apache.pekko.actor">AbstractSchedulerBase</a></code>, <code><a href="../testkit/ExplicitlyTriggeredScheduler.html" title="class in org.apache.pekko.testkit">ExplicitlyTriggeredScheduler</a></code>, <code><a href="LightArrayRevolverScheduler.html" title="class in org.apache.pekko.actor">LightArrayRevolverScheduler</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">Scheduler</span></pre>
<div class="block">An Akka scheduler service.
 <p>
 For scheduling within actors <code>with Timers</code> should be preferred.
 <p>
 Please note that this scheduler implementation is highly optimised for high-throughput
 and high-frequency events. It is not to be confused with long-term schedulers such as
 Quartz. The scheduler will throw an exception if attempts are made to schedule too far
 into the future (which by default is around 8 months (<code>Int.MaxValue</code> seconds).
 <p>
 It's possible to implement a custom <code>Scheduler</code>, although that should rarely be needed.
 <p>
 A <code>Scheduler</code> implementation needs one special behavior: if
 Closeable, it MUST execute all outstanding tasks that implement <a href="Scheduler.TaskRunOnClose.html" title="interface in org.apache.pekko.actor"><code>Scheduler.TaskRunOnClose</code></a>
 upon .close() in order to properly shutdown all dispatchers.
 <p>
 Furthermore, this timer service MUST throw IllegalStateException if it
 cannot schedule a task. Once scheduled, the task MUST be executed. If
 executed upon close(), the task may execute before its timeout.
 <p>
 Scheduler implementation are loaded reflectively at ActorSystem start-up
 with the following constructor arguments:
  1) the system&amp;rsquo;s com.typesafe.config.Config (from system.settings.config)
  2) a org.apache.pekko.event.LoggingAdapter
  3) a java.util.concurrent.ThreadFactory</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Scheduler.TaskRunOnClose.html" title="interface in org.apache.pekko.actor">Scheduler.TaskRunOnClose</a></span></code></th>
<td class="colLast">
<div class="block">If a <code>TaskRunOnClose</code> is used in <code>scheduleOnce</code> it will be run when the <code>Scheduler</code> is
 closed (<code>ActorSystem</code> shutdown).</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#maxFrequency()">maxFrequency</a></span>()</code></th>
<td class="colLast">
<div class="block">The maximum supported task frequency of this scheduler, i.e.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#schedule(java.time.Duration,java.time.Duration,java.lang.Runnable,scala.concurrent.ExecutionContext)">schedule</a></span>&#8203;(java.time.Duration&nbsp;initialDelay,
        java.time.Duration&nbsp;interval,
        java.lang.Runnable&nbsp;runnable,
        scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead.</div>
</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#schedule(java.time.Duration,java.time.Duration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">schedule</a></span>&#8203;(java.time.Duration&nbsp;initialDelay,
        java.time.Duration&nbsp;interval,
        <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
        java.lang.Object&nbsp;message,
        scala.concurrent.ExecutionContext&nbsp;executor,
        <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead.</div>
</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#schedule(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)">schedule</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
        scala.concurrent.duration.FiniteDuration&nbsp;interval,
        java.lang.Runnable&nbsp;runnable,
        scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead.</div>
</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#schedule(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">schedule</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
        scala.concurrent.duration.FiniteDuration&nbsp;interval,
        <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
        java.lang.Object&nbsp;message,
        scala.concurrent.ExecutionContext&nbsp;executor,
        <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead.</div>
</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#schedule(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,scala.Function0,scala.concurrent.ExecutionContext)">schedule</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
        scala.concurrent.duration.FiniteDuration&nbsp;interval,
        scala.Function0&lt;scala.runtime.BoxedUnit&gt;&nbsp;f,
        scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead.</div>
</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#schedule$default$6(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object)">schedule$default$6</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                  scala.concurrent.duration.FiniteDuration&nbsp;interval,
                  <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                  java.lang.Object&nbsp;message)</code></th>
<td class="colLast">
<div class="block">Deprecated API: See <a href="#scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a> or <a href="#scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleAtFixedRate(java.time.Duration,java.time.Duration,java.lang.Runnable,scala.concurrent.ExecutionContext)">scheduleAtFixedRate</a></span>&#8203;(java.time.Duration&nbsp;initialDelay,
                   java.time.Duration&nbsp;interval,
                   java.lang.Runnable&nbsp;runnable,
                   scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Java API: Schedules a <code>Runnable</code> to be run repeatedly with an initial delay and
 a frequency.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleAtFixedRate(java.time.Duration,java.time.Duration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">scheduleAtFixedRate</a></span>&#8203;(java.time.Duration&nbsp;initialDelay,
                   java.time.Duration&nbsp;interval,
                   <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                   java.lang.Object&nbsp;message,
                   scala.concurrent.ExecutionContext&nbsp;executor,
                   <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</code></th>
<td class="colLast">
<div class="block">Java API: Schedules a message to be sent repeatedly with an initial delay and
 frequency.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)">scheduleAtFixedRate</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                   scala.concurrent.duration.FiniteDuration&nbsp;interval,
                   java.lang.Runnable&nbsp;runnable,
                   scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Scala API: Schedules a <code>Runnable</code> to be run repeatedly with an initial delay and
 a frequency.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">scheduleAtFixedRate</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                   scala.concurrent.duration.FiniteDuration&nbsp;interval,
                   <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                   java.lang.Object&nbsp;message,
                   scala.concurrent.ExecutionContext&nbsp;executor,
                   <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</code></th>
<td class="colLast">
<div class="block">Scala API: Schedules a message to be sent repeatedly with an initial delay and
 frequency.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleAtFixedRate$default$6(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object)">scheduleAtFixedRate$default$6</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                             scala.concurrent.duration.FiniteDuration&nbsp;interval,
                             <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                             java.lang.Object&nbsp;message)</code></th>
<td class="colLast">
<div class="block">Scala API: Schedules a message to be sent repeatedly with an initial delay and
 frequency.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleOnce(java.time.Duration,java.lang.Runnable,scala.concurrent.ExecutionContext)">scheduleOnce</a></span>&#8203;(java.time.Duration&nbsp;delay,
            java.lang.Runnable&nbsp;runnable,
            scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Java API: Schedules a Runnable to be run once with a delay, i.e.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleOnce(java.time.Duration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">scheduleOnce</a></span>&#8203;(java.time.Duration&nbsp;delay,
            <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
            java.lang.Object&nbsp;message,
            scala.concurrent.ExecutionContext&nbsp;executor,
            <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</code></th>
<td class="colLast">
<div class="block">Java API: Schedules a message to be sent once with a delay, i.e.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleOnce(scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)">scheduleOnce</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay,
            java.lang.Runnable&nbsp;runnable,
            scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Scala API: Schedules a Runnable to be run once with a delay, i.e.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleOnce(scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">scheduleOnce</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay,
            <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
            java.lang.Object&nbsp;message,
            scala.concurrent.ExecutionContext&nbsp;executor,
            <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</code></th>
<td class="colLast">
<div class="block">Scala API: Schedules a message to be sent once with a delay, i.e.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleOnce(scala.concurrent.duration.FiniteDuration,scala.Function0,scala.concurrent.ExecutionContext)">scheduleOnce</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay,
            scala.Function0&lt;scala.runtime.BoxedUnit&gt;&nbsp;f,
            scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Scala API: Schedules a function to be run once with a delay, i.e.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleOnce$default$5(scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object)">scheduleOnce$default$5</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay,
                      <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                      java.lang.Object&nbsp;message)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWithFixedDelay(java.time.Duration,java.time.Duration,java.lang.Runnable,scala.concurrent.ExecutionContext)">scheduleWithFixedDelay</a></span>&#8203;(java.time.Duration&nbsp;initialDelay,
                      java.time.Duration&nbsp;delay,
                      java.lang.Runnable&nbsp;runnable,
                      scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Java API: Schedules a <code>Runnable</code> to be run repeatedly with an initial delay and
 a fixed <code>delay</code> between subsequent executions.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWithFixedDelay(java.time.Duration,java.time.Duration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">scheduleWithFixedDelay</a></span>&#8203;(java.time.Duration&nbsp;initialDelay,
                      java.time.Duration&nbsp;delay,
                      <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                      java.lang.Object&nbsp;message,
                      scala.concurrent.ExecutionContext&nbsp;executor,
                      <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</code></th>
<td class="colLast">
<div class="block">Java API: Schedules a message to be sent repeatedly with an initial delay and
 a fixed <code>delay</code> between messages.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)">scheduleWithFixedDelay</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                      scala.concurrent.duration.FiniteDuration&nbsp;delay,
                      java.lang.Runnable&nbsp;runnable,
                      scala.concurrent.ExecutionContext&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Scala API: Schedules a <code>Runnable</code> to be run repeatedly with an initial delay and
 a fixed <code>delay</code> between subsequent executions.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">scheduleWithFixedDelay</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                      scala.concurrent.duration.FiniteDuration&nbsp;delay,
                      <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                      java.lang.Object&nbsp;message,
                      scala.concurrent.ExecutionContext&nbsp;executor,
                      <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</code></th>
<td class="colLast">
<div class="block">Scala API: Schedules a message to be sent repeatedly with an initial delay and
 a fixed <code>delay</code> between messages.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code><a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWithFixedDelay$default$6(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object)">scheduleWithFixedDelay$default$6</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                                scala.concurrent.duration.FiniteDuration&nbsp;delay,
                                <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                                java.lang.Object&nbsp;message)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWithFixedDelay</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleWithFixedDelay&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                                   scala.concurrent.duration.FiniteDuration&nbsp;delay,
                                   java.lang.Runnable&nbsp;runnable,
                                   scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="block">Scala API: Schedules a <code>Runnable</code> to be run repeatedly with an initial delay and
 a fixed <code>delay</code> between subsequent executions. E.g. if you would like the function to
 be run after 2 seconds and thereafter every 100ms you would set <code>delay=Duration(2, TimeUnit.SECONDS)</code>
 and <code>interval=Duration(100, TimeUnit.MILLISECONDS)</code>.
 <p>
 It will not compensate the delay between tasks if the execution takes a long time or if
 scheduling is delayed longer than specified for some reason. The delay between subsequent
 execution will always be (at least) the given <code>delay</code>. In the long run, the
 frequency of execution will generally be slightly lower than the reciprocal of the specified
 <code>delay</code>.
 <p>
 If the <code>Runnable</code> throws an exception the repeated scheduling is aborted,
 i.e. the function will not be invoked any more.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the given delays exceed the maximum
 reach (calculated as: <code>delay / tickNanos > Int.MaxValue</code>).
 <p>
 Note: For scheduling within actors <code>with Timers</code> should be preferred.</dd>
</dl>
</li>
</ul>
<a id="scheduleWithFixedDelay(java.time.Duration,java.time.Duration,java.lang.Runnable,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWithFixedDelay</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleWithFixedDelay&#8203;(java.time.Duration&nbsp;initialDelay,
                                   java.time.Duration&nbsp;delay,
                                   java.lang.Runnable&nbsp;runnable,
                                   scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="block">Java API: Schedules a <code>Runnable</code> to be run repeatedly with an initial delay and
 a fixed <code>delay</code> between subsequent executions. E.g. if you would like the function to
 be run after 2 seconds and thereafter every 100ms you would set delay to <code>Duration.ofSeconds(2)</code>,
 and interval to <code>Duration.ofMillis(100)</code>.
 <p>
 It will not compensate the delay between tasks if the execution takes a long time or if
 scheduling is delayed longer than specified for some reason. The delay between subsequent
 execution will always be (at least) the given <code>delay</code>.
 <p>
 In the long run, the frequency of tasks will generally be slightly lower than
 the reciprocal of the specified <code>delay</code>.
 <p>
 If the <code>Runnable</code> throws an exception the repeated scheduling is aborted,
 i.e. the function will not be invoked any more.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the given delays exceed the maximum
 reach (calculated as: <code>delay / tickNanos > Int.MaxValue</code>).
 <p>
 Note: For scheduling within actors <code>AbstractActorWithTimers</code> should be preferred.</dd>
</dl>
</li>
</ul>
<a id="scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWithFixedDelay</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleWithFixedDelay&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                                   scala.concurrent.duration.FiniteDuration&nbsp;delay,
                                   <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                                   java.lang.Object&nbsp;message,
                                   scala.concurrent.ExecutionContext&nbsp;executor,
                                   <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</pre>
<div class="block">Scala API: Schedules a message to be sent repeatedly with an initial delay and
 a fixed <code>delay</code> between messages. E.g. if you would like a message to be sent
 immediately and thereafter every 500ms you would set <code>delay=Duration.Zero</code> and
 <code>interval=Duration(500, TimeUnit.MILLISECONDS)</code>.
 <p>
 It will not compensate the delay between messages if scheduling is delayed
 longer than specified for some reason. The delay between sending of subsequent
 messages will always be (at least) the given <code>delay</code>.
 <p>
 In the long run, the frequency of messages will generally be slightly lower than
 the reciprocal of the specified <code>delay</code>.
 <p>
 Note: For scheduling within actors <code>with Timers</code> should be preferred.</div>
</li>
</ul>
<a id="scheduleWithFixedDelay(java.time.Duration,java.time.Duration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWithFixedDelay</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleWithFixedDelay&#8203;(java.time.Duration&nbsp;initialDelay,
                                   java.time.Duration&nbsp;delay,
                                   <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                                   java.lang.Object&nbsp;message,
                                   scala.concurrent.ExecutionContext&nbsp;executor,
                                   <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</pre>
<div class="block">Java API: Schedules a message to be sent repeatedly with an initial delay and
 a fixed <code>delay</code> between messages. E.g. if you would like a message to be sent
 immediately and thereafter every 500ms you would set <code>delay=Duration.ZERO</code> and
 <code>interval=Duration.ofMillis(500)</code>.
 <p>
 It will not compensate the delay between messages if scheduling is delayed
 longer than specified for some reason. The delay between sending of subsequent
 messages will always be (at least) the given <code>delay</code>.
 <p>
 In the long run, the frequency of messages will generally be slightly lower than
 the reciprocal of the specified <code>delay</code>.
 <p>
 Note: For scheduling within actors <code>AbstractActorWithTimers</code> should be preferred.</div>
</li>
</ul>
<a id="scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleAtFixedRate</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleAtFixedRate&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                                scala.concurrent.duration.FiniteDuration&nbsp;interval,
                                java.lang.Runnable&nbsp;runnable,
                                scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="block">Scala API: Schedules a <code>Runnable</code> to be run repeatedly with an initial delay and
 a frequency. E.g. if you would like the function to be run after 2
 seconds and thereafter every 100ms you would set <code>delay=Duration(2, TimeUnit.SECONDS)</code>
 and <code>interval=Duration(100, TimeUnit.MILLISECONDS)</code>.
 <p>
 It will compensate the delay for a subsequent task if the previous tasks took
 too long to execute. In such cases, the actual execution interval will differ from
 the interval passed to the method.
 <p>
 If the execution of the tasks takes longer than the <code>interval</code>, the subsequent
 execution will start immediately after the prior one completes (there will be
 no overlap of executions). This also has the consequence that after long garbage
 collection pauses or other reasons when the JVM was suspended all "missed" tasks
 will execute when the process wakes up again.
 <p>
 In the long run, the frequency of execution will be exactly the reciprocal of the
 specified <code>interval</code>.
 <p>
 Warning: <code>scheduleAtFixedRate</code> can result in bursts of scheduled tasks after long
 garbage collection pauses, which may in worst case cause undesired load on the system.
 Therefore <code>scheduleWithFixedDelay</code> is often preferred.
 <p>
 If the <code>Runnable</code> throws an exception the repeated scheduling is aborted,
 i.e. the function will not be invoked any more.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the given delays exceed the maximum
 reach (calculated as: <code>delay / tickNanos > Int.MaxValue</code>).
 <p>
 Note: For scheduling within actors <code>with Timers</code> should be preferred.</dd>
</dl>
</li>
</ul>
<a id="scheduleAtFixedRate(java.time.Duration,java.time.Duration,java.lang.Runnable,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleAtFixedRate</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleAtFixedRate&#8203;(java.time.Duration&nbsp;initialDelay,
                                java.time.Duration&nbsp;interval,
                                java.lang.Runnable&nbsp;runnable,
                                scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="block">Java API: Schedules a <code>Runnable</code> to be run repeatedly with an initial delay and
 a frequency. E.g. if you would like the function to be run after 2
 seconds and thereafter every 100ms you would set delay to <code>Duration.ofSeconds(2)</code>,
 and interval to <code>Duration.ofMillis(100)</code>.
 <p>
 It will compensate the delay for a subsequent task if the previous tasks took
 too long to execute. In such cases, the actual execution interval will differ from
 the interval passed to the method.
 <p>
 If the execution of the tasks takes longer than the <code>interval</code>, the subsequent
 execution will start immediately after the prior one completes (there will be
 no overlap of executions). This also has the consequence that after long garbage
 collection pauses or other reasons when the JVM was suspended all "missed" tasks
 will execute when the process wakes up again.
 <p>
 In the long run, the frequency of execution will be exactly the reciprocal of the
 specified <code>interval</code>.
 <p>
 Warning: <code>scheduleAtFixedRate</code> can result in bursts of scheduled tasks after long
 garbage collection pauses, which may in worst case cause undesired load on the system.
 Therefore <code>scheduleWithFixedDelay</code> is often preferred.
 <p>
 If the <code>Runnable</code> throws an exception the repeated scheduling is aborted,
 i.e. the function will not be invoked any more.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the given delays exceed the maximum
 reach (calculated as: <code>delay / tickNanos > Int.MaxValue</code>).
 <p>
 Note: For scheduling within actors <code>AbstractActorWithTimers</code> should be preferred.</dd>
</dl>
</li>
</ul>
<a id="scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleAtFixedRate</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleAtFixedRate&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                                scala.concurrent.duration.FiniteDuration&nbsp;interval,
                                <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                                java.lang.Object&nbsp;message,
                                scala.concurrent.ExecutionContext&nbsp;executor,
                                <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</pre>
<div class="block">Scala API: Schedules a message to be sent repeatedly with an initial delay and
 frequency. E.g. if you would like a message to be sent immediately and
 thereafter every 500ms you would set <code>delay=Duration.Zero</code> and
 <code>interval=Duration(500, TimeUnit.MILLISECONDS)</code>
 <p>
 It will compensate the delay for a subsequent message if the sending of previous
 message was delayed more than specified. In such cases, the actual message interval
 will differ from the interval passed to the method.
 <p>
 If the execution is delayed longer than the <code>interval</code>, the subsequent message will
 be sent immediately after the prior one. This also has the consequence that after
 long garbage collection pauses or other reasons when the JVM was suspended all
 "missed" messages will be sent when the process wakes up again.
 <p>
 In the long run, the frequency of messages will be exactly the reciprocal of the
 specified <code>interval</code>.
 <p>
 Warning: <code>scheduleAtFixedRate</code> can result in bursts of scheduled messages after long
 garbage collection pauses, which may in worst case cause undesired load on the system.
 Therefore <code>scheduleWithFixedDelay</code> is often preferred.
 <p>
 Note: For scheduling within actors <code>with Timers</code> should be preferred.</div>
</li>
</ul>
<a id="scheduleAtFixedRate(java.time.Duration,java.time.Duration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleAtFixedRate</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleAtFixedRate&#8203;(java.time.Duration&nbsp;initialDelay,
                                java.time.Duration&nbsp;interval,
                                <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                                java.lang.Object&nbsp;message,
                                scala.concurrent.ExecutionContext&nbsp;executor,
                                <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</pre>
<div class="block">Java API: Schedules a message to be sent repeatedly with an initial delay and
 frequency. E.g. if you would like a message to be sent immediately and
 thereafter every 500ms you would set <code>delay=Duration.ZERO</code> and
 <code>interval=Duration.ofMillis(500)</code>
 <p>
 It will compensate the delay for a subsequent message if the sending of previous
 message was delayed more than specified. In such cases, the actual message interval
 will differ from the interval passed to the method.
 <p>
 If the execution is delayed longer than the <code>interval</code>, the subsequent message will
 be sent immediately after the prior one. This also has the consequence that after
 long garbage collection pauses or other reasons when the JVM was suspended all
 "missed" messages will be sent when the process wakes up again.
 <p>
 In the long run, the frequency of messages will be exactly the reciprocal of the
 specified <code>interval</code>.
 <p>
 Warning: <code>scheduleAtFixedRate</code> can result in bursts of scheduled messages after long
 garbage collection pauses, which may in worst case cause undesired load on the system.
 Therefore <code>scheduleWithFixedDelay</code> is often preferred.
 <p>
 Note: For scheduling within actors <code>AbstractActorWithTimers</code> should be preferred.</div>
</li>
</ul>
<a id="schedule(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>schedule</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;schedule&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                     scala.concurrent.duration.FiniteDuration&nbsp;interval,
                     <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                     java.lang.Object&nbsp;message,
                     scala.concurrent.ExecutionContext&nbsp;executor,
                     <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead. This has the same semantics as scheduleAtFixedRate, but scheduleWithFixedDelay is often preferred. Since 2.6.0.</div>
</div>
<div class="block">Deprecated API: See <a href="#scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a> or <a href="#scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a>.</div>
</li>
</ul>
<a id="schedule(java.time.Duration,java.time.Duration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>schedule</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;schedule&#8203;(java.time.Duration&nbsp;initialDelay,
                     java.time.Duration&nbsp;interval,
                     <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                     java.lang.Object&nbsp;message,
                     scala.concurrent.ExecutionContext&nbsp;executor,
                     <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead. This has the same semantics as scheduleAtFixedRate, but scheduleWithFixedDelay is often preferred. Since 2.6.0.</div>
</div>
<div class="block">Deprecated API: See <a href="#scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a> or <a href="#scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a>.</div>
</li>
</ul>
<a id="schedule(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,scala.Function0,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>schedule</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;schedule&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                     scala.concurrent.duration.FiniteDuration&nbsp;interval,
                     scala.Function0&lt;scala.runtime.BoxedUnit&gt;&nbsp;f,
                     scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead. This has the same semantics as scheduleAtFixedRate, but scheduleWithFixedDelay is often preferred. Since 2.6.0.</div>
</div>
<div class="block">Deprecated API: See <a href="#scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a> or <a href="#scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a>.</div>
</li>
</ul>
<a id="schedule(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>schedule</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;schedule&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                     scala.concurrent.duration.FiniteDuration&nbsp;interval,
                     java.lang.Runnable&nbsp;runnable,
                     scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead. This has the same semantics as scheduleAtFixedRate, but scheduleWithFixedDelay is often preferred. Since 2.6.0.</div>
</div>
<div class="block">Deprecated API: See <a href="#scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a> or <a href="#scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a>.</div>
</li>
</ul>
<a id="schedule(java.time.Duration,java.time.Duration,java.lang.Runnable,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>schedule</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;schedule&#8203;(java.time.Duration&nbsp;initialDelay,
                     java.time.Duration&nbsp;interval,
                     java.lang.Runnable&nbsp;runnable,
                     scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scheduleWithFixedDelay or scheduleAtFixedRate instead. This has the same semantics as scheduleAtFixedRate, but scheduleWithFixedDelay is often preferred. Since 2.6.0.</div>
</div>
<div class="block">Deprecated API: See <a href="#scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a> or <a href="#scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a>.</div>
</li>
</ul>
<a id="scheduleWithFixedDelay$default$6(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWithFixedDelay$default$6</h4>
<pre class="methodSignature"><a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;scheduleWithFixedDelay$default$6&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                                          scala.concurrent.duration.FiniteDuration&nbsp;delay,
                                          <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                                          java.lang.Object&nbsp;message)</pre>
</li>
</ul>
<a id="scheduleAtFixedRate$default$6(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleAtFixedRate$default$6</h4>
<pre class="methodSignature"><a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;scheduleAtFixedRate$default$6&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                                       scala.concurrent.duration.FiniteDuration&nbsp;interval,
                                       <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                                       java.lang.Object&nbsp;message)</pre>
<div class="block">Scala API: Schedules a message to be sent repeatedly with an initial delay and
 frequency. E.g. if you would like a message to be sent immediately and
 thereafter every 500ms you would set <code>delay=Duration.Zero</code> and
 <code>interval=Duration(500, TimeUnit.MILLISECONDS)</code>
 <p>
 It will compensate the delay for a subsequent message if the sending of previous
 message was delayed more than specified. In such cases, the actual message interval
 will differ from the interval passed to the method.
 <p>
 If the execution is delayed longer than the <code>interval</code>, the subsequent message will
 be sent immediately after the prior one. This also has the consequence that after
 long garbage collection pauses or other reasons when the JVM was suspended all
 "missed" messages will be sent when the process wakes up again.
 <p>
 In the long run, the frequency of messages will be exactly the reciprocal of the
 specified <code>interval</code>.
 <p>
 Warning: <code>scheduleAtFixedRate</code> can result in bursts of scheduled messages after long
 garbage collection pauses, which may in worst case cause undesired load on the system.
 Therefore <code>scheduleWithFixedDelay</code> is often preferred.
 <p>
 Note: For scheduling within actors <code>with Timers</code> should be preferred.</div>
</li>
</ul>
<a id="schedule$default$6(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>schedule$default$6</h4>
<pre class="methodSignature"><a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;schedule$default$6&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                            scala.concurrent.duration.FiniteDuration&nbsp;interval,
                            <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                            java.lang.Object&nbsp;message)</pre>
<div class="block">Deprecated API: See <a href="#scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleWithFixedDelay(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a> or <a href="#scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)"><code>scheduleAtFixedRate(scala.concurrent.duration.FiniteDuration, scala.concurrent.duration.FiniteDuration, java.lang.Runnable, scala.concurrent.ExecutionContext)</code></a>.</div>
</li>
</ul>
<a id="scheduleOnce(scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleOnce&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay,
                         <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                         java.lang.Object&nbsp;message,
                         scala.concurrent.ExecutionContext&nbsp;executor,
                         <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</pre>
<div class="block">Scala API: Schedules a message to be sent once with a delay, i.e. a time period that has
 to pass before the message is sent.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the given delays exceed the maximum
 reach (calculated as: <code>delay / tickNanos > Int.MaxValue</code>).
 <p>
 Note: For scheduling within actors <code>with Timers</code> should be preferred.</dd>
</dl>
</li>
</ul>
<a id="scheduleOnce(java.time.Duration,org.apache.pekko.actor.ActorRef,java.lang.Object,scala.concurrent.ExecutionContext,org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleOnce&#8203;(java.time.Duration&nbsp;delay,
                         <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                         java.lang.Object&nbsp;message,
                         scala.concurrent.ExecutionContext&nbsp;executor,
                         <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;sender)</pre>
<div class="block">Java API: Schedules a message to be sent once with a delay, i.e. a time period that has
 to pass before the message is sent.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the given delays exceed the maximum
 reach (calculated as: <code>delay / tickNanos > Int.MaxValue</code>).
 <p>
 Note: For scheduling within actors <code>AbstractActorWithTimers</code> should be preferred.</dd>
</dl>
</li>
</ul>
<a id="scheduleOnce(scala.concurrent.duration.FiniteDuration,scala.Function0,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleOnce&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay,
                         scala.Function0&lt;scala.runtime.BoxedUnit&gt;&nbsp;f,
                         scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="block">Scala API: Schedules a function to be run once with a delay, i.e. a time period that has
 to pass before the function is run.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the given delays exceed the maximum
 reach (calculated as: <code>delay / tickNanos > Int.MaxValue</code>).
 <p>
 Note: For scheduling within actors <code>with Timers</code> should be preferred.</dd>
</dl>
</li>
</ul>
<a id="scheduleOnce(scala.concurrent.duration.FiniteDuration,java.lang.Runnable,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleOnce&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay,
                         java.lang.Runnable&nbsp;runnable,
                         scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="block">Scala API: Schedules a Runnable to be run once with a delay, i.e. a time period that
 has to pass before the runnable is executed.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the given delays exceed the maximum
 reach (calculated as: <code>delay / tickNanos > Int.MaxValue</code>).
 <p>
 Note: For scheduling within actors <code>with Timers</code> should be preferred.</dd>
</dl>
</li>
</ul>
<a id="scheduleOnce(java.time.Duration,java.lang.Runnable,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre class="methodSignature"><a href="Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&nbsp;scheduleOnce&#8203;(java.time.Duration&nbsp;delay,
                         java.lang.Runnable&nbsp;runnable,
                         scala.concurrent.ExecutionContext&nbsp;executor)</pre>
<div class="block">Java API: Schedules a Runnable to be run once with a delay, i.e. a time period that
 has to pass before the runnable is executed.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the given delays exceed the maximum
 reach (calculated as: <code>delay / tickNanos > Int.MaxValue</code>).
 <p>
 Note: For scheduling within actors <code>AbstractActorWithTimers</code> should be preferred.</dd>
</dl>
</li>
</ul>
<a id="scheduleOnce$default$5(scala.concurrent.duration.FiniteDuration,org.apache.pekko.actor.ActorRef,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce$default$5</h4>
<pre class="methodSignature"><a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;scheduleOnce$default$5&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;delay,
                                <a href="ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;receiver,
                                java.lang.Object&nbsp;message)</pre>
</li>
</ul>
<a id="maxFrequency()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>maxFrequency</h4>
<pre class="methodSignature">double&nbsp;maxFrequency()</pre>
<div class="block">The maximum supported task frequency of this scheduler, i.e. the inverse
 of the minimum time interval between executions of a recurring task, in Hz.</div>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
