<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Actors interop Â· Apache Pekko</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko" class="md-header-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko
</span>
<span class="md-header-nav__topic">
Actors interop
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko">
Apache Pekko
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../downloads.html" class="page">Downloads</a></li>
  <li><a href="../documentation.html" class="page">Documentation</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../general/index.html" class="page">General Concepts</a></li>
    <li><a href="../typed/index.html" class="page">Actors</a></li>
    <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
    <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
    <li><a href="../stream/index.html" class="page">Streams</a></li>
    <li><a href="../discovery/index.html" class="page">Discovery</a></li>
    <li><a href="../index-utilities.html" class="page">Utilities</a></li>
    <li><a href="../common/other-modules.html" class="page">Other Apache Pekko modules</a></li>
    <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
    <li><a href="../project/index.html" class="page">Project Information</a></li>
    <li><a href="../index-classic.html" class="page">Pekko Classic</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../stream/actor-interop.html#actors-interop" class="header">Actors interop</a>
  <ul>
    <li><a href="../stream/actor-interop.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/actor-interop.html#overview" class="header">Overview</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 2.6.20+81-523134c3+20230202-1514*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../stream/actor-interop.html#actors-interop" class="header">Actors interop</a>
  <ul>
    <li><a href="../stream/actor-interop.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/actor-interop.html#overview" class="header">Overview</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#actors-interop" name="actors-interop" class="anchor"><span class="anchor-link"></span></a>Actors interop</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Pekko Streams, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "2.6.20+81-523134c3+20230202-1514-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-stream" % PekkoVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.20+81-523134c3+20230202-1514-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-stream_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:2.6.20+81-523134c3+20230202-1514-SNAPSHOT")

  implementation "org.apache.pekko:pekko-stream_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<h2><a href="#overview" name="overview" class="anchor"><span class="anchor-link"></span></a>Overview</h2>
<p>There are various use cases where it might be reasonable to use actors and streams together:</p>
<ul>
  <li>when integrating existing API&rsquo;s that might be streams- or actors-based.</li>
  <li>when there is any mutable state that should be shared across multiple streams.</li>
  <li>when there is any mutable state or logic that can be influenced &lsquo;from outside&rsquo; while the stream is running.</li>
</ul>
<p>For piping the elements of a stream as messages to an ordinary actor you can use <code>ask</code> in a <code>mapAsync</code> or use <code>Sink.actorRefWithBackpressure</code>.</p>
<p>Messages can be sent to a stream with <code>Source.queue</code> or via the <code>ActorRef</code> that is materialized by <code>Source.actorRef</code>.</p>
<p>Additionally you can use <code>ActorSource.actorRef</code>, <code>ActorSource.actorRefWithBackpressure</code>, <code>ActorSink.actorRef</code> and <code>ActorSink.actorRefWithBackpressure</code> shown below.</p>
<h3><a href="#ask" name="ask" class="anchor"><span class="anchor-link"></span></a>ask</h3><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/Source-or-Flow/ask.html">Flow.ask operator reference docs</a>, <a href="operators/ActorFlow/ask.html">ActorFlow.ask operator reference docs</a> for Pekko Typed</p></div>
<p>A nice way to delegate some processing of elements in a stream to an actor is to use <code>ask</code>. The back-pressure of the stream is maintained by the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> of the <code>ask</code> and the mailbox of the actor will not be filled with more messages than the given <code>parallelism</code> of the <code>ask</code> operator (similarly to how the <code>mapAsync</code> operator works).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L152-L160" target="_blank" title="Go to snippet source">source</a><code class="language-scala">implicit val askTimeout: Timeout = 5.seconds
val words: Source[String, NotUsed] =
  Source(List(&quot;hello&quot;, &quot;hi&quot;))

words
  .ask[String](parallelism = 5)(ref)
  // continue processing of the replies from the actor
  .map(_.toLowerCase)
  .runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L400-L407" target="_blank" title="Go to snippet source">source</a><code class="language-java">Source&lt;String, NotUsed&gt; words = Source.from(Arrays.asList(&quot;hello&quot;, &quot;hi&quot;));
Timeout askTimeout = Timeout.apply(5, TimeUnit.SECONDS);

words
    .ask(5, ref, String.class, askTimeout)
    // continue processing of the replies from the actor
    .map(elem -&gt; elem.toLowerCase())
    .runWith(Sink.ignore(), system);</code></pre></dd>
</dl>
<p>Note that the messages received in the actor will be in the same order as the stream elements, i.e. the <code>parallelism</code> does not change the ordering of the messages. There is a performance advantage of using parallelism &gt; 1 even though the actor will only process one message at a time because then there is already a message in the mailbox when the actor has completed previous message.</p>
<p>The actor must reply to the <span class="group-scala"><code>sender()</code></span><span class="group-java"><code>getSender()</code></span> for each message from the stream. That reply will complete the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> of the <code>ask</code> and it will be the element that is emitted downstream.</p>
<p>In case the target actor is stopped, the operator will fail with an <code>AskStageTargetActorTerminatedException</code></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L132-L139" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class Translator extends Actor {
  def receive = {
    case word: String =&gt;
      // ... process message
      val reply = word.toUpperCase
      sender() ! reply // reply to the ask
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L316-L330" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class Translator extends AbstractActor {
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            word -&gt; {
              // ... process message
              String reply = word.toUpperCase();
              // reply to the ask
              getSender().tell(reply, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>The stream can be completed with failure by sending <code>org.apache.pekko.actor.Status.Failure</code> as reply from the actor.</p>
<p>If the <code>ask</code> fails due to timeout the stream will be completed with <code>TimeoutException</code> failure. If that is not desired outcome you can use <code>recover</code> on the <code>ask</code> <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>, or use the other &ldquo;restart&rdquo; operators to restart it.</p>
<p>If you don&rsquo;t care about the reply values and only use them as back-pressure signals you can use <code>Sink.ignore</code> after the <code>ask</code> operator and then actor is effectively a sink of the stream.</p>
<p>Note that while you may implement the same concept using <code>mapAsync</code>, that style would not be aware of the actor terminating.</p>
<p>If you are intending to ask multiple actors by using <a href="../routing.html">Actor routers</a>, then you should use <code>mapAsyncUnordered</code> and perform the ask manually in there, as the ordering of the replies is not important, since multiple actors are being asked concurrently to begin with, and no single actor is the one to be watched by the operator.</p>
<h3><a href="#sink-actorrefwithbackpressure" name="sink-actorrefwithbackpressure" class="anchor"><span class="anchor-link"></span></a>Sink.actorRefWithBackpressure</h3><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/Sink/actorRefWithBackpressure.html">Sink.actorRefWithBackpressure operator reference docs</a></p></div>
<p>The sink sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal. First element is always <em>onInitMessage</em>, then stream is waiting for the given acknowledgement message from the given actor which means that it is ready to process elements. It also requires the given acknowledgement message after each stream element to make back-pressure work.</p>
<p>If the target actor terminates the stream will be cancelled. When the stream is completed successfully the given <code>onCompleteMessage</code> will be sent to the destination actor. When the stream is completed with failure a <code>org.apache.pekko.actor.Status.Failure</code> message will be sent to the destination actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L203-L228" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val words: Source[String, NotUsed] =
  Source(List(&quot;hello&quot;, &quot;hi&quot;))

// sent from actor to stream to &quot;ack&quot; processing of given element
val AckMessage = AckingReceiver.Ack

// sent from stream to actor to indicate start, end or failure of stream:
val InitMessage = AckingReceiver.StreamInitialized
val OnCompleteMessage = AckingReceiver.StreamCompleted
val onErrorMessage = (ex: Throwable) =&gt; AckingReceiver.StreamFailure(ex)

val probe = TestProbe()
val receiver = system.actorOf(Props(new AckingReceiver(probe.ref)))
val sink = Sink.actorRefWithBackpressure(
  receiver,
  onInitMessage = InitMessage,
  ackMessage = AckMessage,
  onCompleteMessage = OnCompleteMessage,
  onFailureMessage = onErrorMessage)

words.map(_.toLowerCase).runWith(sink)

probe.expectMsg(&quot;Stream initialized!&quot;)
probe.expectMsg(&quot;hello&quot;)
probe.expectMsg(&quot;hi&quot;)
probe.expectMsg(&quot;Stream completed!&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L414-L433" target="_blank" title="Go to snippet source">source</a><code class="language-java">Source&lt;String, NotUsed&gt; words = Source.from(Arrays.asList(&quot;hello&quot;, &quot;hi&quot;));

final TestKit probe = new TestKit(system);

ActorRef receiver = system.actorOf(Props.create(AckingReceiver.class, probe.getRef()));

Sink&lt;String, NotUsed&gt; sink =
    Sink.&lt;String&gt;actorRefWithBackpressure(
        receiver,
        new StreamInitialized(),
        Ack.INSTANCE,
        new StreamCompleted(),
        ex -&gt; new StreamFailure(ex));

words.map(el -&gt; el.toLowerCase()).runWith(sink, system);

probe.expectMsg(&quot;Stream initialized&quot;);
probe.expectMsg(&quot;hello&quot;);
probe.expectMsg(&quot;hi&quot;);
probe.expectMsg(&quot;Stream completed&quot;);</code></pre></dd>
</dl>
<p>The receiving actor would then need to be implemented similar to the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L233-L261" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object AckingReceiver {
  case object Ack

  case object StreamInitialized
  case object StreamCompleted
  final case class StreamFailure(ex: Throwable)
}

class AckingReceiver(probe: ActorRef) extends Actor with ActorLogging {
  import AckingReceiver._

  def receive: Receive = {
    case StreamInitialized =&gt;
      log.info(&quot;Stream initialized!&quot;)
      probe ! &quot;Stream initialized!&quot;
      sender() ! Ack // ack to allow the stream to proceed sending more elements

    case el: String =&gt;
      log.info(&quot;Received element: {}&quot;, el)
      probe ! el
      sender() ! Ack // ack to allow the stream to proceed sending more elements

    case StreamCompleted =&gt;
      log.info(&quot;Stream completed!&quot;)
      probe ! &quot;Stream completed!&quot;
    case StreamFailure(ex) =&gt;
      log.error(ex, &quot;Stream failed!&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L334-L393" target="_blank" title="Go to snippet source">source</a><code class="language-java">enum Ack {
  INSTANCE;
}

static class StreamInitialized {}

static class StreamCompleted {}

static class StreamFailure {
  private final Throwable cause;

  public StreamFailure(Throwable cause) {
    this.cause = cause;
  }

  public Throwable getCause() {
    return cause;
  }
}

static class AckingReceiver extends AbstractLoggingActor {

  private final ActorRef probe;

  public AckingReceiver(ActorRef probe) {
    this.probe = probe;
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            StreamInitialized.class,
            init -&gt; {
              log().info(&quot;Stream initialized&quot;);
              probe.tell(&quot;Stream initialized&quot;, getSelf());
              sender().tell(Ack.INSTANCE, self());
            })
        .match(
            String.class,
            element -&gt; {
              log().info(&quot;Received element: {}&quot;, element);
              probe.tell(element, getSelf());
              sender().tell(Ack.INSTANCE, self());
            })
        .match(
            StreamCompleted.class,
            completed -&gt; {
              log().info(&quot;Stream completed&quot;);
              probe.tell(&quot;Stream completed&quot;, getSelf());
            })
        .match(
            StreamFailure.class,
            failed -&gt; {
              log().error(failed.getCause(), &quot;Stream failed!&quot;);
              probe.tell(&quot;Stream failed!&quot;, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Note that replying to the sender of the elements (the &ldquo;stream&rdquo;) is required as lack of those ack signals would be interpreted as back-pressure (as intended), and no new elements will be sent into the actor until it acknowledges some elements. Handling the other signals while is not required, however is a good practice, to see the state of the stream&rsquo;s lifecycle in the connected actor as well. Technically it is also possible to use multiple sinks targeting the same actor, however it is not common practice to do so, and one should rather investigate using a <code>Merge</code> operator for this purpose.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Using <code>Sink.actorRef</code> or ordinary <code>tell</code> from a <code>map</code> or <code>foreach</code> operator means that there is no back-pressure signal from the destination actor, i.e. if the actor is not consuming the messages fast enough the mailbox of the actor will grow, unless you use a bounded mailbox with zero <em>mailbox-push-timeout-time</em> or use a rate limiting operator in front. It&rsquo;s often better to use <code>Sink.actorRefWithBackpressure</code> or <code>ask</code> in <code>mapAsync</code>, though.</p></div>
<h3><a href="#source-queue" name="source-queue" class="anchor"><span class="anchor-link"></span></a>Source.queue</h3>
<p><code>Source.queue</code> is an improvement over <code>Sink.actorRef</code>, since it can provide backpressure. The <code>offer</code> method returns a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>, which completes with the result of the enqueue operation.</p>
<p><code>Source.queue</code> can be used for emitting elements to a stream from an actor (or from anything running outside the stream). The elements will be buffered until the stream can process them. You can <code>offer</code> elements to the queue and they will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received.</p>
<p>Use overflow strategy <code>org.apache.pekko.stream.OverflowStrategy.backpressure</code> to avoid dropping of elements if the buffer is full, instead the returned <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> does not complete until there is space in the buffer and <code>offer</code> should not be called again until it completes.</p>
<p>Using <code>Source.queue</code> you can push elements to the queue and they will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received. Elements in the buffer will be discarded if downstream is terminated.</p>
<p>You could combine it with the <a href="operators/Source-or-Flow/throttle.html"><code>throttle</code></a> operator is used to slow down the stream to <code>5 element</code> per <code>3 seconds</code> and other patterns.</p>
<p><code>SourceQueue.offer</code> returns <span class="group-scala"><code>Future[QueueOfferResult]</code></span><span class="group-java"><code>CompletionStage&lt;QueueOfferResult&gt;</code></span> which completes with <code>QueueOfferResult.Enqueued</code> if element was added to buffer or sent downstream. It completes with <code>QueueOfferResult.Dropped</code> if element was dropped. Can also complete with <code>QueueOfferResult.Failure</code> - when stream failed or <code>QueueOfferResult.QueueClosed</code> when downstream is completed.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L478-L500" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val bufferSize = 10
val elementsToProcess = 5

val queue = Source
  .queue[Int](bufferSize)
  .throttle(elementsToProcess, 3.second)
  .map(x =&gt; x * x)
  .toMat(Sink.foreach(x =&gt; println(s&quot;completed $x&quot;)))(Keep.left)
  .run()

val source = Source(1 to 10)

implicit val ec = system.dispatcher
source
  .map(x =&gt; {
    queue.offer(x).map {
      case QueueOfferResult.Enqueued    =&gt; println(s&quot;enqueued $x&quot;)
      case QueueOfferResult.Dropped     =&gt; println(s&quot;dropped $x&quot;)
      case QueueOfferResult.Failure(ex) =&gt; println(s&quot;Offer failed ${ex.getMessage}&quot;)
      case QueueOfferResult.QueueClosed =&gt; println(&quot;Source Queue closed&quot;)
    }
  })
  .runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L760-L773" target="_blank" title="Go to snippet source">source</a><code class="language-java">int bufferSize = 10;
int elementsToProcess = 5;

BoundedSourceQueue&lt;Integer&gt; sourceQueue =
    Source.&lt;Integer&gt;queue(bufferSize)
        .throttle(elementsToProcess, Duration.ofSeconds(3))
        .map(x -&gt; x * x)
        .to(Sink.foreach(x -&gt; System.out.println(&quot;got: &quot; + x)))
        .run(system);

Source&lt;Integer, NotUsed&gt; source = Source.from(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

source.map(x -&gt; sourceQueue.offer(x)).runWith(Sink.ignore(), system);
</code></pre></dd>
</dl>
<p>When used from an actor you typically <code>pipe</code> the result of the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> back to the actor to continue processing.</p>
<h3><a href="#source-actorref" name="source-actorref" class="anchor"><span class="anchor-link"></span></a>Source.actorRef</h3>
<p>Messages sent to the actor that is materialized by <code>Source.actorRef</code> will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received.</p>
<p>Depending on the defined <code>OverflowStrategy</code> it might drop elements if there is no space available in the buffer. The strategy <code>OverflowStrategy.backpressure</code> is not supported for this Source type, i.e. elements will be dropped if the buffer is filled by sending at a rate that is faster than the stream can consume. You should consider using <code>Source.queue</code> if you want a backpressured actor interface.</p>
<p>The stream can be completed successfully by sending any message to the actor that is handled by the completion matching function that was provided when the actor reference was created. If the returned completion strategy is <code>org.apache.pekko.stream.CompletionStrategy.immediately</code> the completion will be signaled immediately. If the completion strategy is <code>org.apache.pekko.stream.CompletionStrategy.draining</code>, already buffered elements will be processed before signaling completion. Any elements that are in the actor&rsquo;s mailbox and subsequent elements sent to the actor will not be processed.</p>
<p>The stream can be completed with failure by sending any message to the actor that is handled by the failure matching function that was specified when the actor reference was created.</p>
<p>The actor will be stopped when the stream is completed, failed or cancelled from downstream. You can watch it to get notified when that happens.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L536-L556" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val bufferSize = 10

val cm: PartialFunction[Any, CompletionStrategy] = {
  case Done =&gt;
    CompletionStrategy.immediately
}

val ref = Source
  .actorRef[Int](
    completionMatcher = cm,
    failureMatcher = PartialFunction.empty[Any, Throwable],
    bufferSize = bufferSize,
    overflowStrategy = OverflowStrategy.fail) // note: backpressure is not supported
  .map(x =&gt; x * x)
  .toMat(Sink.foreach((x: Int) =&gt; println(s&quot;completed $x&quot;)))(Keep.left)
  .run()

ref ! 1
ref ! 2
ref ! 3
ref ! Done</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L822-L846" target="_blank" title="Go to snippet source">source</a><code class="language-java">int bufferSize = 10;

Source&lt;Integer, ActorRef&gt; source =
    Source.actorRef(
        elem -&gt; {
          // complete stream immediately if we send it Done
          if (elem == Done.done()) return Optional.of(CompletionStrategy.immediately());
          else return Optional.empty();
        },
        // never fail the stream because of a message
        elem -&gt; Optional.empty(),
        bufferSize,
        OverflowStrategy.dropHead()); // note: backpressure is not supported
ActorRef actorRef =
    source
        .map(x -&gt; x * x)
        .to(Sink.foreach(x -&gt; System.out.println(&quot;got: &quot; + x)))
        .run(system);

actorRef.tell(1, ActorRef.noSender());
actorRef.tell(2, ActorRef.noSender());
actorRef.tell(3, ActorRef.noSender());
actorRef.tell(
    new org.apache.pekko.actor.Status.Success(CompletionStrategy.draining()),
    ActorRef.noSender());</code></pre></dd>
</dl>
<h3><a href="#actorsource-actorref" name="actorsource-actorref" class="anchor"><span class="anchor-link"></span></a>ActorSource.actorRef</h3>
<p>Materialize an <span class="group-java"><code>ActorRef&lt;T&gt;</code></span><span class="group-scala"><code>ActorRef[T]</code></span>; sending messages to it will emit them on the stream only if they are of the same type as the stream.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/ActorSource/actorRef.html">ActorSource.actorRef operator reference docs</a></p></div>
<h3><a href="#actorsource-actorrefwithbackpressure" name="actorsource-actorrefwithbackpressure" class="anchor"><span class="anchor-link"></span></a>ActorSource.actorRefWithBackpressure</h3>
<p>Materialize an <span class="group-java"><code>ActorRef&lt;T&gt;</code></span><span class="group-scala"><code>ActorRef[T]</code></span>; sending messages to it will emit them on the stream. The source acknowledges reception after emitting a message, to provide back pressure from the source.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/ActorSource/actorRefWithBackpressure.html">ActorSource.actorRefWithBackpressure operator reference docs</a></p></div>
<h3><a href="#actorsink-actorref" name="actorsink-actorref" class="anchor"><span class="anchor-link"></span></a>ActorSink.actorRef</h3>
<p>Sends the elements of the stream to the given <span class="group-java"><code>ActorRef&lt;T&gt;</code></span><span class="group-scala"><code>ActorRef[T]</code></span>, without considering backpressure.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/ActorSink/actorRef.html">ActorSink.actorRef operator reference docs</a></p></div>
<h3><a href="#actorsink-actorrefwithbackpressure" name="actorsink-actorrefwithbackpressure" class="anchor"><span class="anchor-link"></span></a>ActorSink.actorRefWithBackpressure</h3>
<p>Sends the elements of the stream to the given <span class="group-java"><code>ActorRef&lt;T&gt;</code></span><span class="group-scala"><code>ActorRef[T]</code></span> with backpressure, to be able to signal demand when the actor is ready to receive more elements.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/ActorSink/actorRefWithBackpressure.html">ActorSink.actorRefWithBackpressure operator reference docs</a></p></div>
<h3><a href="#topic-source" name="topic-source" class="anchor"><span class="anchor-link"></span></a>Topic.source</h3>
<p>A source that will subscribe to a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/pubsub/Topic$.html" title="org.apache.pekko.actor.typed.pubsub.Topic"><code>Topic</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/pubsub/Topic$.html" title="org.apache.pekko.actor.typed.pubsub.Topic"><code>Topic</code></a></span> and stream messages published to the topic.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/PubSub/source.html">ActorSink.actorRefWithBackpressure operator reference docs</a></p></div>
<h3><a href="#topic-sink" name="topic-sink" class="anchor"><span class="anchor-link"></span></a>Topic.sink</h3>
<p>A sink that will publish emitted messages to a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/pubsub/Topic$.html" title="org.apache.pekko.actor.typed.pubsub.Topic"><code>Topic</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/pubsub/Topic$.html" title="org.apache.pekko.actor.typed.pubsub.Topic"><code>Topic</code></a></span>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/PubSub/sink.html">ActorSink.actorRefWithBackpressure operator reference docs</a></p></div>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/stream/actor-interop.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
2.6.20+81-523134c3+20230202-1514*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../stream/futures-interop.html" title="Futures interop" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Futures interop
</span>
</div>
</a>
<a href="../stream/reactive-streams-interop.html" title="Reactive Streams Interop" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Reactive Streams Interop
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2023 The Apache Software Foundation, Licensed under the Apache License, Version 2.0
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script src="../assets/js/groups.js"></script>
</body>
</html>
