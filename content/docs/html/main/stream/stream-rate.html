<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Buffers and working with rate · Apache Pekko</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko" class="md-header-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko
</span>
<span class="md-header-nav__topic">
Buffers and working with rate
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko">
Apache Pekko
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../downloads.html" class="page">Downloads</a></li>
  <li><a href="../documentation.html" class="page">Documentation</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../general/index.html" class="page">General Concepts</a></li>
    <li><a href="../typed/index.html" class="page">Actors</a></li>
    <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
    <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
    <li><a href="../stream/index.html" class="page">Streams</a></li>
    <li><a href="../discovery/index.html" class="page">Discovery</a></li>
    <li><a href="../index-utilities.html" class="page">Utilities</a></li>
    <li><a href="../common/other-modules.html" class="page">Other Apache Pekko modules</a></li>
    <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
    <li><a href="../project/index.html" class="page">Project Information</a></li>
    <li><a href="../index-classic.html" class="page">Pekko Classic</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../stream/stream-rate.html#buffers-and-working-with-rate" class="header">Buffers and working with rate</a>
  <ul>
    <li><a href="../stream/stream-rate.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-rate.html#introduction" class="header">Introduction</a></li>
    <li><a href="../stream/stream-rate.html#buffers-for-asynchronous-operators" class="header">Buffers for asynchronous operators</a></li>
    <li><a href="../stream/stream-rate.html#buffers-in-pekko-streams" class="header">Buffers in Pekko Streams</a></li>
    <li><a href="../stream/stream-rate.html#rate-transformation" class="header">Rate transformation</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 2.6.20+81-523134c3+20230202-1514*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../stream/stream-rate.html#buffers-and-working-with-rate" class="header">Buffers and working with rate</a>
  <ul>
    <li><a href="../stream/stream-rate.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-rate.html#introduction" class="header">Introduction</a></li>
    <li><a href="../stream/stream-rate.html#buffers-for-asynchronous-operators" class="header">Buffers for asynchronous operators</a></li>
    <li><a href="../stream/stream-rate.html#buffers-in-pekko-streams" class="header">Buffers in Pekko Streams</a></li>
    <li><a href="../stream/stream-rate.html#rate-transformation" class="header">Rate transformation</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#buffers-and-working-with-rate" name="buffers-and-working-with-rate" class="anchor"><span class="anchor-link"></span></a>Buffers and working with rate</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Pekko Streams, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "2.6.20+81-523134c3+20230202-1514-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-stream" % PekkoVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.20+81-523134c3+20230202-1514-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-stream_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:2.6.20+81-523134c3+20230202-1514-SNAPSHOT")

  implementation "org.apache.pekko:pekko-stream_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>When upstream and downstream rates differ, especially when the throughput has spikes, it can be useful to introduce buffers in a stream. In this chapter we cover how buffers are used in Pekko Streams.</p>
<a id="async-stream-buffers"></a>
<h2><a href="#buffers-for-asynchronous-operators" name="buffers-for-asynchronous-operators" class="anchor"><span class="anchor-link"></span></a>Buffers for asynchronous operators</h2>
<p>In this section we will discuss internal buffers that are introduced as an optimization when using asynchronous operators.</p>
<p>To run an operator asynchronously it has to be marked explicitly as such using the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/Graph.html#shape:S" title="pekko.stream.Graph"><code>`.async`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/Graph.html#async--" title="pekko.stream.Graph"><code>`.async()`</code></a></span> method. Being run asynchronously means that an operator, after handing out an element to its downstream consumer is able to immediately process the next message. To demonstrate what we mean by this, let&rsquo;s take a look at the following example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/StreamBuffersRateSpec.scala#L26-L39" target="_blank" title="Go to snippet source">source</a><code class="language-scala">Source(1 to 3)
  .map { i =&gt;
    println(s&quot;A: $i&quot;); i
  }
  .async
  .map { i =&gt;
    println(s&quot;B: $i&quot;); i
  }
  .async
  .map { i =&gt;
    println(s&quot;C: $i&quot;); i
  }
  .async
  .runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/StreamBuffersRateDocTest.java#L52-L71" target="_blank" title="Go to snippet source">source</a><code class="language-java">Source.from(Arrays.asList(1, 2, 3))
    .map(
        i -&gt; {
          System.out.println(&quot;A: &quot; + i);
          return i;
        })
    .async()
    .map(
        i -&gt; {
          System.out.println(&quot;B: &quot; + i);
          return i;
        })
    .async()
    .map(
        i -&gt; {
          System.out.println(&quot;C: &quot; + i);
          return i;
        })
    .async()
    .runWith(Sink.ignore(), system);</code></pre></dd>
</dl>
<p>Running the above example, one of the possible outputs looks like this:</p>
<pre><code>A: 1
A: 2
B: 1
A: 3
B: 2
C: 1
B: 3
C: 2
C: 3
</code></pre>
<p>Note that the order is <em>not</em> <code>A:1, B:1, C:1, A:2, B:2, C:2,</code> which would correspond to the normal fused synchronous execution model of flows where an element completely passes through the processing pipeline before the next element enters the flow. The next element is processed by an asynchronous operator as soon as it has emitted the previous one.</p>
<p>While pipelining in general increases throughput, in practice there is a cost of passing an element through the asynchronous (and therefore thread crossing) boundary which is significant. To amortize this cost Pekko Streams uses a <em>windowed</em>, <em>batching</em> backpressure strategy internally. It is windowed because as opposed to a <a href="https://en.wikipedia.org/wiki/Stop-and-wait_ARQ">Stop-And-Wait</a> protocol multiple elements might be &ldquo;in-flight&rdquo; concurrently with requests for elements. It is also batching because a new element is not immediately requested once an element has been drained from the window-buffer but multiple elements are requested after multiple elements have been drained. This batching strategy reduces the communication cost of propagating the backpressure signal through the asynchronous boundary.</p>
<p>While this internal protocol is mostly invisible to the user (apart from its throughput increasing effects) there are situations when these details get exposed. In all of our previous examples we always assumed that the rate of the processing chain is strictly coordinated through the backpressure signal causing all operators to process no faster than the throughput of the connected chain. There are tools in Pekko Streams however that enable the rates of different segments of a processing chain to be &ldquo;detached&rdquo; or to define the maximum throughput of the stream through external timing sources. These situations are exactly those where the internal batching buffering strategy suddenly becomes non-transparent.</p>
<h3><a href="#internal-buffers-and-their-effect" name="internal-buffers-and-their-effect" class="anchor"><span class="anchor-link"></span></a>Internal buffers and their effect</h3>
<p>As we have explained, for performance reasons Pekko Streams introduces a buffer for every asynchronous operator. The purpose of these buffers is solely optimization, in fact the size of 1 would be the most natural choice if there would be no need for throughput improvements. Therefore it is recommended to keep these buffer sizes small, and increase them only to a level suitable for the throughput requirements of the application. Default buffer sizes can be set through configuration:</p>
<pre><code>pekko.stream.materializer.max-input-buffer-size = 16
</code></pre>
<p>Alternatively they can be set per stream by adding an attribute to the complete <code>RunnableGraph</code> or on smaller segments of the stream it is possible by defining a separate <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/Flow.html" title="pekko.stream.scaladsl.Flow"><code>`Flow`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Flow.html" title="pekko.stream.javadsl.Flow"><code>`Flow`</code></a></span> with these attributes:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/StreamBuffersRateSpec.scala#L45-L50" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val section = Flow[Int].map(_ * 2).async.addAttributes(Attributes.inputBuffer(initial = 1, max = 1)) // the buffer size of this map is 1
val flow = section.via(Flow[Int].map(_ / 2)).async // the buffer size of this map is the default
val runnableGraph =
  Source(1 to 10).via(flow).to(Sink.foreach(elem =&gt; println(elem)))

val withOverriddenDefaults = runnableGraph.withAttributes(Attributes.inputBuffer(initial = 64, max = 64))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/StreamBuffersRateDocTest.java#L79-L93" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Flow&lt;Integer, Integer, NotUsed&gt; flow1 =
    Flow.of(Integer.class)
        .map(elem -&gt; elem * 2)
        .async()
        .addAttributes(Attributes.inputBuffer(1, 1)); // the buffer size of this map is 1
final Flow&lt;Integer, Integer, NotUsed&gt; flow2 =
    flow1
        .via(Flow.of(Integer.class).map(elem -&gt; elem / 2))
        .async(); // the buffer size of this map is the value from the surrounding graph it is
// used in
final RunnableGraph&lt;NotUsed&gt; runnableGraph =
    Source.range(1, 10).via(flow1).to(Sink.foreach(elem -&gt; System.out.println(elem)));

final RunnableGraph&lt;NotUsed&gt; withOverridenDefaults =
    runnableGraph.withAttributes(Attributes.inputBuffer(64, 64));</code></pre></dd>
</dl>
<p>Here is an example of a code that demonstrate some of the issues caused by internal buffers:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/StreamBuffersRateSpec.scala#L56-L73" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import scala.concurrent.duration._
case class Tick()

RunnableGraph.fromGraph(GraphDSL.create() { implicit b =&gt;
  import GraphDSL.Implicits._

  // this is the asynchronous stage in this graph
  val zipper = b.add(ZipWith[Tick, Int, Int]((tick, count) =&gt; count).async)

  Source.tick(initialDelay = 3.second, interval = 3.second, Tick()) ~&gt; zipper.in0

  Source
    .tick(initialDelay = 1.second, interval = 1.second, &quot;message!&quot;)
    .conflateWithSeed(seed = _ =&gt; 1)((count, _) =&gt; count + 1) ~&gt; zipper.in1

  zipper.out ~&gt; Sink.foreach(println)
  ClosedShape
})</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/StreamBuffersRateDocTest.java#L100-L118" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Duration oneSecond = Duration.ofSeconds(1);
final Source&lt;String, Cancellable&gt; msgSource = Source.tick(oneSecond, oneSecond, &quot;message!&quot;);
final Source&lt;String, Cancellable&gt; tickSource =
    Source.tick(oneSecond.multipliedBy(3), oneSecond.multipliedBy(3), &quot;tick&quot;);
final Flow&lt;String, Integer, NotUsed&gt; conflate =
    Flow.of(String.class).conflateWithSeed(first -&gt; 1, (count, elem) -&gt; count + 1);

RunnableGraph.fromGraph(
        GraphDSL.create(
            b -&gt; {
              // this is the asynchronous stage in this graph
              final FanInShape2&lt;String, Integer, Integer&gt; zipper =
                  b.add(ZipWith.create((String tick, Integer count) -&gt; count).async());
              b.from(b.add(msgSource)).via(b.add(conflate)).toInlet(zipper.in1());
              b.from(b.add(tickSource)).toInlet(zipper.in0());
              b.from(zipper.out()).to(b.add(Sink.foreach(elem -&gt; System.out.println(elem))));
              return ClosedShape.getInstance();
            }))
    .run(system);</code></pre></dd>
</dl>
<p>Running the above example one would expect the number <em>3</em> to be printed in every 3 seconds (the <code>conflateWithSeed</code> step here is configured so that it counts the number of elements received before the downstream <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/ZipWith$.html" title="pekko.stream.scaladsl.ZipWith"><code>`ZipWith`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/ZipWith$.html" title="pekko.stream.javadsl.ZipWith"><code>`ZipWith`</code></a></span> consumes them). What is being printed is different though, we will see the number <em>1</em>. The reason for this is the internal buffer which is by default 16 elements large, and prefetches elements before the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/ZipWith$.html" title="pekko.stream.scaladsl.ZipWith"><code>`ZipWith`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/ZipWith$.html" title="pekko.stream.javadsl.ZipWith"><code>`ZipWith`</code></a></span> starts consuming them. It is possible to fix this issue by changing the buffer size of <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/ZipWith$.html" title="pekko.stream.scaladsl.ZipWith"><code>`ZipWith`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/ZipWith$.html" title="pekko.stream.javadsl.ZipWith"><code>`ZipWith`</code></a></span> to 1. We will still see a leading 1 though which is caused by an initial prefetch of the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/ZipWith$.html" title="pekko.stream.scaladsl.ZipWith"><code>`ZipWith`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/ZipWith$.html" title="pekko.stream.javadsl.ZipWith"><code>`ZipWith`</code></a></span> element.</p><div class="callout note "><div class="callout-title">Note</div>
<p>In general, when time or rate driven operators exhibit strange behavior, one of the first solutions to try should be to decrease the input buffer of the affected elements to 1.</p></div>
<h2><a href="#buffers-in-pekko-streams" name="buffers-in-pekko-streams" class="anchor"><span class="anchor-link"></span></a>Buffers in Pekko Streams</h2>
<p>In this section we will discuss <em>explicit</em> user defined buffers that are part of the domain logic of the stream processing pipeline of an application.</p>
<p>The example below will ensure that 1000 jobs (but not more) are dequeued from an external (imaginary) system and stored locally in memory - relieving the external system:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/StreamBuffersRateSpec.scala#L81-L83" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// Getting a stream of jobs from an imaginary external system as a Source
val jobs: Source[Job, NotUsed] = inboundJobsConnector()
jobs.buffer(1000, OverflowStrategy.backpressure)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/StreamBuffersRateDocTest.java#L126-L128" target="_blank" title="Go to snippet source">source</a><code class="language-java">// Getting a stream of jobs from an imaginary external system as a Source
final Source&lt;Job, NotUsed&gt; jobs = inboundJobsConnector;
jobs.buffer(1000, OverflowStrategy.backpressure());</code></pre></dd>
</dl>
<p>The next example will also queue up 1000 jobs locally, but if there are more jobs waiting in the imaginary external systems, it makes space for the new element by dropping one element from the <em>tail</em> of the buffer. Dropping from the tail is a very common strategy but it must be noted that this will drop the <em>youngest</em> waiting job. If some &ldquo;fairness&rdquo; is desired in the sense that we want to be nice to jobs that has been waiting for long, then this option can be useful.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/StreamBuffersRateSpec.scala#L87" target="_blank" title="Go to snippet source">source</a><code class="language-scala">jobs.buffer(1000, OverflowStrategy.dropTail)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/StreamBuffersRateDocTest.java#L132" target="_blank" title="Go to snippet source">source</a><code class="language-java">jobs.buffer(1000, OverflowStrategy.dropTail());</code></pre></dd>
</dl>
<p>Instead of dropping the youngest element from the tail of the buffer a new element can be dropped without enqueueing it to the buffer at all.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/StreamBuffersRateSpec.scala#L91" target="_blank" title="Go to snippet source">source</a><code class="language-scala">jobs.buffer(1000, OverflowStrategy.dropNew)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/StreamBuffersRateDocTest.java#L136" target="_blank" title="Go to snippet source">source</a><code class="language-java">jobs.buffer(1000, OverflowStrategy.dropNew());</code></pre></dd>
</dl>
<p>Here is another example with a queue of 1000 jobs, but it makes space for the new element by dropping one element from the <em>head</em> of the buffer. This is the <em>oldest</em> waiting job. This is the preferred strategy if jobs are expected to be resent if not processed in a certain period. The oldest element will be retransmitted soon, (in fact a retransmitted duplicate might be already in the queue!) so it makes sense to drop it first.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/StreamBuffersRateSpec.scala#L95" target="_blank" title="Go to snippet source">source</a><code class="language-scala">jobs.buffer(1000, OverflowStrategy.dropHead)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/StreamBuffersRateDocTest.java#L140" target="_blank" title="Go to snippet source">source</a><code class="language-java">jobs.buffer(1000, OverflowStrategy.dropHead());</code></pre></dd>
</dl>
<p>Compared to the dropping strategies above, dropBuffer drops all the 1000 jobs it has enqueued once the buffer gets full. This aggressive strategy is useful when dropping jobs is preferred to delaying jobs.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/StreamBuffersRateSpec.scala#L99" target="_blank" title="Go to snippet source">source</a><code class="language-scala">jobs.buffer(1000, OverflowStrategy.dropBuffer)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/StreamBuffersRateDocTest.java#L144" target="_blank" title="Go to snippet source">source</a><code class="language-java">jobs.buffer(1000, OverflowStrategy.dropBuffer());</code></pre></dd>
</dl>
<p>If our imaginary external job provider is a client using our API, we might want to enforce that the client cannot have more than 1000 queued jobs otherwise we consider it flooding and terminate the connection. This is achievable by the error strategy which fails the stream once the buffer gets full.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/StreamBuffersRateSpec.scala#L103" target="_blank" title="Go to snippet source">source</a><code class="language-scala">jobs.buffer(1000, OverflowStrategy.fail)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/StreamBuffersRateDocTest.java#L148" target="_blank" title="Go to snippet source">source</a><code class="language-java">jobs.buffer(1000, OverflowStrategy.fail());</code></pre></dd>
</dl>
<h2><a href="#rate-transformation" name="rate-transformation" class="anchor"><span class="anchor-link"></span></a>Rate transformation</h2>
<h3><a href="#understanding-conflate" name="understanding-conflate" class="anchor"><span class="anchor-link"></span></a>Understanding conflate</h3>
<p>When a fast producer can not be informed to slow down by backpressure or some other signal, <code>conflate</code> might be useful to combine elements from a producer until a demand signal comes from a consumer.</p>
<p>Below is an example snippet that summarizes fast stream of elements to a standard deviation, mean and count of elements that have arrived while the stats have been calculated.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/RateTransformationDocSpec.scala#L31-L36" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val statsFlow = Flow[Double].conflateWithSeed(immutable.Seq(_))(_ :+ _).map { s =&gt;
  val μ = s.sum / s.size
  val se = s.map(x =&gt; pow(x - μ, 2))
  val σ = sqrt(se.sum / se.size)
  (σ, μ, s.size)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/RateTransformationDocTest.java#L69-L83" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Flow&lt;Double, Tuple3&lt;Double, Double, Integer&gt;, NotUsed&gt; statsFlow =
    Flow.of(Double.class)
        .conflateWithSeed(
            elem -&gt; Collections.singletonList(elem),
            (acc, elem) -&gt; {
              return Stream.concat(acc.stream(), Collections.singletonList(elem).stream())
                  .collect(Collectors.toList());
            })
        .map(
            s -&gt; {
              final Double mean = s.stream().mapToDouble(d -&gt; d).sum() / s.size();
              final DoubleStream se = s.stream().mapToDouble(x -&gt; Math.pow(x - mean, 2));
              final Double stdDev = Math.sqrt(se.sum() / s.size());
              return new Tuple3&lt;&gt;(stdDev, mean, s.size());
            });</code></pre></dd>
</dl>
<p>This example demonstrates that such flow&rsquo;s rate is decoupled. The element rate at the start of the flow can be much higher than the element rate at the end of the flow.</p>
<p>Another possible use of <code>conflate</code> is to not consider all elements for summary when the producer starts getting too fast. The example below demonstrates how <code>conflate</code> can be used to randomly drop elements when the consumer is not able to keep up with the producer.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/RateTransformationDocSpec.scala#L51-L57" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val p = 0.01
val sampleFlow = Flow[Double]
  .conflateWithSeed(immutable.Seq(_)) {
    case (acc, elem) if Random.nextDouble() &lt; p =&gt; acc :+ elem
    case (acc, _)                               =&gt; acc
  }
  .mapConcat(identity)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/RateTransformationDocTest.java#L99-L111" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Double p = 0.01;
final Flow&lt;Double, Double, NotUsed&gt; sampleFlow =
    Flow.of(Double.class)
        .conflateWithSeed(
            elem -&gt; Collections.singletonList(elem),
            (acc, elem) -&gt; {
              if (r.nextDouble() &lt; p) {
                return Stream.concat(acc.stream(), Collections.singletonList(elem).stream())
                    .collect(Collectors.toList());
              }
              return acc;
            })
        .mapConcat(d -&gt; d);</code></pre></dd>
</dl>
<p>See also <a href="operators/Source-or-Flow/conflate.html"><code>conflate</code></a> and <a href="operators/Source-or-Flow/conflateWithSeed.html">conflateWithSeed`</a> for more information and examples.</p>
<h3><a href="#understanding-extrapolate-and-expand" name="understanding-extrapolate-and-expand" class="anchor"><span class="anchor-link"></span></a>Understanding extrapolate and expand</h3>
<p>Now we will discuss two operators, <code>extrapolate</code> and <code>expand</code>, helping to deal with slow producers that are unable to keep up with the demand coming from consumers. They allow for additional values to be sent as elements to a consumer.</p>
<p>As a simple use case of <code>extrapolate</code>, here is a flow that repeats the last emitted element to a consumer, whenever the consumer signals demand and the producer cannot supply new elements yet.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/RateTransformationDocSpec.scala#L67" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val lastFlow = Flow[Double].extrapolate(Iterator.continually(_))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/RateTransformationDocTest.java#L125-L126" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Flow&lt;Double, Double, NotUsed&gt; lastFlow =
    Flow.of(Double.class).extrapolate(in -&gt; Stream.iterate(in, i -&gt; i).iterator());</code></pre></dd>
</dl>
<p>For situations where there may be downstream demand before any element is emitted from upstream, you can use the <code>initial</code> parameter of <code>extrapolate</code> to &ldquo;seed&rdquo; the stream.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/RateTransformationDocSpec.scala#L80-L81" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val initial = 2.0
val seedFlow = Flow[Double].extrapolate(Iterator.continually(_), Some(initial))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/RateTransformationDocTest.java#L147-L149" target="_blank" title="Go to snippet source">source</a><code class="language-java">Double initial = 2.0;
final Flow&lt;Double, Double, NotUsed&gt; lastFlow =
    Flow.of(Double.class).extrapolate(in -&gt; Stream.iterate(in, i -&gt; i).iterator(), initial);</code></pre></dd>
</dl>
<p><code>extrapolate</code> and <code>expand</code> also allow to produce meta-information based on demand signalled from the downstream. Leveraging this, here is a flow that tracks and reports a drift between a fast consumer and a slow producer. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/RateTransformationDocSpec.scala#L93" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val driftFlow = Flow[Double].map(_ -&gt; 0).extrapolate[(Double, Int)] { case (i, _) =&gt; Iterator.from(1).map(i -&gt; _) }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/RateTransformationDocTest.java#L168-L172" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Flow&lt;Double, Pair&lt;Double, Integer&gt;, NotUsed&gt; driftFlow =
    Flow.of(Double.class)
        .map(d -&gt; new Pair&lt;&gt;(d, 0))
        .extrapolate(
            d -&gt; Stream.iterate(1, i -&gt; i + 1).map(i -&gt; new Pair&lt;&gt;(d.first(), i)).iterator());</code></pre></dd>
</dl>
<p>And here&rsquo;s a more concise representation with <code>expand</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/RateTransformationDocSpec.scala#L116" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val driftFlow = Flow[Double].expand(i =&gt; Iterator.from(0).map(i -&gt; _))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/RateTransformationDocTest.java#L215-L217" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Flow&lt;Double, Pair&lt;Double, Integer&gt;, NotUsed&gt; driftFlow =
    Flow.of(Double.class)
        .expand(d -&gt; Stream.iterate(0, i -&gt; i + 1).map(i -&gt; new Pair&lt;&gt;(d, i)).iterator());</code></pre></dd>
</dl>
<p>The difference is due to the different handling of the <code>Iterator</code>-generating argument.</p>
<p>While <code>extrapolate</code> uses an <code>Iterator</code> only when there is unmet downstream demand, <code>expand</code> <em>always</em> creates an <code>Iterator</code> and emits elements downstream from it.</p>
<p>This makes <code>expand</code> able to transform or even filter out (by providing an empty <code>Iterator</code>) the &ldquo;original&rdquo; elements.</p>
<p>Regardless, since we provide a non-empty <code>Iterator</code> in both examples, this means that the output of this flow is going to report a drift of zero if the producer is fast enough - or a larger drift otherwise.</p>
<p>See also <a href="operators/Source-or-Flow/extrapolate.html"><code>extrapolate</code></a> and <a href="operators/Source-or-Flow/expand.html"><code>expand</code></a> for more information and examples.</p>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/stream/stream-rate.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
2.6.20+81-523134c3+20230202-1514*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../stream/stream-composition.html" title="Modularity, Composition and Hierarchy" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Modularity, Composition and Hierarchy
</span>
</div>
</a>
<a href="../stream/stream-context.html" title="Context Propagation" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Context Propagation
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright © 2023 The Apache Software Foundation, Licensed under the Apache License, Version 2.0
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script src="../assets/js/groups.js"></script>
</body>
</html>
