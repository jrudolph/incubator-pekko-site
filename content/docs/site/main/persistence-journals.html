<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<link rel="shortcut icon" href="assets/images/favicon.png">
<title>Persistence - Building a storage backend Â· Apache Pekko</title>
<link rel="stylesheet" href="assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<script src="assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="assets/fonts/font-awesome.css">
<link rel="stylesheet" href="assets/fonts/material-icons.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="Apache Pekko" class="md-header-nav__button md-logo">
<img src="images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko
</span>
<span class="md-header-nav__topic">
Persistence - Building a storage backend
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="index.html" title="Apache Pekko" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="images/pekko_logo.png" width="24" height="24">
</a>
<a href="index.html" title="Apache Pekko">
Apache Pekko
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="downloads.html" class="page">Downloads</a></li>
  <li><a href="documentation.html" class="page">Documentation</a>
  <ul>
    <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="general/index.html" class="page">General Concepts</a></li>
    <li><a href="typed/index.html" class="page">Actors</a></li>
    <li><a href="typed/index-cluster.html" class="page">Cluster</a></li>
    <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
    <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
    <li><a href="stream/index.html" class="page">Streams</a></li>
    <li><a href="discovery/index.html" class="page">Discovery</a></li>
    <li><a href="index-utilities.html" class="page">Utilities</a></li>
    <li><a href="common/other-modules.html" class="page">Other Apache Pekko modules</a></li>
    <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
    <li><a href="project/index.html" class="page">Project Information</a></li>
    <li><a href="index-classic.html" class="page">Pekko Classic</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="persistence-journals.html#persistence-building-a-storage-backend" class="header">Persistence - Building a storage backend</a>
  <ul>
    <li><a href="persistence-journals.html#journal-plugin-api" class="header">Journal plugin API</a></li>
    <li><a href="persistence-journals.html#snapshot-store-plugin-api" class="header">Snapshot store plugin API</a></li>
    <li><a href="persistence-journals.html#plugin-tck" class="header">Plugin TCK</a></li>
    <li><a href="persistence-journals.html#corrupt-event-logs" class="header">Corrupt event logs</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 2.6.20+81-523134c3+20230202-1514*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="persistence-journals.html#persistence-building-a-storage-backend" class="header">Persistence - Building a storage backend</a>
  <ul>
    <li><a href="persistence-journals.html#journal-plugin-api" class="header">Journal plugin API</a></li>
    <li><a href="persistence-journals.html#snapshot-store-plugin-api" class="header">Snapshot store plugin API</a></li>
    <li><a href="persistence-journals.html#plugin-tck" class="header">Plugin TCK</a></li>
    <li><a href="persistence-journals.html#corrupt-event-logs" class="header">Corrupt event logs</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#persistence-building-a-storage-backend" name="persistence-building-a-storage-backend" class="anchor"><span class="anchor-link"></span></a>Persistence - Building a storage backend</h1>
<p>Storage backends for journals and snapshot stores are pluggable in the Pekko persistence extension. A directory of persistence journal and snapshot store plugins is available at the Pekko Community Projects page, see <a href="https://akka.io/community/">Community plugins</a> This documentation described how to build a new storage backend.</p>
<p>Applications can provide their own plugins by implementing a plugin API and activating them by configuration. Plugin development requires the following imports:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L27-L31" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.persistence._
import pekko.persistence.journal._
import pekko.persistence.snapshot._
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/persistence/LambdaPersistencePluginDocTest.java#L17-L20" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.dispatch.Futures;
import org.apache.pekko.persistence.*;
import org.apache.pekko.persistence.journal.japi.*;
import org.apache.pekko.persistence.snapshot.japi.*;</code></pre></dd>
</dl>
<h2><a href="#journal-plugin-api" name="journal-plugin-api" class="anchor"><span class="anchor-link"></span></a>Journal plugin API</h2>
<p>A journal plugin extends <code>AsyncWriteJournal</code>.</p>
<p><code>AsyncWriteJournal</code> is an actor and the methods to be implemented are:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence/src/main/scala/org/apache/pekko/persistence/journal/AsyncWriteJournal.scala#L212-L297" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * Plugin API: asynchronously writes a batch (`Seq`) of persistent messages to the
 * journal.
 *
 * The batch is only for performance reasons, i.e. all messages don&#39;t have to be written
 * atomically. Higher throughput can typically be achieved by using batch inserts of many
 * records compared to inserting records one-by-one, but this aspect depends on the
 * underlying data store and a journal implementation can implement it as efficient as
 * possible. Journals should aim to persist events in-order for a given `persistenceId`
 * as otherwise in case of a failure, the persistent state may be end up being inconsistent.
 *
 * Each `AtomicWrite` message contains the single `PersistentRepr` that corresponds to
 * the event that was passed to the `persist` method of the `PersistentActor`, or it
 * contains several `PersistentRepr` that corresponds to the events that were passed
 * to the `persistAll` method of the `PersistentActor`. All `PersistentRepr` of the
 * `AtomicWrite` must be written to the data store atomically, i.e. all or none must
 * be stored. If the journal (data store) cannot support atomic writes of multiple
 * events it should reject such writes with a `Try` `Failure` with an
 * `UnsupportedOperationException` describing the issue. This limitation should
 * also be documented by the journal plugin.
 *
 * If there are failures when storing any of the messages in the batch the returned
 * `Future` must be completed with failure. The `Future` must only be completed with
 * success when all messages in the batch have been confirmed to be stored successfully,
 * i.e. they will be readable, and visible, in a subsequent replay. If there is
 * uncertainty about if the messages were stored or not the `Future` must be completed
 * with failure.
 *
 * Data store connection problems must be signaled by completing the `Future` with
 * failure.
 *
 * The journal can also signal that it rejects individual messages (`AtomicWrite`) by
 * the returned `immutable.Seq[Try[Unit]]`. It is possible but not mandatory to reduce
 * number of allocations by returning `Future.successful(Nil)` for the happy path,
 * i.e. when no messages are rejected. Otherwise the returned `Seq` must have as many elements
 * as the input `messages` `Seq`. Each `Try` element signals if the corresponding
 * `AtomicWrite` is rejected or not, with an exception describing the problem. Rejecting
 * a message means it was not stored, i.e. it must not be included in a later replay.
 * Rejecting a message is typically done before attempting to store it, e.g. because of
 * serialization error.
 *
 * Data store connection problems must not be signaled as rejections.
 *
 * It is possible but not mandatory to reduce number of allocations by returning
 * `Future.successful(Nil)` for the happy path, i.e. when no messages are rejected.
 *
 * Calls to this method are serialized by the enclosing journal actor. If you spawn
 * work in asynchronous tasks it is alright that they complete the futures in any order,
 * but the actual writes for a specific persistenceId should be serialized to avoid
 * issues such as events of a later write are visible to consumers (query side, or replay)
 * before the events of an earlier write are visible.
 * A PersistentActor will not send a new WriteMessages request before the previous one
 * has been completed.
 *
 * Please note that the `sender` field of the contained PersistentRepr objects has been
 * nulled out (i.e. set to `ActorRef.noSender`) in order to not use space in the journal
 * for a sender reference that will likely be obsolete during replay.
 *
 * Please also note that requests for the highest sequence number may be made concurrently
 * to this call executing for the same `persistenceId`, in particular it is possible that
 * a restarting actor tries to recover before its outstanding writes have completed. In
 * the latter case it is highly desirable to defer reading the highest sequence number
 * until all outstanding writes have completed, otherwise the PersistentActor may reuse
 * sequence numbers.
 *
 * This call is protected with a circuit-breaker.
 */
def asyncWriteMessages(messages: immutable.Seq[AtomicWrite]): Future[immutable.Seq[Try[Unit]]]

/**
 * Plugin API: asynchronously deletes all persistent messages up to `toSequenceNr`
 * (inclusive).
 *
 * This call is protected with a circuit-breaker.
 * Message deletion doesn&#39;t affect the highest sequence number of messages,
 * journal must maintain the highest sequence number and never decrease it.
 */
def asyncDeleteMessagesTo(persistenceId: String, toSequenceNr: Long): Future[Unit]

/**
 * Plugin API
 *
 * Allows plugin implementers to use `f pipeTo self` and
 * handle additional messages for implementing advanced features
 */
def receivePluginInternal: Actor.Receive = Actor.emptyBehavior</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence/src/main/java/org/apache/pekko/persistence/journal/japi/AsyncWritePlugin.java#L24-L85" target="_blank" title="Go to snippet source">source</a><code class="language-java">/**
 * Java API, Plugin API: asynchronously writes a batch (`Iterable`) of persistent messages to the
 * journal.
 *
 * &lt;p&gt;The batch is only for performance reasons, i.e. all messages don&#39;t have to be written
 * atomically. Higher throughput can typically be achieved by using batch inserts of many records
 * compared to inserting records one-by-one, but this aspect depends on the underlying data store
 * and a journal implementation can implement it as efficient as possible. Journals should aim to
 * persist events in-order for a given `persistenceId` as otherwise in case of a failure, the
 * persistent state may be end up being inconsistent.
 *
 * &lt;p&gt;Each `AtomicWrite` message contains the single `PersistentRepr` that corresponds to the
 * event that was passed to the `persist` method of the `PersistentActor`, or it contains several
 * `PersistentRepr` that corresponds to the events that were passed to the `persistAll` method of
 * the `PersistentActor`. All `PersistentRepr` of the `AtomicWrite` must be written to the data
 * store atomically, i.e. all or none must be stored. If the journal (data store) cannot support
 * atomic writes of multiple events it should reject such writes with an `Optional` with an
 * `UnsupportedOperationException` describing the issue. This limitation should also be documented
 * by the journal plugin.
 *
 * &lt;p&gt;If there are failures when storing any of the messages in the batch the returned `Future`
 * must be completed with failure. The `Future` must only be completed with success when all
 * messages in the batch have been confirmed to be stored successfully, i.e. they will be
 * readable, and visible, in a subsequent replay. If there is uncertainty about if the messages
 * were stored or not the `Future` must be completed with failure.
 *
 * &lt;p&gt;Data store connection problems must be signaled by completing the `Future` with failure.
 *
 * &lt;p&gt;The journal can also signal that it rejects individual messages (`AtomicWrite`) by the
 * returned `Iterable&amp;lt;Optional&amp;lt;Exception&amp;gt;&amp;gt;`. The returned `Iterable` must have as many
 * elements as the input `messages` `Iterable`. Each `Optional` element signals if the
 * corresponding `AtomicWrite` is rejected or not, with an exception describing the problem.
 * Rejecting a message means it was not stored, i.e. it must not be included in a later replay.
 * Rejecting a message is typically done before attempting to store it, e.g. because of
 * serialization error.
 *
 * &lt;p&gt;Data store connection problems must not be signaled as rejections.
 *
 * &lt;p&gt;Note that it is possible to reduce number of allocations by caching some result `Iterable`
 * for the happy path, i.e. when no messages are rejected.
 *
 * &lt;p&gt;Calls to this method are serialized by the enclosing journal actor. If you spawn work in
 * asynchronous tasks it is alright that they complete the futures in any order, but the actual
 * writes for a specific persistenceId should be serialized to avoid issues such as events of a
 * later write are visible to consumers (query side, or replay) before the events of an earlier
 * write are visible. This can also be done with consistent hashing if it is too fine grained to
 * do it on the persistenceId level. Normally a `PersistentActor` will only have one outstanding
 * write request to the journal but it may emit several write requests when `persistAsync` is used
 * and the max batch size is reached.
 *
 * &lt;p&gt;This call is protected with a circuit-breaker.
 */
Future&lt;Iterable&lt;Optional&lt;Exception&gt;&gt;&gt; doAsyncWriteMessages(Iterable&lt;AtomicWrite&gt; messages);

/**
 * Java API, Plugin API: synchronously deletes all persistent messages up to `toSequenceNr`.
 *
 * &lt;p&gt;This call is protected with a circuit-breaker.
 *
 * @see AsyncRecoveryPlugin
 */
Future&lt;Void&gt; doAsyncDeleteMessagesTo(String persistenceId, long toSequenceNr);</code></pre></dd>
</dl>
<p>If the storage backend API only supports synchronous, blocking writes, the methods should be implemented as:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L167-L171" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def asyncWriteMessages(messages: immutable.Seq[AtomicWrite]): Future[immutable.Seq[Try[Unit]]] =
  Future.fromTry(Try {
    // blocking call here
    ???
  })</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/persistence/LambdaPersistencePluginDocTest.java#L107-L118" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public Future&lt;Iterable&lt;Optional&lt;Exception&gt;&gt;&gt; doAsyncWriteMessages(
    Iterable&lt;AtomicWrite&gt; messages) {
  try {
    Iterable&lt;Optional&lt;Exception&gt;&gt; result = new ArrayList&lt;Optional&lt;Exception&gt;&gt;();
    // blocking call here...
    // result.add(..)
    return Futures.successful(result);
  } catch (Exception e) {
    return Futures.failed(e);
  }
}</code></pre></dd>
</dl>
<p>A journal plugin must also implement the methods defined in <code>AsyncRecovery</code> for replays and sequence number recovery:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence/src/main/scala/org/apache/pekko/persistence/journal/AsyncRecovery.scala#L26-L80" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * Plugin API: asynchronously replays persistent messages. Implementations replay
 * a message by calling `replayCallback`. The returned future must be completed
 * when all messages (matching the sequence number bounds) have been replayed.
 * The future must be completed with a failure if any of the persistent messages
 * could not be replayed.
 *
 * The `replayCallback` must also be called with messages that have been marked
 * as deleted. In this case a replayed message&#39;s `deleted` method must return
 * `true`.
 *
 * The `toSequenceNr` is the lowest of what was returned by [[#asyncReadHighestSequenceNr]]
 * and what the user specified as recovery [[pekko.persistence.Recovery]] parameter.
 * This does imply that this call is always preceded by reading the highest sequence
 * number for the given `persistenceId`.
 *
 * This call is NOT protected with a circuit-breaker because it may take long time
 * to replay all events. The plugin implementation itself must protect against
 * an unresponsive backend store and make sure that the returned Future is
 * completed with success or failure within reasonable time. It is not allowed
 * to ignore completing the future.
 *
 * @param persistenceId persistent actor id.
 * @param fromSequenceNr sequence number where replay should start (inclusive).
 * @param toSequenceNr sequence number where replay should end (inclusive).
 * @param max maximum number of messages to be replayed.
 * @param recoveryCallback called to replay a single message. Can be called from any
 *                       thread.
 *
 * @see [[AsyncWriteJournal]]
 */
def asyncReplayMessages(persistenceId: String, fromSequenceNr: Long, toSequenceNr: Long, max: Long)(
    recoveryCallback: PersistentRepr =&gt; Unit): Future[Unit]

/**
 * Plugin API: asynchronously reads the highest stored sequence number for the
 * given `persistenceId`. The persistent actor will use the highest sequence
 * number after recovery as the starting point when persisting new events.
 * This sequence number is also used as `toSequenceNr` in subsequent call
 * to [[#asyncReplayMessages]] unless the user has specified a lower `toSequenceNr`.
 * Journal must maintain the highest sequence number and never decrease it.
 *
 * This call is protected with a circuit-breaker.
 *
 * Please also note that requests for the highest sequence number may be made concurrently
 * to writes executing for the same `persistenceId`, in particular it is possible that
 * a restarting actor tries to recover before its outstanding writes have completed.
 *
 * @param persistenceId persistent actor id.
 * @param fromSequenceNr hint where to start searching for the highest sequence
 *                       number. When a persistent actor is recovering this
 *                       `fromSequenceNr` will be the sequence number of the used
 *                       snapshot or `0L` if no snapshot is used.
 */
def asyncReadHighestSequenceNr(persistenceId: String, fromSequenceNr: Long): Future[Long]</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence/src/main/java/org/apache/pekko/persistence/journal/japi/AsyncRecoveryPlugin.java#L24-L60" target="_blank" title="Go to snippet source">source</a><code class="language-java">/**
 * Java API, Plugin API: asynchronously replays persistent messages. Implementations replay a
 * message by calling `replayCallback`. The returned future must be completed when all messages
 * (matching the sequence number bounds) have been replayed. The future must be completed with a
 * failure if any of the persistent messages could not be replayed.
 *
 * &lt;p&gt;The `replayCallback` must also be called with messages that have been marked as deleted. In
 * this case a replayed message&#39;s `deleted` method must return `true`.
 *
 * &lt;p&gt;The `toSequenceNr` is the lowest of what was returned by {@link
 * #doAsyncReadHighestSequenceNr} and what the user specified as recovery {@link
 * org.apache.pekko.persistence.Recovery} parameter.
 *
 * @param persistenceId id of the persistent actor.
 * @param fromSequenceNr sequence number where replay should start (inclusive).
 * @param toSequenceNr sequence number where replay should end (inclusive).
 * @param max maximum number of messages to be replayed.
 * @param replayCallback called to replay a single message. Can be called from any thread.
 */
Future&lt;Void&gt; doAsyncReplayMessages(
    String persistenceId,
    long fromSequenceNr,
    long toSequenceNr,
    long max,
    Consumer&lt;PersistentRepr&gt; replayCallback);

/**
 * Java API, Plugin API: asynchronously reads the highest stored sequence number for the given
 * `persistenceId`. The persistent actor will use the highest sequence number after recovery as
 * the starting point when persisting new events. This sequence number is also used as
 * `toSequenceNr` in subsequent call to [[#asyncReplayMessages]] unless the user has specified a
 * lower `toSequenceNr`.
 *
 * @param persistenceId id of the persistent actor.
 * @param fromSequenceNr hint where to start searching for the highest sequence number.
 */
Future&lt;Long&gt; doAsyncReadHighestSequenceNr(String persistenceId, long fromSequenceNr);</code></pre></dd>
</dl>
<p>A journal plugin can be activated with the following minimal configuration:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L79-L88" target="_blank" title="Go to snippet source">source</a><code class="language-scala"># Path to the journal plugin to be used
pekko.persistence.journal.plugin = &quot;my-journal&quot;

# My custom journal plugin
my-journal {
  # Class name of the plugin.
  class = &quot;docs.persistence.MyJournal&quot;
  # Dispatcher for the plugin actor.
  plugin-dispatcher = &quot;pekko.actor.default-dispatcher&quot;
}</code></pre>
<p>The journal plugin instance is an actor so the methods corresponding to requests from persistent actors are executed sequentially. It may delegate to asynchronous libraries, spawn futures, or delegate to other actors to achieve parallelism.</p>
<p>The journal plugin class must have a constructor with one of these signatures:</p>
<ul>
  <li>constructor with one <code>com.typesafe.config.Config</code> parameter and a <code>String</code> parameter for the config path</li>
  <li>constructor with one <code>com.typesafe.config.Config</code> parameter</li>
  <li>constructor without parameters</li>
</ul>
<p>The plugin section of the actor system&rsquo;s config will be passed in the config constructor parameter. The config path of the plugin is passed in the <code>String</code> parameter.</p>
<p>The <code>plugin-dispatcher</code> is the dispatcher used for the plugin actor. If not specified, it defaults to <code>pekko.persistence.dispatchers.default-plugin-dispatcher</code>.</p>
<p>Don&rsquo;t run journal tasks/futures on the system default dispatcher, since that might starve other tasks.</p>
<h2><a href="#snapshot-store-plugin-api" name="snapshot-store-plugin-api" class="anchor"><span class="anchor-link"></span></a>Snapshot store plugin API</h2>
<p>A snapshot store plugin must extend the <code>SnapshotStore</code> actor and implement the following methods:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence/src/main/scala/org/apache/pekko/persistence/snapshot/SnapshotStore.scala#L137-L188" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>/**
 * Plugin API: asynchronously loads a snapshot.
 *
 * If the future `Option` is `None` then all events will be replayed,
 * i.e. there was no snapshot. If snapshot could not be loaded the `Future`
 * should be completed with failure. That is important because events may
 * have been deleted and just replaying the events might not result in a valid
 * state.
 *
 * This call is protected with a circuit-breaker.
 *
 * @param persistenceId id of the persistent actor.
 * @param criteria selection criteria for loading.
 */
def loadAsync(persistenceId: String, criteria: SnapshotSelectionCriteria): Future[Option[SelectedSnapshot]]

/**
 * Plugin API: asynchronously saves a snapshot.
 *
 * This call is protected with a circuit-breaker.
 *
 * @param metadata snapshot metadata.
 * @param snapshot snapshot.
 */
def saveAsync(metadata: SnapshotMetadata, snapshot: Any): Future[Unit]

/**
 * Plugin API: deletes the snapshot identified by `metadata`.
 *
 * This call is protected with a circuit-breaker.
 *
 * @param metadata snapshot metadata.
 */
def deleteAsync(metadata: SnapshotMetadata): Future[Unit]

/**
 * Plugin API: deletes all snapshots matching `criteria`.
 *
 * This call is protected with a circuit-breaker.
 *
 * @param persistenceId id of the persistent actor.
 * @param criteria selection criteria for deleting.
 */
def deleteAsync(persistenceId: String, criteria: SnapshotSelectionCriteria): Future[Unit]

/**
 * Plugin API
 * Allows plugin implementers to use `f pipeTo self` and
 * handle additional messages for implementing advanced features
 */
def receivePluginInternal: Actor.Receive = Actor.emptyBehavior</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence/src/main/java/org/apache/pekko/persistence/snapshot/japi/SnapshotStorePlugin.java#L25-L55" target="_blank" title="Go to snippet source">source</a><code class="language-java">/**
 * Java API, Plugin API: asynchronously loads a snapshot.
 *
 * @param persistenceId id of the persistent actor.
 * @param criteria selection criteria for loading.
 */
Future&lt;Optional&lt;SelectedSnapshot&gt;&gt; doLoadAsync(
    String persistenceId, SnapshotSelectionCriteria criteria);

/**
 * Java API, Plugin API: asynchronously saves a snapshot.
 *
 * @param metadata snapshot metadata.
 * @param snapshot snapshot.
 */
Future&lt;Void&gt; doSaveAsync(SnapshotMetadata metadata, Object snapshot);

/**
 * Java API, Plugin API: deletes the snapshot identified by `metadata`.
 *
 * @param metadata snapshot metadata.
 */
Future&lt;Void&gt; doDeleteAsync(SnapshotMetadata metadata);

/**
 * Java API, Plugin API: deletes all snapshots matching `criteria`.
 *
 * @param persistenceId id of the persistent actor.
 * @param criteria selection criteria for deleting.
 */
Future&lt;Void&gt; doDeleteAsync(String persistenceId, SnapshotSelectionCriteria criteria);</code></pre></dd>
</dl>
<p>A snapshot store plugin can be activated with the following minimal configuration:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L92-L101" target="_blank" title="Go to snippet source">source</a><code class="language-scala"># Path to the snapshot store plugin to be used
pekko.persistence.snapshot-store.plugin = &quot;my-snapshot-store&quot;

# My custom snapshot store plugin
my-snapshot-store {
  # Class name of the plugin.
  class = &quot;docs.persistence.MySnapshotStore&quot;
  # Dispatcher for the plugin actor.
  plugin-dispatcher = &quot;pekko.persistence.dispatchers.default-plugin-dispatcher&quot;
}</code></pre>
<p>The snapshot store instance is an actor so the methods corresponding to requests from persistent actors are executed sequentially. It may delegate to asynchronous libraries, spawn futures, or delegate to other actors to achieve parallelism.</p>
<p>The snapshot store plugin class must have a constructor with one of these signatures:</p>
<ul>
  <li>constructor with one <code>com.typesafe.config.Config</code> parameter and a <code>String</code> parameter for the config path</li>
  <li>constructor with one <code>com.typesafe.config.Config</code> parameter</li>
  <li>constructor without parameters</li>
</ul>
<p>The plugin section of the actor system&rsquo;s config will be passed in the config constructor parameter. The config path of the plugin is passed in the <code>String</code> parameter.</p>
<p>The <code>plugin-dispatcher</code> is the dispatcher used for the plugin actor. If not specified, it defaults to <code>pekko.persistence.dispatchers.default-plugin-dispatcher</code>.</p>
<p>Don&rsquo;t run snapshot store tasks/futures on the system default dispatcher, since that might starve other tasks.</p>
<h2><a href="#plugin-tck" name="plugin-tck" class="anchor"><span class="anchor-link"></span></a>Plugin TCK</h2>
<p>In order to help developers build correct and high quality storage plugins, we provide a Technology Compatibility Kit (<a href="https://en.wikipedia.org/wiki/Technology_Compatibility_Kit">TCK</a> for short).</p>
<p>The TCK is usable from Java as well as Scala projects. To test your implementation (independently of language) you need to include the pekko-persistence-tck dependency:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "2.6.20+81-523134c3+20230202-1514-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-persistence-tck" % PekkoVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.20+81-523134c3+20230202-1514-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-persistence-tck_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:2.6.20+81-523134c3+20230202-1514-SNAPSHOT")

  implementation "org.apache.pekko:pekko-persistence-tck_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<p>To include the Journal TCK tests in your test suite simply extend the provided <span class="group-scala"><code>JournalSpec</code></span><span class="group-java"><code>JavaJournalSpec</code></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L198-L207" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class MyJournalSpec
    extends JournalSpec(
      config = ConfigFactory.parseString(&quot;&quot;&quot;pekko.persistence.journal.plugin = &quot;my.journal.plugin&quot;&quot;&quot;&quot;)) {

  override def supportsRejectingNonSerializableObjects: CapabilityFlag =
    false // or CapabilityFlag.off

  override def supportsSerialization: CapabilityFlag =
    true // or CapabilityFlag.on
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/persistence/LambdaPersistencePluginDocTest.java#L145-L159" target="_blank" title="Go to snippet source">source</a><code class="language-java">@RunWith(JUnitRunner.class)
class MyJournalSpecTest extends JavaJournalSpec {

  public MyJournalSpecTest() {
    super(
        ConfigFactory.parseString(
            &quot;pekko.persistence.journal.plugin = &quot;
                + &quot;\&quot;pekko.persistence.journal.leveldb-shared\&quot;&quot;));
  }

  @Override
  public CapabilityFlag supportsRejectingNonSerializableObjects() {
    return CapabilityFlag.off();
  }
}</code></pre></dd>
</dl>
<p>Please note that some of the tests are optional, and by overriding the <code>supports...</code> methods you give the TCK the needed information about which tests to run. You can implement these methods using <span class="group-scala">boolean values or</span> the provided <code>CapabilityFlag.on</code> / <code>CapabilityFlag.off</code> values.</p>
<p>We also provide a simple benchmarking class <span class="group-scala"><code>JournalPerfSpec</code></span><span class="group-java"><code>JavaJournalPerfSpec</code></span> which includes all the tests that <span class="group-scala"><code>JournalSpec</code></span><span class="group-java"><code>JavaJournalSpec</code></span> has, and also performs some longer operations on the Journal while printing its performance stats. While it is NOT aimed to provide a proper benchmarking environment it can be used to get a rough feel about your journal&rsquo;s performance in the most typical scenarios.</p>
<p>In order to include the <code>SnapshotStore</code> TCK tests in your test suite extend the <code>SnapshotStoreSpec</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L214-L222" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class MySnapshotStoreSpec
    extends SnapshotStoreSpec(
      config = ConfigFactory.parseString(&quot;&quot;&quot;
    pekko.persistence.snapshot-store.plugin = &quot;my.snapshot-store.plugin&quot;
    &quot;&quot;&quot;)) {

  override def supportsSerialization: CapabilityFlag =
    true // or CapabilityFlag.on
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/persistence/LambdaPersistencePluginDocTest.java#L166-L175" target="_blank" title="Go to snippet source">source</a><code class="language-java">@RunWith(JUnitRunner.class)
class MySnapshotStoreTest extends JavaSnapshotStoreSpec {

  public MySnapshotStoreTest() {
    super(
        ConfigFactory.parseString(
            &quot;pekko.persistence.snapshot-store.plugin = &quot;
                + &quot;\&quot;pekko.persistence.snapshot-store.local\&quot;&quot;));
  }
}</code></pre></dd>
</dl>
<p>In case your plugin requires some setting up (starting a mock database, removing temporary files etc.) you can override the <code>beforeAll</code> and <code>afterAll</code> methods to hook into the tests lifecycle:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L232-L254" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class MyJournalSpec
    extends JournalSpec(config = ConfigFactory.parseString(&quot;&quot;&quot;
    pekko.persistence.journal.plugin = &quot;my.journal.plugin&quot;
    &quot;&quot;&quot;)) {

  override def supportsRejectingNonSerializableObjects: CapabilityFlag =
    true // or CapabilityFlag.on

  val storageLocations = List(
    new File(system.settings.config.getString(&quot;pekko.persistence.journal.leveldb.dir&quot;)),
    new File(config.getString(&quot;pekko.persistence.snapshot-store.local.dir&quot;)))

  override def beforeAll(): Unit = {
    super.beforeAll()
    storageLocations.foreach(FileUtils.deleteRecursively)
  }

  override def afterAll(): Unit = {
    storageLocations.foreach(FileUtils.deleteRecursively)
    super.afterAll()
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/persistence/LambdaPersistencePluginDocTest.java#L183-L221" target="_blank" title="Go to snippet source">source</a><code class="language-java">@RunWith(JUnitRunner.class)
class MyJournalSpecTest extends JavaJournalSpec {

  List&lt;File&gt; storageLocations = new ArrayList&lt;File&gt;();

  public MyJournalSpecTest() {
    super(
        ConfigFactory.parseString(
            &quot;persistence.journal.plugin = &quot;
                + &quot;\&quot;pekko.persistence.journal.leveldb-shared\&quot;&quot;));

    Config config = system().settings().config();
    storageLocations.add(
        new File(config.getString(&quot;pekko.persistence.journal.leveldb.dir&quot;)));
    storageLocations.add(
        new File(config.getString(&quot;pekko.persistence.snapshot-store.local.dir&quot;)));
  }

  @Override
  public CapabilityFlag supportsRejectingNonSerializableObjects() {
    return CapabilityFlag.on();
  }

  @Override
  public void beforeAll() {
    for (File storageLocation : storageLocations) {
      FileUtils.deleteRecursively(storageLocation);
    }
    super.beforeAll();
  }

  @Override
  public void afterAll() {
    super.afterAll();
    for (File storageLocation : storageLocations) {
      FileUtils.deleteRecursively(storageLocation);
    }
  }
}</code></pre></dd>
</dl>
<p>We <em>highly recommend</em> including these specifications in your test suite, as they cover a broad range of cases you might have otherwise forgotten to test for when writing a plugin from scratch.</p>
<h2><a href="#corrupt-event-logs" name="corrupt-event-logs" class="anchor"><span class="anchor-link"></span></a>Corrupt event logs</h2>
<p>If a journal can&rsquo;t prevent users from running persistent actors with the same <code>persistenceId</code> concurrently it is likely that an event log will be corrupted by having events with the same sequence number.</p>
<p>It is recommended that journals should still deliver these events during recovery so that a <code>replay-filter</code> can be used to decide what to do about it in a journal agnostic way.</p>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/persistence-journals.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
2.6.20+81-523134c3+20230202-1514*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="persistence-plugins.html" title="Persistence Plugins" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Persistence Plugins
</span>
</div>
</a>
<a href="typed/replicated-eventsourcing-examples.html" title="Replicated Event Sourcing Examples" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Replicated Event Sourcing Examples
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2023 The Apache Software Foundation, Licensed under the Apache License, Version 2.0
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application.583bbe55.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"."}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script src="assets/js/groups.js"></script>
</body>
</html>
