<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<link rel="shortcut icon" href="assets/images/favicon.png">
<title>Classic Cluster Client Â· Apache Pekko</title>
<link rel="stylesheet" href="assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<script src="assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="assets/fonts/font-awesome.css">
<link rel="stylesheet" href="assets/fonts/material-icons.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="Apache Pekko" class="md-header-nav__button md-logo">
<img src="images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko
</span>
<span class="md-header-nav__topic">
Classic Cluster Client
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="index.html" title="Apache Pekko" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="images/pekko_logo.png" width="24" height="24">
</a>
<a href="index.html" title="Apache Pekko">
Apache Pekko
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="downloads.html" class="page">Downloads</a></li>
  <li><a href="documentation.html" class="page">Documentation</a>
  <ul>
    <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="general/index.html" class="page">General Concepts</a></li>
    <li><a href="typed/index.html" class="page">Actors</a></li>
    <li><a href="typed/index-cluster.html" class="page">Cluster</a></li>
    <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
    <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
    <li><a href="stream/index.html" class="page">Streams</a></li>
    <li><a href="discovery/index.html" class="page">Discovery</a></li>
    <li><a href="index-utilities.html" class="page">Utilities</a></li>
    <li><a href="common/other-modules.html" class="page">Other Apache Pekko modules</a></li>
    <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
    <li><a href="project/index.html" class="page">Project Information</a></li>
    <li><a href="index-classic.html" class="page">Pekko Classic</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="cluster-client.html#classic-cluster-client" class="header">Classic Cluster Client</a>
  <ul>
    <li><a href="cluster-client.html#module-info" class="header">Module info</a></li>
    <li><a href="cluster-client.html#introduction" class="header">Introduction</a></li>
    <li><a href="cluster-client.html#an-example" class="header">An Example</a></li>
    <li><a href="cluster-client.html#clusterclientreceptionist-extension" class="header">ClusterClientReceptionist Extension</a></li>
    <li><a href="cluster-client.html#events" class="header">Events</a></li>
    <li><a href="cluster-client.html#configuration" class="header">Configuration</a></li>
    <li><a href="cluster-client.html#failure-handling" class="header">Failure handling</a></li>
    <li><a href="cluster-client.html#when-the-cluster-cannot-be-reached-at-all" class="header">When the cluster cannot be reached at all</a></li>
    <li><a href="cluster-client.html#migration-to-apache-pekko-grpc" class="header">Migration to Apache Pekko gRPC</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 2.6.20+81-523134c3+20230202-1514*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="cluster-client.html#classic-cluster-client" class="header">Classic Cluster Client</a>
  <ul>
    <li><a href="cluster-client.html#module-info" class="header">Module info</a></li>
    <li><a href="cluster-client.html#introduction" class="header">Introduction</a></li>
    <li><a href="cluster-client.html#an-example" class="header">An Example</a></li>
    <li><a href="cluster-client.html#clusterclientreceptionist-extension" class="header">ClusterClientReceptionist Extension</a></li>
    <li><a href="cluster-client.html#events" class="header">Events</a></li>
    <li><a href="cluster-client.html#configuration" class="header">Configuration</a></li>
    <li><a href="cluster-client.html#failure-handling" class="header">Failure handling</a></li>
    <li><a href="cluster-client.html#when-the-cluster-cannot-be-reached-at-all" class="header">When the cluster cannot be reached at all</a></li>
    <li><a href="cluster-client.html#migration-to-apache-pekko-grpc" class="header">Migration to Apache Pekko gRPC</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#classic-cluster-client" name="classic-cluster-client" class="anchor"><span class="anchor-link"></span></a>Classic Cluster Client</h1><div class="callout warning "><div class="callout-title">Warning</div>
<p>Cluster Client is deprecated in favor of using <a href="https://pekko.apache.org/docs/pekko-grpc/current/index.html">Pekko gRPC</a>. It is not advised to build new applications with Cluster Client.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>Pekko Classic pertains to the original Actor APIs, which have been improved by more type safe and guided Actor APIs. Pekko Classic is still fully supported and existing applications can continue to use the classic APIs. It is also possible to use the new Actor APIs together with classic actors in the same ActorSystem, see <a href="typed/coexisting.html">coexistence</a>. For new projects we recommend using <a href="typed/actors.html">the new Actor API</a>.</p></div>
<h2><a href="#module-info" name="module-info" class="anchor"><span class="anchor-link"></span></a>Module info</h2>
<p>To use Cluster Client, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "2.6.20+81-523134c3+20230202-1514-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-cluster-tools" % PekkoVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.20+81-523134c3+20230202-1514-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-cluster-tools_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:2.6.20+81-523134c3+20230202-1514-SNAPSHOT")

  implementation "org.apache.pekko:pekko-cluster-tools_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<table class="project-info">
<tr><th colspan="2">Project Info: Pekko Cluster Tools (classic)</th></tr>
  <tr><th>Artifact</th><td><div>org.apache.pekko</div>
  <div>pekko-cluster-tools</div>
  <div>2.6.20+81-523134c3+20230202-1514-SNAPSHOT</div>
  <div><a href="project/links.html#snapshots-repository">Snapshots are available</a></div>
  </td></tr>
  <tr><th>JDK versions</th><td><div>Adopt OpenJDK 8</div><div>Adopt OpenJDK 11</div></td></tr>
  <tr><th>Scala versions</th><td>2.13.8, 2.12.16, 3.1.2</td></tr>
  <tr><th>JPMS module name</th><td>pekko.cluster.tools</td></tr>
  <tr><th>License</th><td><div><a href="https://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener noreferrer">Apache-2.0</a></div>
  </td></tr>
  
  <tr><th>Home page</th><td><a href="https://pekko.apache.org/">https://pekko.apache.org/</a></td></tr>
  <tr><th>API documentation</th><td>
  <div><a href="https://pekko.apache.org/api/pekko/snapshot/pekko/cluster/tools/index.html" target="_blank" rel="noopener noreferrer">API (Scaladoc)</a></div>
  <div><a href="https://pekko.apache.org/japi/pekko/snapshot/pekko/cluster/tools/package-summary.html" target="_blank" rel="noopener noreferrer">API (Javadoc)</a></div>
  </td></tr>
  <tr><th>Forums</th><td>
  <div><a href="https://lists.apache.org/list.html?dev@pekko.apache.org" target="_blank" rel="noopener noreferrer">Apache Pekko Dev mailing list</a></div>
  <div><a href="https://github.com/apache/incubator-pekko/discussions" target="_blank" rel="noopener noreferrer">apache/incubator-pekko discussion</a></div>
  </td></tr>
  <tr><th>Release notes</th><td><a href="https://akka.io/blog/news-archive.html">akka.io blog</a></td></tr>
  <tr><th>Issues</th><td><a href="https://github.com/apache/incubator-pekko/issues" target="_blank" rel="noopener noreferrer">Github issues</a></td></tr>
  <tr><th>Sources</th><td><a href="https://github.com/apache/incubator-pekko" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-pekko</a></td></tr>
</table>

<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>

<p>An actor system that is not part of the cluster can communicate with actors somewhere in the cluster via the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span>, the client can run in an <code>ActorSystem</code> that is part of another cluster. It only needs to know the location of one (or more) nodes to use as initial contact points. It will establish a connection to a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterReceptionist.html" title="org.apache.pekko.cluster.client.ClusterReceptionist"><code>ClusterReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterReceptionist.html" title="org.apache.pekko.cluster.client.ClusterReceptionist"><code>ClusterReceptionist</code></a></span> somewhere in the cluster. It will monitor the connection to the receptionist and establish a new connection if the link goes down. When looking for a new receptionist it uses fresh contact points retrieved from the previous establishment, or periodically refreshed contacts, i.e. not necessarily the initial contact points.</p>

<p>Using the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> for communicating with a cluster from the outside requires that the system with the client can both connect and be connected with Pekko Remoting from all the nodes in the cluster with a receptionist. This creates a tight coupling in that the client and cluster systems may need to have the same version of both Pekko, libraries, message classes, serializers and potentially even the JVM. In many cases it is a better solution to use a more explicit and decoupling protocol such as <a href="https://pekko.apache.org/docs/pekko-http/current/index.html">HTTP</a> or <a href="https://pekko.apache.org/docs/pekko-grpc/current/">gRPC</a>.</p>

<p>Additionally, since Pekko Remoting is primarily designed as a protocol for Pekko Cluster there is no explicit resource management, when a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> has been used it will cause connections with the cluster until the ActorSystem is stopped (unlike other kinds of network clients).</p>

<p><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> should not be used when sending messages to actors that run within the same cluster. Similar functionality as the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> is provided more efficiently by <a href="distributed-pub-sub.html">Distributed Publish Subscribe in Cluster</a> for actors that belong to the same cluster.</p>

<p>The connecting system must have its <code>org.apache.pekko.actor.provider</code> set to <code>remote</code> or <code>cluster</code> when using the cluster client.</p>

<p>The receptionist is supposed to be started on all nodes, or all nodes with a specified role, in the cluster. The receptionist can be started with the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterReceptionist.html" title="org.apache.pekko.cluster.client.ClusterReceptionist"><code>ClusterReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterReceptionist.html" title="org.apache.pekko.cluster.client.ClusterReceptionist"><code>ClusterReceptionist</code></a></span> extension or as an ordinary actor.</p>

<p>You can send messages via the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> to any actor in the cluster that is registered in the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/pubsub/DistributedPubSubMediator.html" title="org.apache.pekko.cluster.pubsub.DistributedPubSubMediator"><code>DistributedPubSubMediator</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/pubsub/DistributedPubSubMediator.html" title="org.apache.pekko.cluster.pubsub.DistributedPubSubMediator"><code>DistributedPubSubMediator</code></a></span> used by the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterReceptionist.html" title="org.apache.pekko.cluster.client.ClusterReceptionist"><code>ClusterReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterReceptionist.html" title="org.apache.pekko.cluster.client.ClusterReceptionist"><code>ClusterReceptionist</code></a></span>. The <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span> provides methods for registration of actors that should be reachable from the client. Messages are wrapped in <code>ClusterClient.Send</code>, <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/cluster/client/ClusterClient$.html" title="pekko.cluster.client.ClusterClient"><code>`ClusterClient.SendToAll`</code></a></span><span class="group-java"><code>ClusterClient.SendToAll</code></span> or <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient$.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>`ClusterClient.Publish`</code></a></span><span class="group-java"><code>ClusterClient.Publish</code></span>.</p>

<p>Both the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> and the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span> emit events that can be subscribed to. The <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> sends out notifications about the list of contact points received from the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span>. One use of this list might be for the client to record its contact points. A client that is restarted could then use this information to supersede any previously configured contact points.</p>

<p>The <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span> sends out notifications in relation to having received a contact from a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span>. This notification enables the server containing the receptionist to become aware of what clients are connected to.</p>

<ol>
  <li><strong>ClusterClient.Send</strong></li>
</ol>
<p>The message will be delivered to one recipient with a matching path if any such exists. If several entries match the path the message will be delivered  to one random destination. The sender of the message can specify that local  affinity is preferred, i.e. the message is sent to an actor in the same local actor  system as the used receptionist actor, if any such exists, otherwise random to any other  matching entry.</p>
<ol>
  <li><strong>ClusterClient.SendToAll</strong></li>
</ol>
<p>The message will be delivered to all recipients with a matching path.</p>
<ol>
  <li><strong>ClusterClient.Publish</strong></li>
</ol>
<p>The message will be delivered to all recipients Actors that have been registered as subscribers  to the named topic.</p>
<p>Response messages from the destination actor are tunneled via the receptionist to avoid inbound connections from other cluster nodes to the client:</p>
<ul>
  <li><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/actor/Actor.html" title="pekko.actor.Actor"><code>`sender()`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/actor/Actor.html" title="pekko.actor.Actor"><code>`getSender()`</code></a></span>, as seen by the destination actor, is not the client itself,  but the receptionist</li>
  <li><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/actor/Actor.html" title="pekko.actor.Actor"><code>`sender()`</code></a></span> <span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/actor/Actor.html" title="pekko.actor.Actor"><code>`getSender()`</code></a></span> of the response messages, sent back from the destination and seen by the client,  is <code>deadLetters</code></li>
</ul>
<p>since the client should normally send subsequent messages via the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span>. It is possible to pass the original sender inside the reply messages if the client is supposed to communicate directly to the actor in the cluster.</p>
<p>While establishing a connection to a receptionist the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> will buffer messages and send them when the connection is established. If the buffer is full the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> will drop old messages when new messages are sent via the client. The size of the buffer is configurable and it can be disabled by using a buffer size of 0.</p>
<p>It&rsquo;s worth noting that messages can always be lost because of the distributed nature of these actors. As always, additional logic should be implemented in the destination (acknowledgement) and in the client (retry) actors to ensure at-least-once message delivery.</p>
<h2><a href="#an-example" name="an-example" class="anchor"><span class="anchor-link"></span></a>An Example</h2>
<p>On the cluster nodes, first start the receptionist. Note, it is recommended to load the extension when the actor system is started by defining it in the <code>pekko.extensions</code> configuration property:</p>
<pre><code>pekko.extensions = [&quot;org.apache.pekko.cluster.client.ClusterClientReceptionist&quot;]
</code></pre>
<p>Next, register the actors that should be available for the client.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/multi-jvm/scala/org/apache/pekko/cluster/client/ClusterClientSpec.scala#L275-L283" target="_blank" title="Go to snippet source">source</a><code class="language-scala">runOn(host1) {
  val serviceA = system.actorOf(Props[Service](), &quot;serviceA&quot;)
  ClusterClientReceptionist(system).registerService(serviceA)
}

runOn(host2, host3) {
  val serviceB = system.actorOf(Props[Service](), &quot;serviceB&quot;)
  ClusterClientReceptionist(system).registerService(serviceB)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/test/java/org/apache/pekko/cluster/client/ClusterClientTest.java#L53-L57" target="_blank" title="Go to snippet source">source</a><code class="language-java">ActorRef serviceA = system.actorOf(Props.create(Service.class), &quot;serviceA&quot;);
ClusterClientReceptionist.get(system).registerService(serviceA);

ActorRef serviceB = system.actorOf(Props.create(Service.class), &quot;serviceB&quot;);
ClusterClientReceptionist.get(system).registerService(serviceB);</code></pre></dd>
</dl>
<p>On the client, you create the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> actor and use it as a gateway for sending messages to the actors identified by their path (without address information) somewhere in the cluster.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/multi-jvm/scala/org/apache/pekko/cluster/client/ClusterClientSpec.scala#L292-L298" target="_blank" title="Go to snippet source">source</a><code class="language-scala">runOn(client) {
  val c = system.actorOf(
    ClusterClient.props(ClusterClientSettings(system).withInitialContacts(initialContacts)),
    &quot;client&quot;)
  c ! ClusterClient.Send(&quot;/user/serviceA&quot;, &quot;hello&quot;, localAffinity = true)
  c ! ClusterClient.SendToAll(&quot;/user/serviceB&quot;, &quot;hi&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/test/java/org/apache/pekko/cluster/client/ClusterClientTest.java#L61-L67" target="_blank" title="Go to snippet source">source</a><code class="language-java">final ActorRef c =
    system.actorOf(
        ClusterClient.props(
            ClusterClientSettings.create(system).withInitialContacts(initialContacts())),
        &quot;client&quot;);
c.tell(new ClusterClient.Send(&quot;/user/serviceA&quot;, &quot;hello&quot;, true), ActorRef.noSender());
c.tell(new ClusterClient.SendToAll(&quot;/user/serviceB&quot;, &quot;hi&quot;), ActorRef.noSender());</code></pre></dd>
</dl>
<p>The <code>initialContacts</code> parameter is a <span class="group-scala"><code>Set[ActorPath]</code></span><span class="group-java"><code>Set&lt;ActorPath&gt;</code></span>, which can be created like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/multi-jvm/scala/org/apache/pekko/cluster/client/ClusterClientSpec.scala#L207-L210" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val initialContacts = Set(
  ActorPath.fromString(&quot;akka://OtherSys@host1:2552/system/receptionist&quot;),
  ActorPath.fromString(&quot;akka://OtherSys@host2:2552/system/receptionist&quot;))
val settings = ClusterClientSettings(system).withInitialContacts(initialContacts)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/test/java/org/apache/pekko/cluster/client/ClusterClientTest.java#L41-L46" target="_blank" title="Go to snippet source">source</a><code class="language-java">Set&lt;ActorPath&gt; initialContacts() {
  return new HashSet&lt;ActorPath&gt;(
      Arrays.asList(
          ActorPaths.fromString(&quot;akka://OtherSys@host1:2552/system/receptionist&quot;),
          ActorPaths.fromString(&quot;akka://OtherSys@host2:2552/system/receptionist&quot;)));
}</code></pre></dd>
</dl>
<p>You will probably define the address information of the initial contact points in configuration or system property. See also <a href="cluster-client.html#cluster-client-config">Configuration</a>.</p>
<h2><a href="#clusterclientreceptionist-extension" name="clusterclientreceptionist-extension" class="anchor"><span class="anchor-link"></span></a>ClusterClientReceptionist Extension</h2>
<p>In the example above the receptionist is started and accessed with the <code>org.apache.pekko.cluster.client.ClusterClientReceptionist</code> extension. That is convenient and perfectly fine in most cases, but it can be good to know that it is possible to start the <code>org.apache.pekko.cluster.client.ClusterReceptionist</code> actor as an ordinary actor and you can have several different receptionists at the same time, serving different types of clients.</p>
<p>Note that the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span> uses the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/pubsub/DistributedPubSub.html" title="org.apache.pekko.cluster.pubsub.DistributedPubSub"><code>DistributedPubSub</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/pubsub/DistributedPubSub.html" title="org.apache.pekko.cluster.pubsub.DistributedPubSub"><code>DistributedPubSub</code></a></span> extension, which is described in <a href="distributed-pub-sub.html">Distributed Publish Subscribe in Cluster</a>.</p>
<p>It is recommended to load the extension when the actor system is started by defining it in the <code>pekko.extensions</code> configuration property:</p>
<pre><code>pekko.extensions = [&quot;pekko.cluster.client.ClusterClientReceptionist&quot;]
</code></pre>
<h2><a href="#events" name="events" class="anchor"><span class="anchor-link"></span></a>Events</h2>
<p>As mentioned earlier, both the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> and <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span> emit events that can be subscribed to. The following code snippet declares an actor that will receive notifications on contact points (addresses to the available receptionists), as they become available. The code illustrates subscribing to the events and receiving the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClient.html" title="org.apache.pekko.cluster.client.ClusterClient"><code>ClusterClient</code></a></span> initial state.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/multi-jvm/scala/org/apache/pekko/cluster/client/ClusterClientSpec.scala#L88-L106" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class ClientListener(targetClient: ActorRef) extends Actor {
  override def preStart(): Unit =
    targetClient ! SubscribeContactPoints

  def receive: Receive =
    receiveWithContactPoints(Set.empty)

  def receiveWithContactPoints(contactPoints: Set[ActorPath]): Receive = {
    case ContactPoints(cps) =&gt;
      context.become(receiveWithContactPoints(cps))
    // Now do something with the up-to-date &quot;cps&quot;
    case ContactPointAdded(cp) =&gt;
      context.become(receiveWithContactPoints(contactPoints + cp))
    // Now do something with an up-to-date &quot;contactPoints + cp&quot;
    case ContactPointRemoved(cp) =&gt;
      context.become(receiveWithContactPoints(contactPoints - cp))
    // Now do something with an up-to-date &quot;contactPoints - cp&quot;
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/test/java/org/apache/pekko/cluster/client/ClusterClientTest.java#L81-L117" target="_blank" title="Go to snippet source">source</a><code class="language-java">public static class ClientListener extends AbstractActor {
  private final ActorRef targetClient;
  private final Set&lt;ActorPath&gt; contactPoints = new HashSet&lt;&gt;();

  public ClientListener(ActorRef targetClient) {
    this.targetClient = targetClient;
  }

  @Override
  public void preStart() {
    targetClient.tell(SubscribeContactPoints.getInstance(), sender());
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            ContactPoints.class,
            msg -&gt; {
              contactPoints.addAll(msg.getContactPoints());
              // Now do something with an up-to-date &quot;contactPoints&quot;
            })
        .match(
            ContactPointAdded.class,
            msg -&gt; {
              contactPoints.add(msg.contactPoint());
              // Now do something with an up-to-date &quot;contactPoints&quot;
            })
        .match(
            ContactPointRemoved.class,
            msg -&gt; {
              contactPoints.remove(msg.contactPoint());
              // Now do something with an up-to-date &quot;contactPoints&quot;
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Similarly we can have an actor that behaves in a similar fashion for learning what cluster clients are connected to a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/multi-jvm/scala/org/apache/pekko/cluster/client/ClusterClientSpec.scala#L127-L145" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class ReceptionistListener(targetReceptionist: ActorRef) extends Actor {
  override def preStart(): Unit =
    targetReceptionist ! SubscribeClusterClients

  def receive: Receive =
    receiveWithClusterClients(Set.empty)

  def receiveWithClusterClients(clusterClients: Set[ActorRef]): Receive = {
    case ClusterClients(cs) =&gt;
      context.become(receiveWithClusterClients(cs))
    // Now do something with the up-to-date &quot;c&quot;
    case ClusterClientUp(c) =&gt;
      context.become(receiveWithClusterClients(clusterClients + c))
    // Now do something with an up-to-date &quot;clusterClients + c&quot;
    case ClusterClientUnreachable(c) =&gt;
      context.become(receiveWithClusterClients(clusterClients - c))
    // Now do something with an up-to-date &quot;clusterClients - c&quot;
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/test/java/org/apache/pekko/cluster/client/ClusterClientTest.java#L121-L157" target="_blank" title="Go to snippet source">source</a><code class="language-java">public static class ReceptionistListener extends AbstractActor {
  private final ActorRef targetReceptionist;
  private final Set&lt;ActorRef&gt; clusterClients = new HashSet&lt;&gt;();

  public ReceptionistListener(ActorRef targetReceptionist) {
    this.targetReceptionist = targetReceptionist;
  }

  @Override
  public void preStart() {
    targetReceptionist.tell(SubscribeClusterClients.getInstance(), sender());
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            ClusterClients.class,
            msg -&gt; {
              clusterClients.addAll(msg.getClusterClients());
              // Now do something with an up-to-date &quot;clusterClients&quot;
            })
        .match(
            ClusterClientUp.class,
            msg -&gt; {
              clusterClients.add(msg.clusterClient());
              // Now do something with an up-to-date &quot;clusterClients&quot;
            })
        .match(
            ClusterClientUnreachable.class,
            msg -&gt; {
              clusterClients.remove(msg.clusterClient());
              // Now do something with an up-to-date &quot;clusterClients&quot;
            })
        .build();
  }
}</code></pre></dd>
</dl>
<a id="cluster-client-config"></a>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p>The <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientReceptionist.html" title="org.apache.pekko.cluster.client.ClusterClientReceptionist"><code>ClusterClientReceptionist</code></a></span> extension (or <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterReceptionistSettings.html" title="org.apache.pekko.cluster.client.ClusterReceptionistSettings"><code>ClusterReceptionistSettings</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterReceptionistSettings.html" title="org.apache.pekko.cluster.client.ClusterReceptionistSettings"><code>ClusterReceptionistSettings</code></a></span>) can be configured with the following properties:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/main/resources/reference.conf#L57-L91" target="_blank" title="Go to snippet source">source</a><code class="language-conf"># Settings for the ClusterClientReceptionist extension
pekko.cluster.client.receptionist {
  # Actor name of the ClusterReceptionist actor, /system/receptionist
  name = receptionist

  # Start the receptionist on members tagged with this role.
  # All members are used if undefined or empty.
  role = &quot;&quot;

  # The receptionist will send this number of contact points to the client
  number-of-contacts = 3

  # The actor that tunnel response messages to the client will be stopped
  # after this time of inactivity.
  response-tunnel-receive-timeout = 30s
  
  # The id of the dispatcher to use for ClusterReceptionist actors.
  # If specified you need to define the settings of the actual dispatcher.
  use-dispatcher = &quot;pekko.actor.internal-dispatcher&quot;

  # How often failure detection heartbeat messages should be received for
  # each ClusterClient
  heartbeat-interval = 2s

  # Number of potentially lost/delayed heartbeats that will be
  # accepted before considering it to be an anomaly.
  # The ClusterReceptionist is using the org.apache.pekko.remote.DeadlineFailureDetector, which
  # will trigger if there are no heartbeats within the duration
  # heartbeat-interval + acceptable-heartbeat-pause, i.e. 15 seconds with
  # the default settings.
  acceptable-heartbeat-pause = 13s

  # Failure detection checking interval for checking all ClusterClients
  failure-detection-interval = 2s
}</code></pre>
<p>The following configuration properties are read by the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientSettings.html" title="org.apache.pekko.cluster.client.ClusterClientSettings"><code>ClusterClientSettings</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientSettings.html" title="org.apache.pekko.cluster.client.ClusterClientSettings"><code>ClusterClientSettings</code></a></span> when created with a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/actor/ActorSystem.html" title="pekko.actor.ActorSystem"><code>`ActorSystem`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/actor/ActorSystem.html" title="pekko.actor.ActorSystem"><code>`ActorSystem`</code></a></span> parameter. It is also possible to amend the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientSettings.html" title="org.apache.pekko.cluster.client.ClusterClientSettings"><code>ClusterClientSettings</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientSettings.html" title="org.apache.pekko.cluster.client.ClusterClientSettings"><code>ClusterClientSettings</code></a></span> or create it from another config section with the same layout as below. <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientSettings.html" title="org.apache.pekko.cluster.client.ClusterClientSettings"><code>ClusterClientSettings</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/client/ClusterClientSettings.html" title="org.apache.pekko.cluster.client.ClusterClientSettings"><code>ClusterClientSettings</code></a></span> is a parameter to the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/cluster/client/ClusterClient$.html" title="pekko.cluster.client.ClusterClient"><code>`ClusterClient.props`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/cluster/client/ClusterClient$.html" title="pekko.cluster.client.ClusterClient"><code>`ClusterClient.props`</code></a></span> factory method, i.e. each client can be configured with different settings if needed.</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-tools/src/main/resources/reference.conf#L95-L139" target="_blank" title="Go to snippet source">source</a><code class="language-conf"># Settings for the ClusterClient
pekko.cluster.client {
  # Actor paths of the ClusterReceptionist actors on the servers (cluster nodes)
  # that the client will try to contact initially. It is mandatory to specify
  # at least one initial contact. 
  # Comma separated full actor paths defined by a string on the form of
  # &quot;akka://system@hostname:port/system/receptionist&quot;
  initial-contacts = []
  
  # Interval at which the client retries to establish contact with one of 
  # ClusterReceptionist on the servers (cluster nodes)
  establishing-get-contacts-interval = 3s
  
  # Interval at which the client will ask the ClusterReceptionist for
  # new contact points to be used for next reconnect.
  refresh-contacts-interval = 60s
  
  # How often failure detection heartbeat messages should be sent
  heartbeat-interval = 2s
  
  # Number of potentially lost/delayed heartbeats that will be
  # accepted before considering it to be an anomaly.
  # The ClusterClient is using the org.apache.pekko.remote.DeadlineFailureDetector, which
  # will trigger if there are no heartbeats within the duration 
  # heartbeat-interval + acceptable-heartbeat-pause, i.e. 15 seconds with
  # the default settings.
  acceptable-heartbeat-pause = 13s
  
  # If connection to the receptionist is not established the client will buffer
  # this number of messages and deliver them the connection is established.
  # When the buffer is full old messages will be dropped when new messages are sent
  # via the client. Use 0 to disable buffering, i.e. messages will be dropped
  # immediately if the location of the singleton is unknown.
  # Maximum allowed buffer size is 10000.
  buffer-size = 1000

  # If connection to the receiptionist is lost and the client has not been
  # able to acquire a new connection for this long the client will stop itself.
  # This duration makes it possible to watch the cluster client and react on a more permanent
  # loss of connection with the cluster, for example by accessing some kind of
  # service registry for an updated set of initial contacts to start a new cluster client with.
  # If this is not wanted it can be set to &quot;off&quot; to disable the timeout and retry
  # forever.
  reconnect-timeout = off
}</code></pre>
<h2><a href="#failure-handling" name="failure-handling" class="anchor"><span class="anchor-link"></span></a>Failure handling</h2>
<p>When the cluster client is started it must be provided with a list of initial contacts which are cluster nodes where receptionists are running. It will then repeatedly (with an interval configurable by <code>establishing-get-contacts-interval</code>) try to contact those until it gets in contact with one of them. While running, the list of contacts is continuously updated with data from the receptionists (again, with an interval configurable with <code>refresh-contacts-interval</code>), so that if there are more receptionists in the cluster than the initial contacts provided to the client will learn about them.</p>
<p>While the client is running it will detect failures in its connection to the receptionist by heartbeats if more than a configurable amount of heartbeats are missed the client will try to reconnect to its known set of contacts to find a receptionist it can access.</p>
<h2><a href="#when-the-cluster-cannot-be-reached-at-all" name="when-the-cluster-cannot-be-reached-at-all" class="anchor"><span class="anchor-link"></span></a>When the cluster cannot be reached at all</h2>
<p>It is possible to make the cluster client stop entirely if it cannot find a receptionist it can talk to within a configurable interval. This is configured with the <code>reconnect-timeout</code>, which defaults to <code>off</code>. This can be useful when initial contacts are provided from some kind of service registry, cluster node addresses are entirely dynamic and the entire cluster might shut down or crash, be restarted on new addresses. Since the client will be stopped in that case a monitoring actor can watch it and upon <code>Terminate</code> a new set of initial contacts can be fetched and a new cluster client started.</p>
<h2><a href="#migration-to-apache-pekko-grpc" name="migration-to-apache-pekko-grpc" class="anchor"><span class="anchor-link"></span></a>Migration to Apache Pekko gRPC</h2>
<p>Cluster Client is deprecated and it is not advised to build new applications with it. As a replacement, we recommend using <a href="https://pekko.apache.org/docs/pekko-grpc/current/">Pekko gRPC</a> with an application-specific protocol. The benefits of this approach are:</p>
<ul>
  <li>Improved security by using TLS for gRPC (HTTP/2) versus exposing Pekko Remoting outside the Pekko Cluster</li>
  <li>Easier to update clients and servers independent of each other</li>
  <li>Improved protocol definition between client and server</li>
  <li>Usage of <a href="https://pekko.apache.org/docs/pekko-grpc/current/client/configuration.html#using-pekko-discovery-for-endpoint-discovery">Pekko gRPC Service Discovery</a></li>
  <li>Clients do not need to use Pekko</li>
  <li>See also <a href="https://pekko.apache.org/docs/pekko-grpc/current/whygrpc.html#grpc-vs-akka-remoting">gRPC versus Pekko Remoting</a></li>
</ul>
<h3><a href="#migrating-directly" name="migrating-directly" class="anchor"><span class="anchor-link"></span></a>Migrating directly</h3>
<p>Existing users of Cluster Client may migrate directly to Pekko gRPC and use it as documented in <a href="https://pekko.apache.org/docs/pekko-grpc/current/">its documentation</a>.</p>
<h3><a href="#migrating-gradually" name="migrating-gradually" class="anchor"><span class="anchor-link"></span></a>Migrating gradually</h3>
<p>If your application extensively uses Cluster Client, a more gradual migration might be desired that requires less re-write of the application. That migration step is described in this section. We recommend migration directly if feasible, though.</p>
<p>An example is provided to illustrate an approach to migrate from the deprecated Cluster Client to Pekko gRPC, with minimal changes to your existing code. The example is intended to be copied and adjusted to your needs. It will not be provided as a published artifact.</p>
<ul>
  <li><a href="https://github.com/apache/incubator-pekko-samples/tree/2.6/pekko-bom-sample-cluster-client-grpc-scala">pekko-samples/pekko-bom-sample-cluster-cluster-client-grpc-scala</a> implemented in Scala</li>
  <li><a href="https://github.com/apache/incubator-pekko-samples/tree/2.6/pekko-bom-sample-cluster-client-grpc-java">pekko-samples/pekko-bom-sample-cluster-cluster-client-grpc-java</a> implemented in Java</li>
</ul>
<p>The example is still using an actor on the client-side to have an API that is very close to the original Cluster Client. The messages this actor can handle correspond to the <a href="distributed-pub-sub.html">Distributed Pub Sub</a> messages on the server-side, such as <code>ClusterClient.Send</code> and <code>ClusterClient.Publish</code>.</p>
<p>The <code>ClusterClient</code> actor delegates those messages to the gRPC client, and on the server-side those are translated and delegated to the destination actors that are registered via the <code>ClusterClientReceptionist</code> in the same way as in the original.</p>
<p>Pekko gRPC is used as the transport for the messages between client and server, instead of Pekko Remoting.</p>
<p>The application specific messages are wrapped and serialized with Pekko Serialization, which means that care must be taken to keep wire compatibility when changing any messages used between the client and server. The Pekko configuration of Pekko serializers must be the same (or being compatible) on the client and the server.</p>
<h4><a href="#next-steps" name="next-steps" class="anchor"><span class="anchor-link"></span></a>Next steps</h4>
<p>After this first migration step from Cluster Client to Pekko gRPC, you can start replacing calls to <code>ClusterClientReceptionistService</code> with new, application-specific gRPC endpoints.</p>
<h4><a href="#differences" name="differences" class="anchor"><span class="anchor-link"></span></a>Differences</h4>
<p>Aside from the underlying implementation using gRPC instead of Actor messages and Pekko Remoting it&rsquo;s worth pointing out the following differences between the Cluster Client and the example emulating Cluster Client with Pekko gRPC as transport.</p>
<h5><a href="#single-request-reply" name="single-request-reply" class="anchor"><span class="anchor-link"></span></a>Single request-reply</h5>
<p>For request-reply interactions when there is only one reply message for each request it is more efficient to use the <code>ClusterClient.AskSend</code> message instead of <code>ClusterClient.Send</code> as illustrated in the example. Then it doesn&rsquo;t have to setup a full bidirectional gRPC stream for each request but can use the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> based API.</p>
<h5><a href="#initial-contact-points" name="initial-contact-points" class="anchor"><span class="anchor-link"></span></a>Initial contact points</h5>
<p>Instead of configured initial contact points the <a href="https://pekko.apache.org/docs/pekko-grpc/current/client/configuration.html#using-pekko-discovery-for-endpoint-discovery">Pekko gRPC Service Discovery</a> can be used.</p>
<h5><a href="#failure-detection" name="failure-detection" class="anchor"><span class="anchor-link"></span></a>Failure detection</h5>
<p>Heartbeat messages and failure detection of the connections have been removed since that should be handled by the gRPC connections.</p>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/cluster-client.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
2.6.20+81-523134c3+20230202-1514*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="distributed-pub-sub.html" title="Classic Distributed Publish Subscribe in Cluster" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Classic Distributed Publish Subscribe in Cluster
</span>
</div>
</a>
<a href="cluster-sharding.html" title="Classic Cluster Sharding" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Classic Cluster Sharding
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2023 The Apache Software Foundation, Licensed under the Apache License, Version 2.0
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application.583bbe55.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"."}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script src="assets/js/groups.js"></script>
</body>
</html>
