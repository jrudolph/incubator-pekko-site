<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Streams Quickstart Guide Â· Apache Pekko</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko" class="md-header-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko
</span>
<span class="md-header-nav__topic">
Streams Quickstart Guide
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko">
Apache Pekko
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../downloads.html" class="page">Downloads</a></li>
  <li><a href="../documentation.html" class="page">Documentation</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../general/index.html" class="page">General Concepts</a></li>
    <li><a href="../typed/index.html" class="page">Actors</a></li>
    <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
    <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
    <li><a href="../stream/index.html" class="page">Streams</a></li>
    <li><a href="../discovery/index.html" class="page">Discovery</a></li>
    <li><a href="../index-utilities.html" class="page">Utilities</a></li>
    <li><a href="../common/other-modules.html" class="page">Other Apache Pekko modules</a></li>
    <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
    <li><a href="../project/index.html" class="page">Project Information</a></li>
    <li><a href="../index-classic.html" class="page">Pekko Classic</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../stream/stream-quickstart.html#streams-quickstart-guide" class="header">Streams Quickstart Guide</a>
  <ul>
    <li><a href="../stream/stream-quickstart.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-quickstart.html#first-steps" class="header">First steps</a></li>
    <li><a href="../stream/stream-quickstart.html#reusable-pieces" class="header">Reusable Pieces</a></li>
    <li><a href="../stream/stream-quickstart.html#time-based-processing" class="header">Time-Based Processing</a></li>
    <li><a href="../stream/stream-quickstart.html#reactive-tweets" class="header">Reactive Tweets</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 2.6.20+81-523134c3+20230202-1514*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../stream/stream-quickstart.html#streams-quickstart-guide" class="header">Streams Quickstart Guide</a>
  <ul>
    <li><a href="../stream/stream-quickstart.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-quickstart.html#first-steps" class="header">First steps</a></li>
    <li><a href="../stream/stream-quickstart.html#reusable-pieces" class="header">Reusable Pieces</a></li>
    <li><a href="../stream/stream-quickstart.html#time-based-processing" class="header">Time-Based Processing</a></li>
    <li><a href="../stream/stream-quickstart.html#reactive-tweets" class="header">Reactive Tweets</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#streams-quickstart-guide" name="streams-quickstart-guide" class="anchor"><span class="anchor-link"></span></a>Streams Quickstart Guide</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Pekko Streams, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "2.6.20+81-523134c3+20230202-1514-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-stream" % PekkoVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.20+81-523134c3+20230202-1514-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-stream_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:2.6.20+81-523134c3+20230202-1514-SNAPSHOT")

  implementation "org.apache.pekko:pekko-stream_${versions.ScalaBinary}"
}</code></pre></dd></dl><div class="callout note "><div class="callout-title">Note</div>
<p>Both the Java and Scala DSLs of Pekko Streams are bundled in the same JAR. For a smooth development experience, when using an IDE such as Eclipse or IntelliJ, you can disable the auto-importer from suggesting <code>javadsl</code> imports when working in Scala, or viceversa. See <a href="../additional/ide.html">IDE Tips</a>. </p></div>
<h2><a href="#first-steps" name="first-steps" class="anchor"><span class="anchor-link"></span></a>First steps</h2>
<p>A stream usually begins at a source, so this is also how we start a Pekko Stream. Before we create one, we import the full complement of streaming tools:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L17-L19" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.stream._
import pekko.stream.scaladsl._</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/QuickStartDocTest.java#L17-L18" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.stream.*;
import org.apache.pekko.stream.javadsl.*;</code></pre></dd>
</dl>
<p>If you want to execute the code samples while you read through the quick start guide, you will also need the following imports:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L23-L28" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import pekko.{ Done, NotUsed }
import pekko.actor.ActorSystem
import pekko.util.ByteString
import scala.concurrent._
import scala.concurrent.duration._
import java.nio.file.Paths</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/QuickStartDocTest.java#L22-L31" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.Done;
import org.apache.pekko.NotUsed;
import org.apache.pekko.actor.ActorSystem;
import org.apache.pekko.util.ByteString;

import java.nio.file.Paths;
import java.math.BigInteger;
import java.time.Duration;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ExecutionException;</code></pre></dd>
</dl>
<p>And <span class="group-scala">an object</span><span class="group-java">a class</span> to start a Pekko <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span> and hold your code <span class="group-scala">. Making the <code>ActorSystem</code> implicit makes it available to the streams without manually passing it when running them</span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L36-L39" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object Main extends App {
  implicit val system: ActorSystem = ActorSystem(&quot;QuickStart&quot;)
  // Code here
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/Main.java#L19-L24" target="_blank" title="Go to snippet source">source</a><code class="language-java">public class Main {
  public static void main(String[] argv) {
    final ActorSystem system = ActorSystem.create(&quot;QuickStart&quot;);
    // Code here
  }
}</code></pre></dd>
</dl>
<p>Now we will start with a rather simple source, emitting the integers 1 to 100:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L51" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val source: Source[Int, NotUsed] = Source(1 to 100)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/QuickStartDocTest.java#L49" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Source&lt;Integer, NotUsed&gt; source = Source.range(1, 100);</code></pre></dd>
</dl>
<p>The <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source</code></a></span> type is parameterized with two types: the first one is the type of element that this source emits and the second one, the &ldquo;materialized value&rdquo;, allows running the source to produce some auxiliary value (e.g. a network source may provide information about the bound port or the peerâs address). Where no auxiliary information is produced, the type <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/NotUsed.html" title="org.apache.pekko.NotUsed"><code>NotUsed</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/NotUsed.html" title="org.apache.pekko.NotUsed"><code>NotUsed</code></a></span> is used. A simple range of integers falls into this category - running our stream produces a <code>NotUsed</code>.</p>
<p>Having created this source means that we have a description of how to emit the first 100 natural numbers, but this source is not yet active. In order to get those numbers out we have to run it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L55" target="_blank" title="Go to snippet source">source</a><code class="language-scala">source.runForeach(i =&gt; println(i))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/QuickStartDocTest.java#L53" target="_blank" title="Go to snippet source">source</a><code class="language-java">source.runForeach(i -&gt; System.out.println(i), system);</code></pre></dd>
</dl>
<p>This line will complement the source with a consumer functionâin this example we print out the numbers to the consoleâand pass this little stream setup to an Actor that runs it. This activation is signaled by having ârunâ be part of the method name; there are other methods that run Pekko Streams, and they all follow this pattern.</p>
<p>When running this <span class="group-scala">source in a <code>scala.App</code></span><span class="group-java">program</span> you might notice it does not terminate, because the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span> is never terminated. Luckily <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html#runForeach(org.apache.pekko.japi.function.Procedure,org.apache.pekko.stream.Materializer)" title="org.apache.pekko.stream.javadsl.Source"><code>runForeach</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html#runForeach(f:Out=%3EUnit)(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[org.apache.pekko.Done]" title="org.apache.pekko.stream.scaladsl.Source"><code>runForeach</code></a></span> returns a <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a>[<span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/Done.html" title="org.apache.pekko.Done"><code>Done</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/Done.html" title="org.apache.pekko.Done"><code>Done</code></a></span>]</span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a>&lt;<span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/Done.html" title="org.apache.pekko.Done"><code>Done</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/Done.html" title="org.apache.pekko.Done"><code>Done</code></a></span>&gt;</span> which resolves when the stream finishes:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L80-L83" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val done: Future[Done] = source.runForeach(i =&gt; println(i))

implicit val ec = system.dispatcher
done.onComplete(_ =&gt; system.terminate())</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/QuickStartDocTest.java#L81-L83" target="_blank" title="Go to snippet source">source</a><code class="language-java">final CompletionStage&lt;Done&gt; done = source.runForeach(i -&gt; System.out.println(i), system);

done.thenRun(() -&gt; system.terminate());</code></pre></dd>
</dl>
<p>The nice thing about Pekko Streams is that the <code>Source</code> is a description of what you want to run, and like an architectâs blueprint it can be reused, incorporated into a larger design. We may choose to transform the source of integers and write it to a file instead:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L59-L62" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val factorials = source.scan(BigInt(1))((acc, next) =&gt; acc * next)

val result: Future[IOResult] =
  factorials.map(num =&gt; ByteString(s&quot;$num\n&quot;)).runWith(FileIO.toPath(Paths.get(&quot;factorials.txt&quot;)))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/QuickStartDocTest.java#L57-L63" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Source&lt;BigInteger, NotUsed&gt; factorials =
    source.scan(BigInteger.ONE, (acc, next) -&gt; acc.multiply(BigInteger.valueOf(next)));

final CompletionStage&lt;IOResult&gt; result =
    factorials
        .map(num -&gt; ByteString.fromString(num.toString() + &quot;\n&quot;))
        .runWith(FileIO.toPath(Paths.get(&quot;factorials.txt&quot;)), system);</code></pre></dd>
</dl>
<p>First we use the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html#scan(T,org.apache.pekko.japi.function.Function2)" title="org.apache.pekko.stream.javadsl.Source"><code>scan</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html#scan[T](zero:T)(f:(T,Out)=%3ET):FlowOps.this.Repr[T]" title="org.apache.pekko.stream.scaladsl.Source"><code>scan</code></a></span> operator to run a computation over the whole stream: starting with the number 1 (<span class="group-scala"><code>BigInt(1)</code></span><span class="group-java"><code>BigInteger.ONE</code></span>) we multiply by each of the incoming numbers, one after the other; the scan operation emits the initial value and then every calculation result. This yields the series of factorial numbers which we stash away as a <code>Source</code> for later reuseâit is important to keep in mind that nothing is actually computed yet, this is a description of what we want to have computed once we run the stream. Then we convert the resulting series of numbers into a stream of <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span> objects describing lines in a text file. This stream is then run by attaching a file as the receiver of the data. In the terminology of Pekko Streams this is called a <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Sink.html" title="org.apache.pekko.stream.javadsl.Sink"><code>Sink</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Sink.html" title="org.apache.pekko.stream.scaladsl.Sink"><code>Sink</code></a></span>. <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/IOResult.html" title="org.apache.pekko.stream.IOResult"><code>IOResult</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/IOResult.html" title="org.apache.pekko.stream.IOResult"><code>IOResult</code></a></span> is a type that IO operations return in Pekko Streams in order to tell you how many bytes or elements were consumed and whether the stream terminated normally or exceptionally.</p>
<h3><a href="#browser-embedded-example" name="browser-embedded-example" class="anchor"><span class="anchor-link"></span></a>Browser-embedded example</h3>
<a name="here-is-another-example-that-you-can-edit-and-run-in-the-browser-"></a>
<p>Here is another example that you can edit and run in the browser:</p>

        <div data-scalafiddle="true"    data-template="Pekko"   data-minheight="400px"  data-layout="v75" >
          <pre class="prettyprint"><code class="language-scala">import org.apache.pekko
import pekko.NotUsed
import pekko.actor.ActorSystem
import pekko.stream.scaladsl._

final case class Author(handle: String)

final case class Hashtag(name: String)

final case class Tweet(author: Author, timestamp: Long, body: String) {
  def hashtags: Set[Hashtag] =
    body
      .split(" ")
      .collect {
        case t if t.startsWith("#") => Hashtag(t.replaceAll("[^#\\w]", ""))
      }
      .toSet
}

val pekkoTag = Hashtag("#pekko")

val tweets: Source[Tweet, NotUsed] = Source(
  Tweet(Author("rolandkuhn"), System.currentTimeMillis, "#pekko rocks!") ::
  Tweet(Author("patriknw"), System.currentTimeMillis, "#pekko !") ::
  Tweet(Author("bantonsson"), System.currentTimeMillis, "#pekko !") ::
  Tweet(Author("drewhk"), System.currentTimeMillis, "#pekko !") ::
  Tweet(Author("ktosopl"), System.currentTimeMillis, "#pekko on the rocks!") ::
  Tweet(Author("mmartynas"), System.currentTimeMillis, "wow #pekko !") ::
  Tweet(Author("pekkoteam"), System.currentTimeMillis, "#pekko rocks!") ::
  Tweet(Author("bananaman"), System.currentTimeMillis, "#bananas rock!") ::
  Tweet(Author("appleman"), System.currentTimeMillis, "#apples rock!") ::
  Tweet(Author("drama"), System.currentTimeMillis, "we compared #apples to #oranges!") ::
  Nil)

  implicit val system: ActorSystem = ActorSystem("reactive-tweets")

  tweets
    .filterNot(_.hashtags.contains(pekkoTag)) // Remove all tweets containing #pekko hashtag
    .map(_.hashtags) // Get all sets of hashtags ...
    .reduce(_ ++ _) // ... and reduce them to a single set, removing duplicates across all tweets
    .mapConcat(identity) // Flatten the set of hashtags to a stream of hashtags
    .map(_.name.toUpperCase) // Convert all hashtags to upper case
    .runWith(Sink.foreach(println)) // Attach the Flow to a Sink that will finally print the hashtags</code></pre>
        </div>
        <script defer="true" src="https://embed.scalafiddle.io/integration.js"></script>
        
<h2><a href="#reusable-pieces" name="reusable-pieces" class="anchor"><span class="anchor-link"></span></a>Reusable Pieces</h2>

<p>One of the nice parts of Pekko Streamsâand something that other stream libraries do not offerâis that not only sources can be reused like blueprints, all other elements can be as well. We can take the file-writing <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Sink.html" title="org.apache.pekko.stream.javadsl.Sink"><code>Sink</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Sink.html" title="org.apache.pekko.stream.scaladsl.Sink"><code>Sink</code></a></span>, prepend the processing steps necessary to get the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span> elements from incoming strings and package that up as a reusable piece as well. Since the language for writing these streams always flows from left to right (just like plain English), we need a starting point that is like a source but with an âopenâ input. In Pekko Streams, this is called a <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Flow.html" title="org.apache.pekko.stream.javadsl.Flow"><code>Flow</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Flow.html" title="org.apache.pekko.stream.scaladsl.Flow"><code>Flow</code></a></span>:</p>

<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L90-L91" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def lineSink(filename: String): Sink[String, Future[IOResult]] =
  Flow[String].map(s =&gt; ByteString(s + &quot;\n&quot;)).toMat(FileIO.toPath(Paths.get(filename)))(Keep.right)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/QuickStartDocTest.java#L90-L94" target="_blank" title="Go to snippet source">source</a><code class="language-java">public Sink&lt;String, CompletionStage&lt;IOResult&gt;&gt; lineSink(String filename) {
  return Flow.of(String.class)
      .map(s -&gt; ByteString.fromString(s.toString() + &quot;\n&quot;))
      .toMat(FileIO.toPath(Paths.get(filename)), Keep.right());
}</code></pre></dd>
</dl>
<p>Starting from a flow of strings we convert each to <code>ByteString</code> and then feed to the already known file-writing <code>Sink</code>. The resulting blueprint is a <span class="group-scala"><code>Sink[String, Future[IOResult]]</code></span><span class="group-java"><code>Sink&lt;String, CompletionStage&lt;IOResult&gt;&gt;</code></span>, which means that it accepts strings as its input and when materialized it will create auxiliary information of type <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a>[<span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/IOResult.html" title="org.apache.pekko.stream.IOResult"><code>IOResult</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/IOResult.html" title="org.apache.pekko.stream.IOResult"><code>IOResult</code></a></span>]</span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a>&lt;<span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/IOResult.html" title="org.apache.pekko.stream.IOResult"><code>IOResult</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/IOResult.html" title="org.apache.pekko.stream.IOResult"><code>IOResult</code></a></span>&gt;</span> (when chaining operations on a <code>Source</code> or <code>Flow</code> the type of the auxiliary informationâcalled the âmaterialized valueââis given by the leftmost starting point; since we want to retain what the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/FileIO$.html#toPath(java.nio.file.Path)" title="org.apache.pekko.stream.javadsl.FileIO"><code>FileIO.toPath</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/FileIO$.html#toPath(f:java.nio.file.Path,options:Set[java.nio.file.OpenOption],startPosition:Long):org.apache.pekko.stream.scaladsl.Sink[org.apache.pekko.util.ByteString,scala.concurrent.Future[org.apache.pekko.stream.IOResult]]" title="org.apache.pekko.stream.scaladsl.FileIO"><code>FileIO.toPath</code></a></span> sink has to offer, we need to say <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/Keep$.html#right[L,R]:(L,R)=%3ER" title="pekko.stream.scaladsl.Keep"><code>Keep.right</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Keep$.html#right()" title="pekko.stream.javadsl.Keep"><code>Keep.right()</code></a></span>.</p>
<p>We can use the new and shiny <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Sink.html" title="org.apache.pekko.stream.javadsl.Sink"><code>Sink</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Sink.html" title="org.apache.pekko.stream.scaladsl.Sink"><code>Sink</code></a></span> we just created by attaching it to our <code>factorials</code> sourceâafter a small adaptation to turn the numbers into strings:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L66" target="_blank" title="Go to snippet source">source</a><code class="language-scala">factorials.map(_.toString).runWith(lineSink(&quot;factorial2.txt&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/QuickStartDocTest.java#L67" target="_blank" title="Go to snippet source">source</a><code class="language-java">factorials.map(BigInteger::toString).runWith(lineSink(&quot;factorial2.txt&quot;), system);</code></pre></dd>
</dl>
<h2><a href="#time-based-processing" name="time-based-processing" class="anchor"><span class="anchor-link"></span></a>Time-Based Processing</h2>
<p>Before we start looking at a more involved example we explore the streaming nature of what Pekko Streams can do. Starting from the <code>factorials</code> source we transform the stream by zipping it together with another stream, represented by a <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source</code></a></span> that emits the number 0 to 100: the first number emitted by the <code>factorials</code> source is the factorial of zero, the second is the factorial of one, and so on. We combine these two by forming strings like <code>&quot;3! = 6&quot;</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/QuickStartDocSpec.scala#L70-L76" target="_blank" title="Go to snippet source">source</a><code class="language-scala">factorials
  .zipWith(Source(0 to 100))((num, idx) =&gt; s&quot;$idx! = $num&quot;)
  .throttle(1, 1.second)
  .runForeach(println)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/QuickStartDocTest.java#L71-L77" target="_blank" title="Go to snippet source">source</a><code class="language-java">factorials
    .zipWith(Source.range(0, 99), (num, idx) -&gt; String.format(&quot;%d! = %s&quot;, idx, num))
    .throttle(1, Duration.ofSeconds(1))
    .runForeach(s -&gt; System.out.println(s), system);</code></pre></dd>
</dl>
<p>All operations so far have been time-independent and could have been performed in the same fashion on strict collections of elements. The next line demonstrates that we are in fact dealing with streams that can flow at a certain speed: we use the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html#throttle(int,java.time.Duration)" title="org.apache.pekko.stream.javadsl.Source"><code>throttle</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html#throttle(elements:Int,per:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" title="org.apache.pekko.stream.scaladsl.Source"><code>throttle</code></a></span> operator to slow down the stream to 1 element per second.</p>
<p>If you run this program you will see one line printed per second. One aspect that is not immediately visible deserves mention, though: if you try and set the streams to produce a billion numbers each then you will notice that your JVM does not crash with an OutOfMemoryError, even though you will also notice that running the streams happens in the background, asynchronously (this is the reason for the auxiliary information to be provided as a <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a></span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a></span>, in the future). The secret that makes this work is that Pekko Streams implicitly implement pervasive flow control, all operators respect back-pressure. This allows the throttle operator to signal to all its upstream sources of data that it can only accept elements at a certain rateâwhen the incoming rate is higher than one per second the throttle operator will assert <em>back-pressure</em> upstream.</p>
<p>This is all there is to Pekko Streams in a nutshellâglossing over the fact that there are dozens of sources and sinks and many more stream transformation operators to choose from, see also <a href="operators/index.html">operator index</a>.</p>
<h1><a href="#reactive-tweets" name="reactive-tweets" class="anchor"><span class="anchor-link"></span></a>Reactive Tweets</h1>
<p>A typical use case for stream processing is consuming a live stream of data that we want to extract or aggregate some other data from. In this example we&rsquo;ll consider consuming a stream of tweets and extracting information concerning Pekko from them.</p>
<p>We will also consider the problem inherent to all non-blocking streaming solutions: <em>&ldquo;What if the subscriber is too slow to consume the live stream of data?&rdquo;</em>. Traditionally the solution is often to buffer the elements, but this canâand usually willâcause eventual buffer overflows and instability of such systems. Instead Pekko Streams depend on internal backpressure signals that allow to control what should happen in such scenarios.</p>
<p>Here&rsquo;s the data model we&rsquo;ll be working with throughout the quickstart examples:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L39-L53" target="_blank" title="Go to snippet source">source</a><code class="language-scala">final case class Author(handle: String)

final case class Hashtag(name: String)

final case class Tweet(author: Author, timestamp: Long, body: String) {
  def hashtags: Set[Hashtag] =
    body
      .split(&quot; &quot;)
      .collect {
        case t if t.startsWith(&quot;#&quot;) =&gt; Hashtag(t.replaceAll(&quot;[^#\\w]&quot;, &quot;&quot;))
      }
      .toSet
}

val pekkoTag = Hashtag(&quot;#pekko&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L66-L176" target="_blank" title="Go to snippet source">source</a><code class="language-java">public static class Author {
  public final String handle;

  public Author(String handle) {
    this.handle = handle;
  }

  // ...

}

public static class Hashtag {
  public final String name;

  public Hashtag(String name) {
    this.name = name;
  }

  // ...
}

public static class Tweet {
  public final Author author;
  public final long timestamp;
  public final String body;

  public Tweet(Author author, long timestamp, String body) {
    this.author = author;
    this.timestamp = timestamp;
    this.body = body;
  }

  public Set&lt;Hashtag&gt; hashtags() {
    return Arrays.asList(body.split(&quot; &quot;)).stream()
        .filter(a -&gt; a.startsWith(&quot;#&quot;))
        .map(a -&gt; new Hashtag(a))
        .collect(Collectors.toSet());
  }

  // ...
}

public static final Hashtag PEKKO = new Hashtag(&quot;#pekko&quot;);</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>If you would like to get an overview of the used vocabulary first instead of diving head-first into an actual example you can have a look at the <a href="stream-flows-and-basics.html#core-concepts">Core concepts</a> and <a href="stream-flows-and-basics.html#defining-and-running-streams">Defining and running streams</a> sections of the docs, and then come back to this quickstart to see it all pieced together into a simple example application.</p></div>
<h2><a href="#transforming-and-consuming-simple-streams" name="transforming-and-consuming-simple-streams" class="anchor"><span class="anchor-link"></span></a>Transforming and consuming simple streams</h2>
<p>The example application we will be looking at is a simple Twitter feed stream from which we&rsquo;ll want to extract certain information, like for example finding all twitter handles of users who tweet about <code>#pekko</code>.</p>
<p>In order to prepare our environment by creating an <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span> which will be responsible for running the streams we are about to create:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L93" target="_blank" title="Go to snippet source">source</a><code class="language-scala">implicit val system: ActorSystem = ActorSystem(&quot;reactive-tweets&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L209" target="_blank" title="Go to snippet source">source</a><code class="language-java">final ActorSystem system = ActorSystem.create(&quot;reactive-tweets&quot;);</code></pre></dd>
</dl>
<p>Let&rsquo;s assume we have a stream of tweets readily available. In Pekko, this is expressed as a <span class="group-scala"><code>Source[Out, M]</code></span><span class="group-java"><code>Source&lt;Out, M&gt;</code></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L60" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val tweets: Source[Tweet, NotUsed]</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L202" target="_blank" title="Go to snippet source">source</a><code class="language-java">Source&lt;Tweet, NotUsed&gt; tweets;</code></pre></dd>
</dl>
<p>Streams always start flowing from a <span class="group-scala"><code>Source[Out,M1]</code></span><span class="group-java"><code>Source&lt;Out,M1&gt;</code></span> then can continue through <span class="group-scala"><code>Flow[In,Out,M2]</code></span><span class="group-java"><code>Flow&lt;In,Out,M2&gt;</code></span> elements or more advanced operators to finally be consumed by a <span class="group-scala"><code>Sink[In,M3]</code></span><span class="group-java"><code>Sink&lt;In,M3&gt;</code></span> <span class="group-scala">(ignore the type parameters <code>M1</code>, <code>M2</code> and <code>M3</code> for now, they are not relevant to the types of the elements produced/consumed by these classes â they are &ldquo;materialized types&rdquo;, which we&rsquo;ll talk about <a href="stream-quickstart.html#materialized-values-quick">below</a>)</span><span class="group-java">. The first type parameterâ<code>Tweet</code> in this caseâdesignates the kind of elements produced by the source while the <code>M</code> type parameters describe the object that is created during materialization (<a href="#materialized-values-quick">see below</a>)â<code>NotUsed</code> (from the <code>scala.runtime</code> package) means that no value is produced, it is the generic equivalent of <code>void</code>.</span></p>
<p>The operations should look familiar to anyone who has used the Scala Collections library, however they operate on streams and not collections of data (which is a very important distinction, as some operations only make sense in streaming and vice versa):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L104-L105" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val authors: Source[Author, NotUsed] =
  tweets.filter(_.hashtags.contains(pekkoTag)).map(_.author)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L243-L244" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Source&lt;Author, NotUsed&gt; authors =
    tweets.filter(t -&gt; t.hashtags().contains(PEKKO)).map(t -&gt; t.author);</code></pre></dd>
</dl>
<p>Finally in order to <a href="stream-flows-and-basics.html#stream-materialization">materialize</a> and run the stream computation we need to attach the Flow to a <span class="group-scala"><code>Sink</code></span><span class="group-java"><code>Sink&lt;T, M&gt;</code></span> that will get the Flow running. The simplest way to do this is to call <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html#runWith(org.apache.pekko.stream.Graph,org.apache.pekko.actor.ClassicActorSystemProvider)" title="org.apache.pekko.stream.javadsl.Source"><code>runWith(sink)</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html#runWith[Mat2](sink:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(implicitmaterializer:org.apache.pekko.stream.Materializer):Mat2" title="org.apache.pekko.stream.scaladsl.Source"><code>runWith(sink)</code></a></span> on a <span class="group-scala"><code>Source</code></span><span class="group-java"><code>Source&lt;Out, M&gt;</code></span>. For convenience a number of common Sinks are predefined and collected as <span class="group-java">static</span> methods on the <span class="group-scala"><code>Sink</code> companion object</span><span class="group-java"><code>Sink class</code></span>. For now let&rsquo;s print each author:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L119" target="_blank" title="Go to snippet source">source</a><code class="language-scala">authors.runWith(Sink.foreach(println))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L269" target="_blank" title="Go to snippet source">source</a><code class="language-java">authors.runWith(Sink.foreach(a -&gt; System.out.println(a)), system);</code></pre></dd>
</dl>
<p>or by using the shorthand version (which are defined only for the most popular Sinks such as <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Sink$.html#fold(U,org.apache.pekko.japi.function.Function2)" title="org.apache.pekko.stream.javadsl.Sink"><code>Sink.fold</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Sink$.html#fold[U,T](zero:U)(f:(U,T)=%3EU):org.apache.pekko.stream.scaladsl.Sink[T,scala.concurrent.Future[U]]" title="org.apache.pekko.stream.scaladsl.Sink"><code>Sink.fold</code></a></span> and <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Sink$.html#foreach(org.apache.pekko.japi.function.Procedure)" title="org.apache.pekko.stream.javadsl.Sink"><code>Sink.foreach</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Sink$.html#foreach[T](f:T=%3EUnit):org.apache.pekko.stream.scaladsl.Sink[T,scala.concurrent.Future[org.apache.pekko.Done]]" title="org.apache.pekko.stream.scaladsl.Sink"><code>Sink.foreach</code></a></span>):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L124" target="_blank" title="Go to snippet source">source</a><code class="language-scala">authors.runForeach(println)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L274" target="_blank" title="Go to snippet source">source</a><code class="language-java">authors.runForeach(a -&gt; System.out.println(a), system);</code></pre></dd>
</dl>
<p>Materializing and running a stream always requires an <code>ActorSystem</code> to be <span class="group-scala">in implicit scope (or passed in explicitly, like this: <a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/Source.html#runWith[Mat2](sink:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(implicitmaterializer:org.apache.pekko.stream.Materializer):Mat2" title="pekko.stream.scaladsl.Source"><code>.runWith(sink)(system)</code></a>)</span><span class="group-java">passed in explicitly, like this: <a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Source.html#runWith(org.apache.pekko.stream.Graph,org.apache.pekko.stream.Materializer)" title="pekko.stream.javadsl.Source"><code>runWith(sink, system)</code></a></span>.</p>
<p>The complete snippet looks like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L93-L119" target="_blank" title="Go to snippet source">source</a><code class="language-scala">implicit val system: ActorSystem = ActorSystem(&quot;reactive-tweets&quot;)

val authors: Source[Author, NotUsed] =
  tweets.filter(_.hashtags.contains(pekkoTag)).map(_.author)

authors.runWith(Sink.foreach(println))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L209-L269" target="_blank" title="Go to snippet source">source</a><code class="language-java">final ActorSystem system = ActorSystem.create(&quot;reactive-tweets&quot;);

final Source&lt;Author, NotUsed&gt; authors =
    tweets.filter(t -&gt; t.hashtags().contains(PEKKO)).map(t -&gt; t.author);

authors.runWith(Sink.foreach(a -&gt; System.out.println(a)), system);</code></pre></dd>
</dl>
<h2><a href="#flattening-sequences-in-streams" name="flattening-sequences-in-streams" class="anchor"><span class="anchor-link"></span></a>Flattening sequences in streams</h2>
<p>In the previous section we were working on 1:1 relationships of elements which is the most common case, but sometimes we might want to map from one element to a number of elements and receive a &ldquo;flattened&rdquo; stream, similarly like <code>flatMap</code> works on Scala Collections. In order to get a flattened stream of hashtags from our stream of tweets we can use the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html#mapConcat(org.apache.pekko.japi.function.Function)" title="org.apache.pekko.stream.javadsl.Source"><code>mapConcat</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html#mapConcat[T](f:Out=%3EIterableOnce[T]):FlowOps.this.Repr[T]" title="org.apache.pekko.stream.scaladsl.Source"><code>mapConcat</code></a></span> operator:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L130" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val hashtags: Source[Hashtag, NotUsed] = tweets.mapConcat(_.hashtags.toList)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L281-L282" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Source&lt;Hashtag, NotUsed&gt; hashtags =
    tweets.mapConcat(t -&gt; new ArrayList&lt;Hashtag&gt;(t.hashtags()));</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>The name <code>flatMap</code> was consciously avoided due to its proximity with for-comprehensions and monadic composition. It is problematic for two reasons: <span class="group-scala">first</span><span class="group-java">firstly</span>, flattening by concatenation is often undesirable in bounded stream processing due to the risk of deadlock (with merge being the preferred strategy), and <span class="group-scala">second</span><span class="group-java">secondly</span>, the monad laws would not hold for our implementation of flatMap (due to the liveness issues).</p>
<p>Please note that the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html#mapConcat(org.apache.pekko.japi.function.Function)" title="org.apache.pekko.stream.javadsl.Source"><code>mapConcat</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html#mapConcat[T](f:Out=%3EIterableOnce[T]):FlowOps.this.Repr[T]" title="org.apache.pekko.stream.scaladsl.Source"><code>mapConcat</code></a></span> requires the supplied function to return <span class="group-scala">an iterable (<code>f: Out =&gt; immutable.Iterable[T]</code></span><span class="group-java">a strict collection (<code>Out f -&gt; java.util.List&lt;T&gt;</code>)</span>, whereas <code>flatMap</code> would have to operate on streams all the way through.</p></div>
<h2><a href="#broadcasting-a-stream" name="broadcasting-a-stream" class="anchor"><span class="anchor-link"></span></a>Broadcasting a stream</h2>
<p>Now let&rsquo;s say we want to persist all hashtags, as well as all author names from this one live stream. For example we&rsquo;d like to write all author handles into one file, and all hashtags into another file on disk. This means we have to split the source stream into two streams which will handle the writing to these different files.</p>
<p>Elements that can be used to form such &ldquo;fan-out&rdquo; (or &ldquo;fan-in&rdquo;) structures are referred to as &ldquo;junctions&rdquo; in Pekko Streams. One of these that we&rsquo;ll be using in this example is called <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Broadcast$.html" title="org.apache.pekko.stream.javadsl.Broadcast"><code>Broadcast</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Broadcast$.html" title="org.apache.pekko.stream.scaladsl.Broadcast"><code>Broadcast</code></a></span>, and it emits elements from its input port to all of its output ports.</p>
<p>Pekko Streams intentionally separate the linear stream structures (Flows) from the non-linear, branching ones (Graphs) in order to offer the most convenient API for both of these cases. Graphs can express arbitrarily complex stream setups at the expense of not reading as familiarly as collection transformations.</p>
<p>Graphs are constructed using <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/GraphDSL$.html" title="org.apache.pekko.stream.javadsl.GraphDSL"><code>GraphDSL</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/GraphDSL$.html" title="org.apache.pekko.stream.scaladsl.GraphDSL"><code>GraphDSL</code></a></span> like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L136-L156" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val writeAuthors: Sink[Author, NotUsed] = ???
val writeHashtags: Sink[Hashtag, NotUsed] = ???
val g = RunnableGraph.fromGraph(GraphDSL.create() { implicit b =&gt;
  import GraphDSL.Implicits._

  val bcast = b.add(Broadcast[Tweet](2))
  tweets ~&gt; bcast.in
  bcast.out(0) ~&gt; Flow[Tweet].map(_.author) ~&gt; writeAuthors
  bcast.out(1) ~&gt; Flow[Tweet].mapConcat(_.hashtags.toList) ~&gt; writeHashtags
  ClosedShape
})
g.run()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L288-L316" target="_blank" title="Go to snippet source">source</a><code class="language-java">Sink&lt;Author, NotUsed&gt; writeAuthors;
Sink&lt;Hashtag, NotUsed&gt; writeHashtags;
RunnableGraph.fromGraph(
        GraphDSL.create(
            b -&gt; {
              final UniformFanOutShape&lt;Tweet, Tweet&gt; bcast = b.add(Broadcast.create(2));
              final FlowShape&lt;Tweet, Author&gt; toAuthor =
                  b.add(Flow.of(Tweet.class).map(t -&gt; t.author));
              final FlowShape&lt;Tweet, Hashtag&gt; toTags =
                  b.add(
                      Flow.of(Tweet.class)
                          .mapConcat(t -&gt; new ArrayList&lt;Hashtag&gt;(t.hashtags())));
              final SinkShape&lt;Author&gt; authors = b.add(writeAuthors);
              final SinkShape&lt;Hashtag&gt; hashtags = b.add(writeHashtags);

              b.from(b.add(tweets)).viaFanOut(bcast).via(toAuthor).to(authors);
              b.from(bcast).via(toTags).to(hashtags);
              return ClosedShape.getInstance();
            }))
    .run(system);</code></pre></dd>
</dl>
<p>As you can see, <span class="group-scala">inside the <code>GraphDSL</code> we use an implicit graph builder <code>b</code> to mutably construct the graph using the <code>~&gt;</code> &ldquo;edge operator&rdquo; (also read as &ldquo;connect&rdquo; or &ldquo;via&rdquo; or &ldquo;to&rdquo;). The operator is provided implicitly by importing <code>GraphDSL.Implicits._</code></span><span class="group-java">we use graph builder <code>b</code> to construct the graph using <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/UniformFanOutShape.html" title="org.apache.pekko.stream.UniformFanOutShape"><code>UniformFanOutShape</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/UniformFanOutShape.html" title="org.apache.pekko.stream.UniformFanOutShape"><code>UniformFanOutShape</code></a></span> and <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Flow.html" title="org.apache.pekko.stream.javadsl.Flow"><code>Flow</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Flow.html" title="org.apache.pekko.stream.scaladsl.Flow"><code>Flow</code></a></span> s</span>.</p>
<p><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/GraphDSL$.html#create(java.util.List,org.apache.pekko.japi.function.Function2)" title="org.apache.pekko.stream.javadsl.GraphDSL"><code>GraphDSL.create</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/GraphDSL$.html#create[S&lt;:org.apache.pekko.stream.Shape,IS&lt;:org.apache.pekko.stream.Shape,Mat](graphs:Seq[org.apache.pekko.stream.Graph[IS,Mat]])(buildBlock:org.apache.pekko.stream.scaladsl.GraphDSL.Builder[Seq[Mat]]=%3E(Seq[IS]=%3ES)):org.apache.pekko.stream.Graph[S,Seq[Mat]]" title="org.apache.pekko.stream.scaladsl.GraphDSL"><code>GraphDSL.create</code></a></span> returns a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/Graph.html" title="org.apache.pekko.stream.Graph"><code>Graph</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/Graph.html" title="org.apache.pekko.stream.Graph"><code>Graph</code></a></span>, in this example a <span class="group-scala"><code>Graph[ClosedShape, NotUsed]</code></span><span class="group-java"><code>Graph&lt;ClosedShape,NotUsed&gt;</code></span> where <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/ClosedShape.html" title="org.apache.pekko.stream.ClosedShape"><code>ClosedShape</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/ClosedShape.html" title="org.apache.pekko.stream.ClosedShape"><code>ClosedShape</code></a></span> means that it is <em>a fully connected graph</em> or &ldquo;closed&rdquo; - there are no unconnected inputs or outputs. Since it is closed it is possible to transform the graph into a <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/RunnableGraph.html" title="org.apache.pekko.stream.javadsl.RunnableGraph"><code>RunnableGraph</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/RunnableGraph.html" title="org.apache.pekko.stream.scaladsl.RunnableGraph"><code>RunnableGraph</code></a></span> using <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/RunnableGraph$.html#fromGraph(org.apache.pekko.stream.Graph)" title="org.apache.pekko.stream.javadsl.RunnableGraph"><code>RunnableGraph.fromGraph</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/RunnableGraph$.html#fromGraph[Mat](g:stream.Graph[org.apache.pekko.stream.ClosedShape,Mat]):org.apache.pekko.stream.scaladsl.RunnableGraph[Mat]" title="org.apache.pekko.stream.scaladsl.RunnableGraph"><code>RunnableGraph.fromGraph</code></a></span>. The <code>RunnableGraph</code> can then be <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/RunnableGraph.html#run(org.apache.pekko.stream.Materializer)" title="org.apache.pekko.stream.javadsl.RunnableGraph"><code>run()</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/RunnableGraph.html#run()(implicitmaterializer:org.apache.pekko.stream.Materializer):Mat" title="org.apache.pekko.stream.scaladsl.RunnableGraph"><code>run()</code></a></span> to materialize a stream out of it.</p>
<p>Both <code>Graph</code> and <code>RunnableGraph</code> are <em>immutable, thread-safe, and freely shareable</em>.</p>
<p>A graph can also have one of several other shapes, with one or more unconnected ports. Having unconnected ports expresses a graph that is a <em>partial graph</em>. Concepts around composing and nesting graphs in large structures are explained in detail in <a href="stream-composition.html">Modularity, Composition and Hierarchy</a>. It is also possible to wrap complex computation graphs as Flows, Sinks or Sources, which will be explained in detail in <span class="group-scala"><a href="stream-graphs.html#constructing-sources-sinks-flows-from-partial-graphs">Constructing Sources, Sinks and Flows from Partial Graphs</a></span><span class="group-java"><a href="stream-graphs.html#partial-graph-dsl">Constructing and combining Partial Graphs</a></span>.</p>
<h2><a href="#back-pressure-in-action" name="back-pressure-in-action" class="anchor"><span class="anchor-link"></span></a>Back-pressure in action</h2>
<p>One of the main advantages of Pekko Streams is that they <em>always</em> propagate back-pressure information from stream Sinks (Subscribers) to their Sources (Publishers). It is not an optional feature, and is enabled at all times. To learn more about the back-pressure protocol used by Pekko Streams and all other Reactive Streams compatible implementations read <a href="stream-flows-and-basics.html#back-pressure-explained">Back-pressure explained</a>.</p>
<p>A typical problem applications (not using Pekko Streams) like this often face is that they are unable to process the incoming data fast enough, either temporarily or by design, and will start buffering incoming data until there&rsquo;s no more space to buffer, resulting in either <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/OutOfMemoryError.html" title="java.lang.OutOfMemoryError"><code>OutOfMemoryError</code></a> s or other severe degradations of service responsiveness. With Pekko Streams buffering can and must be handled explicitly. For example, if we are only interested in the &ldquo;<em>most recent tweets, with a buffer of 10 elements</em>&rdquo; this can be expressed using the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html#buffer(int,org.apache.pekko.stream.OverflowStrategy)" title="org.apache.pekko.stream.javadsl.Source"><code>buffer</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html#buffer(size:Int,overflowStrategy:org.apache.pekko.stream.OverflowStrategy):FlowOps.this.Repr[Out]" title="org.apache.pekko.stream.scaladsl.Source"><code>buffer</code></a></span> element:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L182" target="_blank" title="Go to snippet source">source</a><code class="language-scala">tweets.buffer(10, OverflowStrategy.dropHead).map(slowComputation).runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L332-L335" target="_blank" title="Go to snippet source">source</a><code class="language-java">tweets
    .buffer(10, OverflowStrategy.dropHead())
    .map(t -&gt; slowComputation(t))
    .runWith(Sink.ignore(), system);</code></pre></dd>
</dl>
<p>The <code>buffer</code> element takes an explicit and required <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/OverflowStrategy.html" title="org.apache.pekko.stream.OverflowStrategy"><code>OverflowStrategy</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/OverflowStrategy.html" title="org.apache.pekko.stream.OverflowStrategy"><code>OverflowStrategy</code></a></span>, which defines how the buffer should react when it receives another element while it is full. Strategies provided include dropping the oldest element (<code>dropHead</code>), dropping the entire buffer, signalling <span class="group-scala">errors</span><span class="group-java">failures</span> etc. Be sure to pick and choose the strategy that fits your use case best.</p>
<a id="materialized-values-quick"></a>
<h2><a href="#materialized-values" name="materialized-values" class="anchor"><span class="anchor-link"></span></a>Materialized values</h2>
<p>So far we&rsquo;ve been only processing data using Flows and consuming it into some kind of external Sink - be it by printing values or storing them in some external system. However sometimes we may be interested in some value that can be obtained from the materialized processing pipeline. For example, we want to know how many tweets we have processed. While this question is not as obvious to give an answer to in case of an infinite stream of tweets (one way to answer this question in a streaming setting would be to create a stream of counts described as &ldquo;<em>up until now</em>, we&rsquo;ve processed N tweets&rdquo;), but in general it is possible to deal with finite streams and come up with a nice result such as a total count of elements.</p>
<p>First, let&rsquo;s write such an element counter using <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/Sink$.html#fold[U,T](zero:U)(f:(U,T)=%3EU):org.apache.pekko.stream.scaladsl.Sink[T,scala.concurrent.Future[U]]" title="pekko.stream.scaladsl.Sink"><code>Sink.fold</code></a> and</span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Flow.html#of(java.lang.Class)" title="pekko.stream.javadsl.Flow"><code>Flow.of(Class)</code></a> and <a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Sink$.html#fold(U,org.apache.pekko.japi.function.Function2)" title="pekko.stream.javadsl.Sink"><code>Sink.fold</code></a> to</span> see how the types look like:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L203-L212" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val count: Flow[Tweet, Int, NotUsed] = Flow[Tweet].map(_ =&gt; 1)

val sumSink: Sink[Int, Future[Int]] = Sink.fold[Int, Int](0)(_ + _)

val counterGraph: RunnableGraph[Future[Int]] =
  tweets.via(count).toMat(sumSink)(Keep.right)

val sum: Future[Int] = counterGraph.run()

sum.foreach(c =&gt; println(s&quot;Total tweets processed: $c&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L342-L351" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Sink&lt;Integer, CompletionStage&lt;Integer&gt;&gt; sumSink =
    Sink.&lt;Integer, Integer&gt;fold(0, (acc, elem) -&gt; acc + elem);

final RunnableGraph&lt;CompletionStage&lt;Integer&gt;&gt; counter =
    tweets.map(t -&gt; 1).toMat(sumSink, Keep.right());

final CompletionStage&lt;Integer&gt; sum = counter.run(system);

sum.thenAcceptAsync(
    c -&gt; System.out.println(&quot;Total tweets processed: &quot; + c), system.dispatcher());</code></pre></dd>
</dl>
<p><span class="group-scala">First we prepare a reusable <code>Flow</code> that will change each incoming tweet into an integer of value <code>1</code>. We&rsquo;ll use this in order to combine those with a <code>Sink.fold</code> that will sum all <code>Int</code> elements of the stream and make its result available as a <code>Future[Int]</code>. Next we connect the <code>tweets</code> stream to <code>count</code> with <code>via</code>. Finally we connect the Flow to the previously prepared Sink using <code>toMat</code></span><span class="group-java"><code>Sink.fold</code> will sum all <code>Integer</code> elements of the stream and make its result available as a <code>CompletionStage&lt;Integer&gt;</code>. Next we use the <code>map</code> method of <code>tweets</code> <code>Source</code> which will change each incoming tweet into an integer value <code>1</code>. Finally we connect the Flow to the previously prepared Sink using <code>toMat</code></span>.</p>
<p>Remember those mysterious <code>Mat</code> type parameters on <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/Source.html" title="pekko.stream.scaladsl.Source"><code>Source</code></a>[+Out, +Mat], <a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/Flow.html" title="pekko.stream.scaladsl.Flow"><code>Flow</code></a>[-In, +Out, +Mat] and <a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/Sink.html" title="pekko.stream.scaladsl.Sink"><code>Sink</code></a>[-In, +Mat]</span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Source.html" title="pekko.stream.javadsl.Source"><code>Source</code></a>&lt;Out, Mat&gt;, <a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Flow.html" title="pekko.stream.javadsl.Flow"><code>Flow</code></a>&lt;In, Out, Mat&gt; and <a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Sink.html" title="pekko.stream.javadsl.Sink"><code>Sink</code></a>&lt;In, Mat&gt;</span>? They represent the type of values these processing parts return when materialized. When you chain these together, you can explicitly combine their materialized values. In our example we used the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/Keep$.html#right[L,R]:(L,R)=%3ER" title="pekko.stream.scaladsl.Keep"><code>Keep.right</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Keep$.html#right()" title="pekko.stream.javadsl.Keep"><code>Keep.right()</code></a></span> predefined function, which tells the implementation to only care about the materialized type of the operator currently appended to the right. The materialized type of <code>sumSink</code> is <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a>[Int]</span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a><Integer></span> and because of using <span class="group-scala"><code>Keep.right</code></span><span class="group-java"><code>Keep.right()</code></span>, the resulting <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/RunnableGraph.html" title="org.apache.pekko.stream.javadsl.RunnableGraph"><code>RunnableGraph</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/RunnableGraph.html" title="org.apache.pekko.stream.scaladsl.RunnableGraph"><code>RunnableGraph</code></a></span> has also a type parameter of <span class="group-scala"><code>Future[Int]</code></span><span class="group-java"><code>CompletionStage&lt;Integer&gt;</code></span>.</p>
<p>This step does <em>not</em> yet materialize the processing pipeline, it merely prepares the description of the Flow, which is now connected to a Sink, and therefore can be <code>run()</code>, as indicated by its type: <span class="group-scala"><code>RunnableGraph[Future[Int]]</code></span><span class="group-java"><code>RunnableGraph&lt;CompletionStage&lt;Integer&gt;&gt;</code></span>. Next we call <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/RunnableGraph.html#run(org.apache.pekko.stream.Materializer)" title="org.apache.pekko.stream.javadsl.RunnableGraph"><code>run()</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/RunnableGraph.html#run()(implicitmaterializer:org.apache.pekko.stream.Materializer):Mat" title="org.apache.pekko.stream.scaladsl.RunnableGraph"><code>run()</code></a></span> which materializes and runs the Flow. The value returned by calling <code>run()</code> on a <span class="group-scala"><code>RunnableGraph[T]</code></span><span class="group-java"><code>RunnableGraph&lt;T&gt;</code></span> is of type <code>T</code>. In our case this type is <span class="group-scala"><code>Future[Int]</code></span><span class="group-java"><code>CompletionStage&lt;Integer&gt;</code></span> which, when completed, will contain the total length of our <code>tweets</code> stream. In case of the stream failing, this future would complete with a Failure.</p>
<p>A <span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/javadsl/RunnableGraph.html" title="org.apache.pekko.stream.javadsl.RunnableGraph"><code>RunnableGraph</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/stream/scaladsl/RunnableGraph.html" title="org.apache.pekko.stream.scaladsl.RunnableGraph"><code>RunnableGraph</code></a></span> may be reused and materialized multiple times, because it is only the &ldquo;blueprint&rdquo; of the stream. This means that if we materialize a stream, for example one that consumes a live stream of tweets within a minute, the materialized values for those two materializations will be different, as illustrated by this example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L226-L234" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val sumSink = Sink.fold[Int, Int](0)(_ + _)
val counterRunnableGraph: RunnableGraph[Future[Int]] =
  tweetsInMinuteFromNow.filter(_.hashtags contains pekkoTag).map(t =&gt; 1).toMat(sumSink)(Keep.right)

// materialize the stream once in the morning
val morningTweetsCount: Future[Int] = counterRunnableGraph.run()
// and once in the evening, reusing the flow
val eveningTweetsCount: Future[Int] = counterRunnableGraph.run()
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L367-L378" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Sink&lt;Integer, CompletionStage&lt;Integer&gt;&gt; sumSink =
    Sink.&lt;Integer, Integer&gt;fold(0, (acc, elem) -&gt; acc + elem);
final RunnableGraph&lt;CompletionStage&lt;Integer&gt;&gt; counterRunnableGraph =
    tweetsInMinuteFromNow
        .filter(t -&gt; t.hashtags().contains(PEKKO))
        .map(t -&gt; 1)
        .toMat(sumSink, Keep.right());

// materialize the stream once in the morning
final CompletionStage&lt;Integer&gt; morningTweetsCount = counterRunnableGraph.run(system);
// and once in the evening, reusing the blueprint
final CompletionStage&lt;Integer&gt; eveningTweetsCount = counterRunnableGraph.run(system);</code></pre></dd>
</dl>
<p>Many elements in Pekko Streams provide materialized values which can be used for obtaining either results of computation or steering these elements which will be discussed in detail in <a href="stream-flows-and-basics.html#stream-materialization">Stream Materialization</a>. Summing up this section, now we know what happens behind the scenes when we run this one-liner, which is equivalent to the multi line version above:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/TwitterStreamQuickstartDocSpec.scala#L217" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val sum: Future[Int] = tweets.map(t =&gt; 1).runWith(sumSink)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/TwitterStreamQuickstartDocTest.java#L356" target="_blank" title="Go to snippet source">source</a><code class="language-java">final CompletionStage&lt;Integer&gt; sum = tweets.map(t -&gt; 1).runWith(sumSink, system);</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p><code>runWith()</code> is a convenience method that automatically ignores the materialized value of any other operators except those appended by the <code>runWith()</code> itself. In the above example it translates to using <span class="group-scala"><code>Keep.right</code></span><span class="group-java"><code>Keep.right()</code></span> as the combiner for materialized values.</p></div>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/stream/stream-quickstart.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
2.6.20+81-523134c3+20230202-1514*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../stream/stream-introduction.html" title="Introduction" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Introduction
</span>
</div>
</a>
<a href="../general/stream/stream-design.html" title="Design Principles behind Apache Pekko Streams" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Design Principles behind Apache Pekko Streams
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2023 The Apache Software Foundation, Licensed under the Apache License, Version 2.0
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script src="../assets/js/groups.js"></script>
</body>
</html>
