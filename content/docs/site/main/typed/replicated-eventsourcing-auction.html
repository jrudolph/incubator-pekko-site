<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Auction example Â· Apache Pekko</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko" class="md-header-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko
</span>
<span class="md-header-nav__topic">
Auction example
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko">
Apache Pekko
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../downloads.html" class="page">Downloads</a></li>
  <li><a href="../documentation.html" class="page">Documentation</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../general/index.html" class="page">General Concepts</a></li>
    <li><a href="../typed/index.html" class="page">Actors</a></li>
    <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
    <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
    <li><a href="../stream/index.html" class="page">Streams</a></li>
    <li><a href="../discovery/index.html" class="page">Discovery</a></li>
    <li><a href="../index-utilities.html" class="page">Utilities</a></li>
    <li><a href="../common/other-modules.html" class="page">Other Apache Pekko modules</a></li>
    <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
    <li><a href="../project/index.html" class="page">Project Information</a></li>
    <li><a href="../index-classic.html" class="page">Pekko Classic</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../typed/replicated-eventsourcing-auction.html#auction-example" class="header">Auction example</a>
  <ul>
    <li><a href="../typed/replicated-eventsourcing-auction.html#triggering-closing" class="header">Triggering closing</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 2.6.20+81-523134c3+20230202-1514*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../typed/replicated-eventsourcing-auction.html#auction-example" class="header">Auction example</a>
  <ul>
    <li><a href="../typed/replicated-eventsourcing-auction.html#triggering-closing" class="header">Triggering closing</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#auction-example" name="auction-example" class="anchor"><span class="anchor-link"></span></a>Auction example</h1>
<p>In this example we want to show that real-world applications can be implemented by designing events in a way that they don&rsquo;t conflict. In the end, you will end up with a solution based on a custom CRDT.</p>
<p>We are building a small auction service. It has the following operations:</p>
<ul>
  <li>Place a bid</li>
  <li>Get the highest bid</li>
  <li>Finish the auction</li>
</ul>
<p>We model those operations as commands to be sent to the auction actor:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleSpec.scala#L51-L60" target="_blank" title="Go to snippet source">source</a><code class="language-scala">type MoneyAmount = Int

case class Bid(bidder: String, offer: MoneyAmount, timestamp: Instant, originReplica: ReplicaId)

sealed trait Command extends CborSerializable
case object Finish extends Command // A timer needs to schedule this event at each replica
final case class OfferBid(bidder: String, offer: MoneyAmount) extends Command
final case class GetHighestBid(replyTo: ActorRef[Bid]) extends Command
final case class IsClosed(replyTo: ActorRef[Boolean]) extends Command
private case object Close extends Command // Internal, should not be sent from the outside</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleTest.java#L121-L169" target="_blank" title="Go to snippet source">source</a><code class="language-java">public static final class Bid {
  public final String bidder;
  public final int offer;
  public final Instant timestamp;
  public final ReplicaId originReplica;

  public Bid(String bidder, int offer, Instant timestamp, ReplicaId originReplica) {
    this.bidder = bidder;
    this.offer = offer;
    this.timestamp = timestamp;
    this.originReplica = originReplica;
  }
}

interface Command extends CborSerializable {}

public enum Finish implements Command {
  INSTANCE
}

public static final class OfferBid implements Command {
  public final String bidder;
  public final int offer;

  public OfferBid(String bidder, int offer) {
    this.bidder = bidder;
    this.offer = offer;
  }
}

public static final class GetHighestBid implements Command {
  public final ActorRef&lt;Bid&gt; replyTo;

  public GetHighestBid(ActorRef&lt;Bid&gt; replyTo) {
    this.replyTo = replyTo;
  }
}

public static final class IsClosed implements Command {
  public final ActorRef&lt;Boolean&gt; replyTo;

  public IsClosed(ActorRef&lt;Boolean&gt; replyTo) {
    this.replyTo = replyTo;
  }
}

private enum Close implements Command {
  INSTANCE
}</code></pre></dd>
</dl>
<p>The events:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleSpec.scala#L64-L68" target="_blank" title="Go to snippet source">source</a><code class="language-scala">sealed trait Event extends CborSerializable
final case class BidRegistered(bid: Bid) extends Event
final case class AuctionFinished(atReplica: ReplicaId) extends Event
final case class WinnerDecided(atReplica: ReplicaId, winningBid: Bid, highestCounterOffer: MoneyAmount)
    extends Event</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleTest.java#L173-L203" target="_blank" title="Go to snippet source">source</a><code class="language-java">interface Event extends CborSerializable {}

public static final class BidRegistered implements Event {
  public final Bid bid;

  @JsonCreator
  public BidRegistered(Bid bid) {
    this.bid = bid;
  }
}

public static final class AuctionFinished implements Event {
  public final ReplicaId atReplica;

  @JsonCreator
  public AuctionFinished(ReplicaId atReplica) {
    this.atReplica = atReplica;
  }
}

public static final class WinnerDecided implements Event {
  public final ReplicaId atReplica;
  public final Bid winningBid;
  public final int amount;

  public WinnerDecided(ReplicaId atReplica, Bid winningBid, int amount) {
    this.atReplica = atReplica;
    this.winningBid = winningBid;
    this.amount = amount;
  }
}</code></pre></dd>
</dl>
<p>The winner does not have to pay the highest bid but only enough to beat the second highest, so the <code>highestCounterOffer</code> is in the <code>AuctionFinished</code> event. </p>
<p>Let&rsquo;s have a look at the auction entity that will handle incoming commands:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleSpec.scala#L195-L241" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def commandHandler(state: AuctionState, command: Command): Effect[Event, AuctionState] = {
  state.phase match {
    case Closing(_) | Closed =&gt;
      command match {
        case GetHighestBid(replyTo) =&gt;
          replyTo ! state.highestBid.copy(offer = state.highestCounterOffer) // TODO this is not as described
          Effect.none
        case IsClosed(replyTo) =&gt;
          replyTo ! (state.phase == Closed)
          Effect.none
        case Finish =&gt;
          context.log.info(&quot;Finish&quot;)
          Effect.persist(AuctionFinished(replicationContext.replicaId))
        case Close =&gt;
          context.log.info(&quot;Close&quot;)
          require(shouldClose(state))
          // TODO send email (before or after persisting)
          Effect.persist(WinnerDecided(replicationContext.replicaId, state.highestBid, state.highestCounterOffer))
        case _: OfferBid =&gt;
          // auction finished, no more bids accepted
          Effect.unhandled
      }
    case Running =&gt;
      command match {
        case OfferBid(bidder, offer) =&gt;
          Effect.persist(
            BidRegistered(
              Bid(
                bidder,
                offer,
                Instant.ofEpochMilli(replicationContext.currentTimeMillis()),
                replicationContext.replicaId)))
        case GetHighestBid(replyTo) =&gt;
          replyTo ! state.highestBid
          Effect.none
        case Finish =&gt;
          Effect.persist(AuctionFinished(replicationContext.replicaId))
        case Close =&gt;
          context.log.warn(&quot;Premature close&quot;)
          // Close should only be triggered when we have already finished
          Effect.unhandled
        case IsClosed(replyTo) =&gt;
          replyTo ! false
          Effect.none
      }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleTest.java#L331-L400" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public CommandHandler&lt;Command, Event, AuctionState&gt; commandHandler() {

  CommandHandlerBuilder&lt;Command, Event, AuctionState&gt; builder = newCommandHandlerBuilder();

  // running
  builder
      .forState(state -&gt; state.stillRunning)
      .onCommand(
          OfferBid.class,
          (state, bid) -&gt;
              Effect()
                  .persist(
                      new BidRegistered(
                          new Bid(
                              bid.bidder,
                              bid.offer,
                              Instant.ofEpochMilli(
                                  this.getReplicationContext().currentTimeMillis()),
                              this.getReplicationContext().replicaId()))))
      .onCommand(
          GetHighestBid.class,
          (state, get) -&gt; {
            get.replyTo.tell(state.highestBid);
            return Effect().none();
          })
      .onCommand(
          Finish.class,
          (state, finish) -&gt;
              Effect().persist(new AuctionFinished(getReplicationContext().replicaId())))
      .onCommand(Close.class, (state, close) -&gt; Effect().unhandled())
      .onCommand(
          IsClosed.class,
          (state, get) -&gt; {
            get.replyTo.tell(false);
            return Effect().none();
          });

  // finished
  builder
      .forAnyState()
      .onCommand(OfferBid.class, (state, bid) -&gt; Effect().unhandled())
      .onCommand(
          GetHighestBid.class,
          (state, get) -&gt; {
            get.replyTo.tell(state.highestBid);
            return Effect().none();
          })
      .onCommand(
          Finish.class,
          (state, finish) -&gt;
              Effect().persist(new AuctionFinished(getReplicationContext().replicaId())))
      .onCommand(
          Close.class,
          (state, close) -&gt;
              Effect()
                  .persist(
                      new WinnerDecided(
                          getReplicationContext().replicaId(),
                          state.highestBid,
                          state.highestCounterOffer)))
      .onCommand(
          IsClosed.class,
          (state, get) -&gt; {
            get.replyTo.tell(state.isClosed());
            return Effect().none();
          });

  return builder.build();
}</code></pre></dd>
</dl>
<p>There is nothing specific to Replicated Event Sourcing about the command handler. It is the same as a command handler for a standard <code>EventSourcedBehavior</code>. For <code>OfferBid</code> and <code>AuctionFinished</code> we do nothing more than to emit events corresponding to the command. For <code>GetHighestBid</code> we respond with details from the state. Note, that we overwrite the actual offer of the highest bid here with the amount of the <code>highestCounterOffer</code>. This is done to follow the popular auction style where the actual highest bid is never publicly revealed.</p>
<p>The auction entity is started with the initial parameters for the auction. The minimum bid is modelled as an <code>initialBid</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleSpec.scala#L46-L299" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object AuctionEntity {

  def apply(
      replica: ReplicaId,
      name: String,
      initialBid: AuctionEntity.Bid, // the initial bid is basically the minimum price bidden at start time by the owner
      closingAt: Instant,
      responsibleForClosing: Boolean,
      allReplicas: Set[ReplicaId]): Behavior[Command] = Behaviors.setup[Command] { ctx =&gt;
    Behaviors.withTimers { timers =&gt;
      ReplicatedEventSourcing.commonJournalConfig(
        ReplicationId(&quot;auction&quot;, name, replica),
        allReplicas,
        PersistenceTestKitReadJournal.Identifier) { replicationCtx =&gt;
        new AuctionEntity(ctx, replicationCtx, timers, closingAt, responsibleForClosing, allReplicas)
          .behavior(initialBid)
      }
    }
  }

}

class AuctionEntity(
    context: ActorContext[AuctionEntity.Command],
    replicationContext: ReplicationContext,
    timers: TimerScheduler[AuctionEntity.Command],
    closingAt: Instant,
    responsibleForClosing: Boolean,
    allReplicas: Set[ReplicaId]) {
  import AuctionEntity._

  private def behavior(initialBid: AuctionEntity.Bid): EventSourcedBehavior[Command, Event, AuctionState] =
    EventSourcedBehavior(
      replicationContext.persistenceId,
      AuctionState(phase = Running, highestBid = initialBid, highestCounterOffer = initialBid.offer),
      commandHandler,
      eventHandler).receiveSignal {
      case (state, RecoveryCompleted) =&gt; recoveryCompleted(state)
    }

  private def recoveryCompleted(state: AuctionState): Unit = {
    if (shouldClose(state))
      context.self ! Close

    val millisUntilClosing = closingAt.toEpochMilli - replicationContext.currentTimeMillis()
    timers.startSingleTimer(Finish, millisUntilClosing.millis)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleTest.java#L103-L454" target="_blank" title="Go to snippet source">source</a><code class="language-java">class AuctionEntity
    extends ReplicatedEventSourcedBehavior&lt;
        AuctionEntity.Command, AuctionEntity.Event, AuctionEntity.AuctionState&gt; {

  public static ReplicaId R1 = new ReplicaId(&quot;R1&quot;);
  public static ReplicaId R2 = new ReplicaId(&quot;R2&quot;);

  public static Set&lt;ReplicaId&gt; ALL_REPLICAS = new HashSet&lt;&gt;(Arrays.asList(R1, R2));

  private final ActorContext&lt;Command&gt; context;
  private final TimerScheduler&lt;Command&gt; timers;
  private final Bid initialBid;
  private final Instant closingAt;
  private final boolean responsibleForClosing;

  public static Behavior&lt;Command&gt; create(
      ReplicaId replica,
      String name,
      Bid initialBid,
      Instant closingAt,
      boolean responsibleForClosing) {
    return Behaviors.setup(
        ctx -&gt;
            Behaviors.withTimers(
                timers -&gt;
                    ReplicatedEventSourcing.commonJournalConfig(
                        new ReplicationId(&quot;Auction&quot;, name, replica),
                        ALL_REPLICAS,
                        PersistenceTestKitReadJournal.Identifier(),
                        replicationCtx -&gt;
                            new AuctionEntity(
                                ctx,
                                replicationCtx,
                                timers,
                                initialBid,
                                closingAt,
                                responsibleForClosing))));
  }

  private AuctionEntity(
      ActorContext&lt;Command&gt; context,
      ReplicationContext replicationContext,
      TimerScheduler&lt;Command&gt; timers,
      Bid initialBid,
      Instant closingAt,
      boolean responsibleForClosing) {
    super(replicationContext);
    this.context = context;
    this.timers = timers;
    this.initialBid = initialBid;
    this.closingAt = closingAt;
    this.responsibleForClosing = responsibleForClosing;
  }

  @Override
  public AuctionState emptyState() {
    return new AuctionState(true, initialBid, initialBid.offer, Collections.emptySet());
  }

  @Override
  public SignalHandler&lt;AuctionState&gt; signalHandler() {
    return newSignalHandlerBuilder()
        .onSignal(RecoveryCompleted.instance(), this::onRecoveryCompleted)
        .build();
  }

  private void onRecoveryCompleted(AuctionState state) {
    if (shouldClose(state)) {
      context.getSelf().tell(Close.INSTANCE);
    }

    long millisUntilClosing =
        closingAt.toEpochMilli() - getReplicationContext().currentTimeMillis();
    timers.startSingleTimer(Finish.INSTANCE, Duration.ofMillis(millisUntilClosing));
  }

}</code></pre></dd>
</dl><div class="group-scala">
<p>The auction moves through the following phases:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleSpec.scala#L72-L95" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * The auction passes through several workflow phases.
 * First, in `Running` `OfferBid` commands are accepted.
 *
 * `AuctionEntity` instances in all DCs schedule a `Finish` command
 * at a given time. That persists the `AuctionFinished` event and the
 * phase is in `Closing` until the auction is finished in all DCs.
 *
 * When the auction has been finished no more `OfferBid` commands are accepted.
 *
 * The auction is also finished immediately if `AuctionFinished` event from another
 * DC is seen before the scheduled `Finish` command. In that way the auction is finished
 * as quickly as possible in all DCs even though there might be some clock skew.
 *
 * One DC is responsible for finally deciding the winner and publishing the result.
 * All events must be collected from all DC before that can happen.
 * When the responsible DC has seen all `AuctionFinished` events from other DCs
 * all other events have also been propagated and it can persist `WinnerDecided` and
 * the auction is finally `Closed`.
 */
sealed trait AuctionPhase
case object Running extends AuctionPhase
final case class Closing(finishedAtReplica: Set[ReplicaId]) extends AuctionPhase
case object Closed extends AuctionPhase</code></pre></dd>
</dl></div>
<p>The closing and closed states are to model waiting for all replicas to see the result of the auction before actually closing the action.</p>
<p>Let&rsquo;s have a look at our state class, <code>AuctionState</code> which also represents the CRDT in our example.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleSpec.scala#L99-L143" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case class AuctionState(phase: AuctionPhase, highestBid: Bid, highestCounterOffer: MoneyAmount)
    extends CborSerializable {

  def applyEvent(event: Event): AuctionState =
    event match {
      case BidRegistered(b) =&gt;
        if (isHigherBid(b, highestBid))
          withNewHighestBid(b)
        else
          withTooLowBid(b)
      case AuctionFinished(atDc) =&gt;
        phase match {
          case Running =&gt;
            copy(phase = Closing(Set(atDc)))
          case Closing(alreadyFinishedDcs) =&gt;
            copy(phase = Closing(alreadyFinishedDcs + atDc))
          case _ =&gt;
            this
        }
      case _: WinnerDecided =&gt;
        copy(phase = Closed)
    }

  def withNewHighestBid(bid: Bid): AuctionState = {
    require(phase != Closed)
    require(isHigherBid(bid, highestBid))
    copy(highestBid = bid, highestCounterOffer = highestBid.offer // keep last highest bid around
    )
  }

  def withTooLowBid(bid: Bid): AuctionState = {
    require(phase != Closed)
    require(isHigherBid(highestBid, bid))
    copy(highestCounterOffer = highestCounterOffer.max(bid.offer)) // update highest counter offer
  }

  def isHigherBid(first: Bid, second: Bid): Boolean =
    first.offer &gt; second.offer ||
    (first.offer == second.offer &amp;&amp; first.timestamp.isBefore(second.timestamp)) || // if equal, first one wins
    // If timestamps are equal, choose by dc where the offer was submitted
    // In real auctions, this last comparison should be deterministic but unpredictable, so that submitting to a
    // particular DC would not be an advantage.
    (first.offer == second.offer &amp;&amp; first.timestamp.equals(second.timestamp) &amp;&amp; first.originReplica.id
      .compareTo(second.originReplica.id) &lt; 0)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleTest.java#L207-L263" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class AuctionState implements CborSerializable {

  final boolean stillRunning;
  final Bid highestBid;
  final int highestCounterOffer;
  final Set&lt;String&gt; finishedAtDc;

  AuctionState(
      boolean stillRunning, Bid highestBid, int highestCounterOffer, Set&lt;String&gt; finishedAtDc) {
    this.stillRunning = stillRunning;
    this.highestBid = highestBid;
    this.highestCounterOffer = highestCounterOffer;
    this.finishedAtDc = finishedAtDc;
  }

  AuctionState withNewHighestBid(Bid bid) {
    assertTrue(stillRunning);
    assertTrue(isHigherBid(bid, highestBid));
    return new AuctionState(
        stillRunning, bid, highestBid.offer, finishedAtDc); // keep last highest bid around
  }

  AuctionState withTooLowBid(Bid bid) {
    assertTrue(stillRunning);
    assertTrue(isHigherBid(highestBid, bid));
    return new AuctionState(
        stillRunning, highestBid, Math.max(highestCounterOffer, bid.offer), finishedAtDc);
  }

  static Boolean isHigherBid(Bid first, Bid second) {
    return first.offer &gt; second.offer
        || (first.offer == second.offer &amp;&amp; first.timestamp.isBefore(second.timestamp))
        || // if equal, first one wins
        // If timestamps are equal, choose by dc where the offer was submitted
        // In real auctions, this last comparison should be deterministic but unpredictable, so
        // that submitting to a
        // particular DC would not be an advantage.
        (first.offer == second.offer
            &amp;&amp; first.timestamp.equals(second.timestamp)
            &amp;&amp; first.originReplica.id().compareTo(second.originReplica.id()) &lt; 0);
  }

  AuctionState addFinishedAtReplica(String replica) {
    Set&lt;String&gt; s = new HashSet&lt;&gt;(finishedAtDc);
    s.add(replica);
    return new AuctionState(
        false, highestBid, highestCounterOffer, Collections.unmodifiableSet(s));
  }

  public AuctionState close() {
    return new AuctionState(false, highestBid, highestCounterOffer, Collections.emptySet());
  }

  public boolean isClosed() {
    return !stillRunning &amp;&amp; finishedAtDc.isEmpty();
  }
}</code></pre></dd>
</dl>
<p>The state consists of a flag that keeps track of whether the auction is still active, the currently highest bid, and the highest counter offer so far.</p>
<p>In the <code>eventHandler</code>, we handle persisted events to drive the state change. When a new bid is registered,</p>
<ul>
  <li>it needs to be decided whether the new bid is the winning bid or not</li>
  <li>the state needs to be updated accordingly</li>
</ul>
<p>The point of CRDTs is that the state must be end up being the same regardless of the order the events have been processed. We can see how this works in the auction example: we are only interested in the highest bid, so, if we can define an ordering on all bids, it should suffice to compare the new bid with currently highest to eventually end up with the globally highest regardless of the order in which the events come in.</p>
<p>The ordering between bids is crucial, therefore. We need to ensure that it is deterministic and does not depend on local state outside of our state class so that all replicas come to the same result. We define the ordering as this:</p>
<ul>
  <li>A higher bid wins.</li>
  <li>If there&rsquo;s a tie between the two highest bids, the bid that was registered earlier wins. For that we keep track of the  (local) timestamp the bid was registered.</li>
  <li>We need to make sure that no timestamp is used twice in the same replica (missing in this example).</li>
  <li>If there&rsquo;s a tie between the timestamp, we define an arbitrary but deterministic ordering on the replicas, in our case  we just compare the name strings of the replicas. That&rsquo;s why we need to keep the identifier of the replica where a bid was registered  for every <code>Bid</code>.</li>
</ul>
<p>If the new bid was higher, we keep this one as the new highest and keep the amount of the former highest as the <code>highestCounterOffer</code>. If the new bid was lower, we just update the <code>highestCounterOffer</code> if necessary.</p>
<p>Using those rules, the order of incoming does not matter. Replicas will eventually converge to the same result.</p>
<h2><a href="#triggering-closing" name="triggering-closing" class="anchor"><span class="anchor-link"></span></a>Triggering closing</h2>
<p>In the auction we want to ensure that all bids are seen before declaring a winner. That means that an auction can only be closed once all replicas have seen all bids.</p>
<p>In the event handler above, when recovery is not running, it calls <code>eventTriggers</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleSpec.scala#L259-L295" target="_blank" title="Go to snippet source">source</a><code class="language-scala">private def eventTriggers(event: Event, newState: AuctionState): Unit = {
  event match {
    case finished: AuctionFinished =&gt;
      newState.phase match {
        case Closing(alreadyFinishedAtDc) =&gt;
          context.log.infoN(
            &quot;AuctionFinished at {}, already finished at [{}]&quot;,
            finished.atReplica,
            alreadyFinishedAtDc.mkString(&quot;, &quot;))
          if (alreadyFinishedAtDc(replicationContext.replicaId)) {
            if (shouldClose(newState)) context.self ! Close
          } else {
            context.log.info(&quot;Sending finish to self&quot;)
            context.self ! Finish
          }

        case _ =&gt; // no trigger for this state
      }
    case _ =&gt; // no trigger for this event
  }
}

private def shouldClose(state: AuctionState): Boolean = {
  responsibleForClosing &amp;&amp; (state.phase match {
    case Closing(alreadyFinishedAtDc) =&gt;
      val allDone = allReplicas.diff(alreadyFinishedAtDc).isEmpty
      if (!allDone) {
        context.log.info2(
          s&quot;Not closing auction as not all DCs have reported finished. All DCs: {}. Reported finished {}&quot;,
          allReplicas,
          alreadyFinishedAtDc)
      }
      allDone
    case _ =&gt;
      false
  })
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedAuctionExampleTest.java#L433-L450" target="_blank" title="Go to snippet source">source</a><code class="language-java">private void eventTriggers(AuctionFinished event, AuctionState newState) {
  if (newState.finishedAtDc.contains(getReplicationContext().replicaId().id())) {
    if (shouldClose(newState)) {
      context.getSelf().tell(Close.INSTANCE);
    }
  } else {
    context.getSelf().tell(Finish.INSTANCE);
  }
}

private boolean shouldClose(AuctionState state) {
  return responsibleForClosing
      &amp;&amp; !state.isClosed()
      &amp;&amp; getReplicationContext().getAllReplicas().stream()
          .map(ReplicaId::id)
          .collect(Collectors.toSet())
          .equals(state.finishedAtDc);
}</code></pre></dd>
</dl>
<p>The event trigger uses the <code>ReplicationContext</code> to decide when to trigger the Finish of the action. When a replica saves the <code>AuctionFinished</code> event it checks whether it should close the auction. For the close to happen the replica must be the one designated to close and all replicas must have reported that they have finished. </p>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/typed/replicated-eventsourcing-auction.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
2.6.20+81-523134c3+20230202-1514*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../typed/replicated-eventsourcing-examples.html" title="Replicated Event Sourcing Examples" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Replicated Event Sourcing Examples
</span>
</div>
</a>
<a href="../typed/replicated-eventsourcing-cart.html" title="Shopping cart example" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Shopping cart example
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2023 The Apache Software Foundation, Licensed under the Apache License, Version 2.0
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script src="../assets/js/groups.js"></script>
</body>
</html>
