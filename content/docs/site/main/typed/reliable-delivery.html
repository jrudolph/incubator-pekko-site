<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Reliable delivery and flow control of messages between actors.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Reliable delivery and flow control of messages between actors.">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Reliable delivery Â· Apache Pekko</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko" class="md-header-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko
</span>
<span class="md-header-nav__topic">
Reliable delivery
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko">
Apache Pekko
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../downloads.html" class="page">Downloads</a></li>
  <li><a href="../documentation.html" class="page">Documentation</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../general/index.html" class="page">General Concepts</a></li>
    <li><a href="../typed/index.html" class="page">Actors</a></li>
    <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
    <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
    <li><a href="../stream/index.html" class="page">Streams</a></li>
    <li><a href="../discovery/index.html" class="page">Discovery</a></li>
    <li><a href="../index-utilities.html" class="page">Utilities</a></li>
    <li><a href="../common/other-modules.html" class="page">Other Apache Pekko modules</a></li>
    <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
    <li><a href="../project/index.html" class="page">Project Information</a></li>
    <li><a href="../index-classic.html" class="page">Pekko Classic</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../typed/reliable-delivery.html#reliable-delivery" class="header">Reliable delivery</a>
  <ul>
    <li><a href="../typed/reliable-delivery.html#module-info" class="header">Module info</a></li>
    <li><a href="../typed/reliable-delivery.html#introduction" class="header">Introduction</a></li>
    <li><a href="../typed/reliable-delivery.html#point-to-point" class="header">Point-to-point</a></li>
    <li><a href="../typed/reliable-delivery.html#work-pulling" class="header">Work pulling</a></li>
    <li><a href="../typed/reliable-delivery.html#sharding" class="header">Sharding</a></li>
    <li><a href="../typed/reliable-delivery.html#durable-producer" class="header">Durable producer</a></li>
    <li><a href="../typed/reliable-delivery.html#ask-from-the-producer" class="header">Ask from the producer</a></li>
    <li><a href="../typed/reliable-delivery.html#only-flow-control" class="header">Only flow control</a></li>
    <li><a href="../typed/reliable-delivery.html#chunk-large-messages" class="header">Chunk large messages</a></li>
    <li><a href="../typed/reliable-delivery.html#configuration" class="header">Configuration</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 2.6.20+81-523134c3+20230202-1514*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../typed/reliable-delivery.html#reliable-delivery" class="header">Reliable delivery</a>
  <ul>
    <li><a href="../typed/reliable-delivery.html#module-info" class="header">Module info</a></li>
    <li><a href="../typed/reliable-delivery.html#introduction" class="header">Introduction</a></li>
    <li><a href="../typed/reliable-delivery.html#point-to-point" class="header">Point-to-point</a></li>
    <li><a href="../typed/reliable-delivery.html#work-pulling" class="header">Work pulling</a></li>
    <li><a href="../typed/reliable-delivery.html#sharding" class="header">Sharding</a></li>
    <li><a href="../typed/reliable-delivery.html#durable-producer" class="header">Durable producer</a></li>
    <li><a href="../typed/reliable-delivery.html#ask-from-the-producer" class="header">Ask from the producer</a></li>
    <li><a href="../typed/reliable-delivery.html#only-flow-control" class="header">Only flow control</a></li>
    <li><a href="../typed/reliable-delivery.html#chunk-large-messages" class="header">Chunk large messages</a></li>
    <li><a href="../typed/reliable-delivery.html#configuration" class="header">Configuration</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#reliable-delivery" name="reliable-delivery" class="anchor"><span class="anchor-link"></span></a>Reliable delivery</h1>
<p>You are viewing the documentation for the new actor APIs, to view the Pekko Classic documentation, see <a href="../persistence.html#at-least-once-delivery">Classic At-Least-Once Delivery</a>.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>This module is currently marked as <a href="../common/may-change.html">may change</a> because it is a new feature that needs feedback from real usage before finalizing the API. This means that API or semantics can change without warning or deprecation period. It is also not recommended to use this module in production just yet.</p></div>
<h2><a href="#module-info" name="module-info" class="anchor"><span class="anchor-link"></span></a>Module info</h2>
<p>To use reliable delivery, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "2.6.20+81-523134c3+20230202-1514-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-actor-typed" % PekkoVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.20+81-523134c3+20230202-1514-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-actor-typed_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:2.6.20+81-523134c3+20230202-1514-SNAPSHOT")

  implementation "org.apache.pekko:pekko-actor-typed_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Normal <a href="../general/message-delivery-reliability.html">message delivery reliability</a> is at-most-once delivery, which means that messages may be lost. That should be rare, but still possible.</p>
<p>For interactions between some actors, that is not acceptable and at-least-once delivery or effectively-once processing is needed. The tools for reliable delivery described here help with implementing that. It can&rsquo;t be achieved automatically under the hood without collaboration from the application. This is because confirming when a message has been fully processed is a business level concern. Only ensuring that it was transferred over the network or delivered to the mailbox of the actor would not be enough, since the actor may crash right before being able to process the message.</p>
<p>Lost messages are detected, resent and deduplicated as needed. In addition, it also includes flow control for the sending of messages to avoid that a fast producer overwhelms a slower consumer or sends messages at a higher rate than what can be transferred over the network. This can be a common problem in interactions between actors, resulting in fatal errors like <code>OutOfMemoryError</code> because too many messages are queued in the mailboxes of the actors. The detection of lost messages and the flow control is driven by the consumer side, which means that the producer side will not send faster than the demand requested by the consumer side. The producer side will not push resends unless requested by the consumer side.</p>
<p>There are 3 supported patterns, which are described in the following sections:</p>
<ul>
  <li><a href="reliable-delivery.html#point-to-point">Point-to-point</a></li>
  <li><a href="reliable-delivery.html#work-pulling">Work pulling</a></li>
  <li><a href="reliable-delivery.html#sharding">Sharding</a></li>
</ul>
<p>The Point-to-Point pattern has support for automatically <a href="reliable-delivery.html#chunk-large-messages">splitting up large messages</a> and assemble them again on the consumer side. This feature is useful for avoiding head of line blocking from serialization and transfer of large messages.</p>
<h2><a href="#point-to-point" name="point-to-point" class="anchor"><span class="anchor-link"></span></a>Point-to-point</h2>
<p>This pattern implements point-to-point reliable delivery between a single producer actor sending messages and a single consumer actor receiving the messages.</p>
<p>Messages are sent from the producer to <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/ProducerController$.html" title="org.apache.pekko.actor.typed.delivery.ProducerController"><code>ProducerController</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/ProducerController$.html" title="org.apache.pekko.actor.typed.delivery.ProducerController"><code>ProducerController</code></a></span> and via <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/ConsumerController$.html" title="org.apache.pekko.actor.typed.delivery.ConsumerController"><code>ConsumerController</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/ConsumerController$.html" title="org.apache.pekko.actor.typed.delivery.ConsumerController"><code>ConsumerController</code></a></span> actors, which handle the delivery and confirmation of the processing in the destination consumer actor.</p>
<p><img src="./images/delivery-p2p-1.png" alt="delivery-p2p-1.png" /></p>
<p>The producer actor will start the flow by sending a <code>ProducerController.Start</code> message to the <code>ProducerController</code>.</p>
<p>The <code>ProducerController</code> sends <code>RequestNext</code> to the producer, which is then allowed to send one message to the <code>ProducerController</code>. Thereafter the producer will receive a new <code>RequestNext</code> when it&rsquo;s allowed to send one more message.</p>
<p>The producer and <code>ProducerController</code> actors are required to be local so that message delivery is both fast and guaranteed. This requirement is enforced by a runtime check.</p>
<p>Similarly, on the consumer side the destination consumer actor will start the flow by sending an initial <code>ConsumerController.Start</code> message to the <code>ConsumerController</code>. </p>
<p>For the <code>ProducerController</code> to know where to send the messages, it must be connected with the <code>ConsumerController</code>. This can be done with the <code>ProducerController.RegisterConsumer</code> or <code>ConsumerController.RegisterToProducerController</code> messages. When using the point-to-point pattern, it is the application&rsquo;s responsibility to connect them together. For example, this can be done by sending the <code>ActorRef</code> in an ordinary message to the other side, or by registering the <code>ActorRef</code> in the <a href="actor-discovery.html">Receptionist</a> so it can be found on the other side.</p>
<p>You must also take measures to reconnect them if any of the sides crashes, for example by watching it for termination.</p>
<p>Messages sent by the producer are wrapped in <code>ConsumerController.Delivery</code> when received by a consumer and the consumer should reply with <code>ConsumerController.Confirmed</code> when it has processed the message.</p>
<p>The next message is not delivered until the previous one is confirmed. Any messages from the producer that arrive while waiting for the confirmation are stashed by the <code>ConsumerController</code> and delivered when the previous message is confirmed.</p>
<p>Similar to the producer side, the consumer and the <code>ConsumerController</code> actors are required to be local so that message delivery is both fast and guaranteed. This requirement is enforced by a runtime check.</p>
<p>Many unconfirmed messages can be in flight between the <code>ProducerController</code> and <code>ConsumerController</code>, but their number is limited by a flow control window. The flow control is driven by the consumer side, which means that the <code>ProducerController</code> will not send faster than the demand requested by the <code>ConsumerController</code>.</p>
<h3><a href="#point-to-point-example" name="point-to-point-example" class="anchor"><span class="anchor-link"></span></a>Point-to-point example</h3>
<p>An example of a fibonacci number generator (producer):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/delivery/PointToPointDocExample.scala#L23-L28" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.typed.ActorRef
import pekko.actor.typed.Behavior
import pekko.actor.typed.delivery.ProducerController
import pekko.actor.typed.scaladsl.Behaviors

object FibonacciProducer {
  sealed trait Command

  private case class WrappedRequestNext(r: ProducerController.RequestNext[FibonacciConsumer.Command]) extends Command

  def apply(
      producerController: ActorRef[ProducerController.Command[FibonacciConsumer.Command]]): Behavior[Command] = {
    Behaviors.setup { context =&gt;
      val requestNextAdapter =
        context.messageAdapter[ProducerController.RequestNext[FibonacciConsumer.Command]](WrappedRequestNext(_))
      producerController ! ProducerController.Start(requestNextAdapter)

      fibonacci(0, 1, 0)
    }
  }

  private def fibonacci(n: Long, b: BigInt, a: BigInt): Behavior[Command] = {
    Behaviors.receive {
      case (context, WrappedRequestNext(next)) =&gt;
        context.log.info(&quot;Generated fibonacci {}: {}&quot;, n, a)
        next.sendNextTo ! FibonacciConsumer.FibonacciNumber(n, a)

        if (n == 1000)
          Behaviors.stopped
        else
          fibonacci(n + 1, a + b, b)
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/PointToPointDocExample.java#L17-L26" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.ActorRef;
import org.apache.pekko.actor.typed.Behavior;
import org.apache.pekko.actor.typed.delivery.ProducerController;
import org.apache.pekko.actor.typed.javadsl.AbstractBehavior;
import org.apache.pekko.actor.typed.javadsl.ActorContext;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.actor.typed.javadsl.Receive;
import java.math.BigInteger;
import java.util.Optional;

public class FibonacciProducer extends AbstractBehavior&lt;FibonacciProducer.Command&gt; {

  private long n = 0;
  private BigInteger b = BigInteger.ONE;
  private BigInteger a = BigInteger.ZERO;

  interface Command {}

  private static class WrappedRequestNext implements Command {
    final ProducerController.RequestNext&lt;FibonacciConsumer.Command&gt; next;

    private WrappedRequestNext(ProducerController.RequestNext&lt;FibonacciConsumer.Command&gt; next) {
      this.next = next;
    }
  }

  private FibonacciProducer(ActorContext&lt;Command&gt; context) {
    super(context);
  }

  public static Behavior&lt;Command&gt; create(
      ActorRef&lt;ProducerController.Command&lt;FibonacciConsumer.Command&gt;&gt; producerController) {
    return Behaviors.setup(
        context -&gt; {
          ActorRef&lt;ProducerController.RequestNext&lt;FibonacciConsumer.Command&gt;&gt; requestNextAdapter =
              context.messageAdapter(
                  ProducerController.requestNextClass(), WrappedRequestNext::new);
          producerController.tell(new ProducerController.Start&lt;&gt;(requestNextAdapter));

          return new FibonacciProducer(context);
        });
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(WrappedRequestNext.class, w -&gt; onWrappedRequestNext(w))
        .build();
  }

  private Behavior&lt;Command&gt; onWrappedRequestNext(WrappedRequestNext w) {
    getContext().getLog().info(&quot;Generated fibonacci {}: {}&quot;, n, a);
    w.next.sendNextTo().tell(new FibonacciConsumer.FibonacciNumber(n, a));

    if (n == 1000) {
      return Behaviors.stopped();
    } else {
      n = n + 1;
      b = a.add(b);
      a = b;
      return this;
    }
  }
}</code></pre></dd>
</dl>
<p>and consumer of the fibonacci numbers:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/delivery/PointToPointDocExample.scala#L67-L91" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import pekko.actor.typed.delivery.ConsumerController

object FibonacciConsumer {
  sealed trait Command

  final case class FibonacciNumber(n: Long, value: BigInt) extends Command

  private case class WrappedDelivery(d: ConsumerController.Delivery[Command]) extends Command

  def apply(
      consumerController: ActorRef[ConsumerController.Command[FibonacciConsumer.Command]]): Behavior[Command] = {
    Behaviors.setup { context =&gt;
      val deliveryAdapter =
        context.messageAdapter[ConsumerController.Delivery[FibonacciConsumer.Command]](WrappedDelivery(_))
      consumerController ! ConsumerController.Start(deliveryAdapter)

      Behaviors.receiveMessagePartial {
        case WrappedDelivery(ConsumerController.Delivery(FibonacciNumber(n, value), confirmTo)) =&gt;
          context.log.info(&quot;Processed fibonacci {}: {}&quot;, n, value)
          confirmTo ! ConsumerController.Confirmed
          Behaviors.same
      }
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/PointToPointDocExample.java#L30-L147" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.delivery.ConsumerController;

public class FibonacciConsumer extends AbstractBehavior&lt;FibonacciConsumer.Command&gt; {

  interface Command {}

  public static class FibonacciNumber implements Command {
    public final long n;
    public final BigInteger value;

    public FibonacciNumber(long n, BigInteger value) {
      this.n = n;
      this.value = value;
    }
  }

  private static class WrappedDelivery implements Command {
    final ConsumerController.Delivery&lt;Command&gt; delivery;

    private WrappedDelivery(ConsumerController.Delivery&lt;Command&gt; delivery) {
      this.delivery = delivery;
    }
  }

  public static Behavior&lt;Command&gt; create(
      ActorRef&lt;ConsumerController.Command&lt;FibonacciConsumer.Command&gt;&gt; consumerController) {
    return Behaviors.setup(
        context -&gt; {
          ActorRef&lt;ConsumerController.Delivery&lt;FibonacciConsumer.Command&gt;&gt; deliveryAdapter =
              context.messageAdapter(ConsumerController.deliveryClass(), WrappedDelivery::new);
          consumerController.tell(new ConsumerController.Start&lt;&gt;(deliveryAdapter));

          return new FibonacciConsumer(context);
        });
  }

  private FibonacciConsumer(ActorContext&lt;Command&gt; context) {
    super(context);
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder().onMessage(WrappedDelivery.class, this::onDelivery).build();
  }

  private Behavior&lt;Command&gt; onDelivery(WrappedDelivery w) {
    FibonacciNumber number = (FibonacciNumber) w.delivery.message();
    getContext().getLog().info(&quot;Processed fibonacci {}: {}&quot;, number.n, number.value);
    w.delivery.confirmTo().tell(ConsumerController.confirmed());
    return this;
  }
}</code></pre></dd>
</dl>
<p>The <code>FibonacciProducer</code> sends the messages to a <code>ProducerController</code>. The <code>FibonacciConsumer</code> receives the messages from a <code>ConsumerController</code>. Note how the <code>ActorRef</code> in the <code>Start</code> messages are constructed as message adapters to map the <code>RequestNext</code> and <code>Delivery</code> to the protocol of the producer and consumer actors respectively.</p>
<p>The <code>ConsumerController</code> and <code>ProducerController</code> are connected via the <code>ConsumerController.RegisterToProducerController</code> message. The <code>ActorRef</code> of the <code>ProducerController</code> can be shared between producer and consumer sides with ordinary messages, or by using the <code>Receptionist</code>. Alternatively, they can be connected in the other direction by sending <code>ProducerController.RegisterConsumer</code> to the <code>ProducerController</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/delivery/PointToPointDocExample.scala#L98-L107" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val consumerController = context.spawn(ConsumerController[FibonacciConsumer.Command](), &quot;consumerController&quot;)
context.spawn(FibonacciConsumer(consumerController), &quot;consumer&quot;)

val producerId = s&quot;fibonacci-${UUID.randomUUID()}&quot;
val producerController = context.spawn(
  ProducerController[FibonacciConsumer.Command](producerId, durableQueueBehavior = None),
  &quot;producerController&quot;)
context.spawn(FibonacciProducer(producerController), &quot;producer&quot;)

consumerController ! ConsumerController.RegisterToProducerController(producerController)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/PointToPointDocExample.java#L155-L168" target="_blank" title="Go to snippet source">source</a><code class="language-java">ActorRef&lt;ConsumerController.Command&lt;FibonacciConsumer.Command&gt;&gt; consumerController =
    context.spawn(ConsumerController.create(), &quot;consumerController&quot;);
context.spawn(FibonacciConsumer.create(consumerController), &quot;consumer&quot;);

String producerId = &quot;fibonacci-&quot; + UUID.randomUUID();
ActorRef&lt;ProducerController.Command&lt;FibonacciConsumer.Command&gt;&gt; producerController =
    context.spawn(
        ProducerController.create(
            FibonacciConsumer.Command.class, producerId, Optional.empty()),
        &quot;producerController&quot;);
context.spawn(FibonacciProducer.create(producerController), &quot;producer&quot;);

consumerController.tell(
    new ConsumerController.RegisterToProducerController&lt;&gt;(producerController));</code></pre></dd>
</dl>
<h3><a href="#point-to-point-delivery-semantics" name="point-to-point-delivery-semantics" class="anchor"><span class="anchor-link"></span></a>Point-to-point delivery semantics</h3>
<p>As long as neither producer nor consumer crash, the messages are delivered to the consumer actor in the same order as they were sent to the <code>ProducerController</code>, without loss or duplicates. This means effectively-once processing without any business level deduplication.</p>
<p>Unconfirmed messages may be lost if the producer crashes. To avoid that, you need to enable the <a href="reliable-delivery.html#durable-producer">durable queue</a> on the producer side. By doing so, any stored unconfirmed messages will be redelivered when the corresponding producer is started again. Even if the same <code>ConsumerController</code> instance is used, there may be delivery of messages that had already been processed but the fact that they were confirmed had not been stored yet. This means that we have at-least-once delivery.</p>
<p>If the consumer crashes, a new <code>ConsumerController</code> can be connected to the original <code>ProducerConsumer</code> without restarting it. The <code>ProducerConsumer</code> will then redeliver all unconfirmed messages. In that case the unconfirmed messages will be delivered to the new consumer and some of these may already have been processed by the previous consumer. Again, this means that we have at-least-once delivery.</p>
<h2><a href="#work-pulling" name="work-pulling" class="anchor"><span class="anchor-link"></span></a>Work pulling</h2>
<p>Work pulling is a pattern where several worker actors pull tasks at their own pace from a shared work manager instead of that the manager pushes work to the workers blindly without knowing their individual capacity and current availability.</p>
<p>One important property is that the order of the messages should not matter, because each message is routed randomly to one of the workers with demand. In other words, two subsequent messages may be routed to two different workers and processed independent of each other.</p>
<p>Messages are sent from the producer to <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/WorkPullingProducerController$.html" title="org.apache.pekko.actor.typed.delivery.WorkPullingProducerController"><code>WorkPullingProducerController</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/WorkPullingProducerController$.html" title="org.apache.pekko.actor.typed.delivery.WorkPullingProducerController"><code>WorkPullingProducerController</code></a></span> and via <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/ConsumerController$.html" title="org.apache.pekko.actor.typed.delivery.ConsumerController"><code>ConsumerController</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/ConsumerController$.html" title="org.apache.pekko.actor.typed.delivery.ConsumerController"><code>ConsumerController</code></a></span> actors, which handle the delivery and confirmation of the processing in the destination worker (consumer) actor.</p>
<p><img src="./images/delivery-work-pulling-1.png" alt="delivery-work-pulling-1.png" /></p>
<p>and adding another worker</p>
<p><img src="./images/delivery-work-pulling-2.png" alt="delivery-work-pulling-2.png" /></p>
<p>A worker actor (consumer) and its <code>ConsumerController</code> is dynamically registered to the <code>WorkPullingProducerController</code> via a <code>ServiceKey</code>. It will register itself to the <a href="actor-discovery.html">Receptionist</a>, and the <code>WorkPullingProducerController</code> subscribes to the same key to find active workers. In this way workers can be dynamically added or removed from any node in the cluster.</p>
<p>The work manager (producer) actor will start the flow by sending a <code>WorkPullingProducerController.Start</code> message to the <code>WorkPullingProducerController</code>.</p>
<p>The <code>WorkPullingProducerController</code> sends <code>RequestNext</code> to the producer, which is then allowed to send one message to the <code>WorkPullingProducerController</code>. Thereafter the producer will receive a new <code>RequestNext</code> when it&rsquo;s allowed to send one more message. <code>WorkPullingProducerController</code> will send a new <code>RequestNext</code> when there is a demand from any worker. It&rsquo;s possible that all workers with demand are deregistered after the <code>RequestNext</code> is sent and before the actual messages is sent to the <code>WorkPullingProducerController</code>. In that case the message is buffered and will be delivered when a new worker is registered or when there is a new demand.</p>
<p>The producer and <code>WorkPullingProducerController</code> actors are supposed to be local so that these messages are fast and not lost. This is enforced by a runtime check.</p>
<p>Similarly, on the consumer side the destination consumer actor will start the flow by sending an initial <code>ConsumerController.Start</code> message to the <code>ConsumerController</code>.</p>
<p>Received messages from the producer are wrapped in <code>ConsumerController.Delivery</code> when sent to the consumer, which is supposed to reply with <code>ConsumerController.Confirmed</code> when it has processed the message. Next message is not delivered until the previous is confirmed. More messages from the producer that arrive while waiting for the confirmation are stashed by the <code>ConsumerController</code> and delivered when the previous message is confirmed.</p>
<p>The consumer and the <code>ConsumerController</code> actors are supposed to be local so that these messages are fast and not lost. This is enforced by a runtime check.</p>
<p>Many unconfirmed messages can be in flight between the <code>WorkPullingProducerController</code> and each <code>ConsumerController</code>, but it is limited by a flow control window. The flow control is driven by the consumer side, which means that the <code>WorkPullingProducerController</code> will not send faster than the demand requested by the workers.</p>
<h3><a href="#work-pulling-example" name="work-pulling-example" class="anchor"><span class="anchor-link"></span></a>Work pulling example</h3>
<p>Example of image converter worker (consumer):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/delivery/WorkPullingDocExample.scala#L31-L33" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.typed.scaladsl.Behaviors
import pekko.actor.typed.Behavior
import pekko.actor.typed.delivery.ConsumerController
import pekko.actor.typed.receptionist.ServiceKey

object ImageConverter {
  sealed trait Command
  final case class ConversionJob(resultId: UUID, fromFormat: String, toFormat: String, image: Array[Byte])
  private case class WrappedDelivery(d: ConsumerController.Delivery[ConversionJob]) extends Command

  val serviceKey = ServiceKey[ConsumerController.Command[ConversionJob]](&quot;ImageConverter&quot;)

  def apply(): Behavior[Command] = {
    Behaviors.setup { context =&gt;
      val deliveryAdapter =
        context.messageAdapter[ConsumerController.Delivery[ConversionJob]](WrappedDelivery(_))
      val consumerController =
        context.spawn(ConsumerController(serviceKey), &quot;consumerController&quot;)
      consumerController ! ConsumerController.Start(deliveryAdapter)

      Behaviors.receiveMessage {
        case WrappedDelivery(delivery) =&gt;
          val image = delivery.message.image
          val fromFormat = delivery.message.fromFormat
          val toFormat = delivery.message.toFormat
          // convert image...
          // store result with resultId key for later retrieval

          // and when completed confirm
          delivery.confirmTo ! ConsumerController.Confirmed

          Behaviors.same
      }

    }
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/WorkPullingDocExample.java#L17-L27" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.ActorRef;
import org.apache.pekko.actor.typed.Behavior;
import org.apache.pekko.actor.typed.delivery.ConsumerController;
import org.apache.pekko.actor.typed.delivery.DurableProducerQueue;
import org.apache.pekko.actor.typed.javadsl.ActorContext;
import org.apache.pekko.actor.typed.javadsl.Behaviors;

import java.time.Duration;
import java.util.Optional;
import java.util.UUID;

public class ImageConverter {
  interface Command {}

  public static class ConversionJob {
    public final UUID resultId;
    public final String fromFormat;
    public final String toFormat;
    public final byte[] image;

    public ConversionJob(UUID resultId, String fromFormat, String toFormat, byte[] image) {
      this.resultId = resultId;
      this.fromFormat = fromFormat;
      this.toFormat = toFormat;
      this.image = image;
    }
  }

  private static class WrappedDelivery implements Command {
    final ConsumerController.Delivery&lt;ConversionJob&gt; delivery;

    private WrappedDelivery(ConsumerController.Delivery&lt;ConversionJob&gt; delivery) {
      this.delivery = delivery;
    }
  }

  public static ServiceKey&lt;ConsumerController.Command&lt;ConversionJob&gt;&gt; serviceKey =
      ServiceKey.create(ConsumerController.serviceKeyClass(), &quot;ImageConverter&quot;);

  public static Behavior&lt;Command&gt; create() {
    return Behaviors.setup(
        context -&gt; {
          ActorRef&lt;ConsumerController.Delivery&lt;ConversionJob&gt;&gt; deliveryAdapter =
              context.messageAdapter(ConsumerController.deliveryClass(), WrappedDelivery::new);
          ActorRef&lt;ConsumerController.Command&lt;ConversionJob&gt;&gt; consumerController =
              context.spawn(ConsumerController.create(serviceKey), &quot;consumerController&quot;);
          consumerController.tell(new ConsumerController.Start&lt;&gt;(deliveryAdapter));

          return Behaviors.receive(Command.class)
              .onMessage(WrappedDelivery.class, ImageConverter::onDelivery)
              .build();
        });
  }

  private static Behavior&lt;Command&gt; onDelivery(WrappedDelivery w) {
    byte[] image = w.delivery.message().image;
    String fromFormat = w.delivery.message().fromFormat;
    String toFormat = w.delivery.message().toFormat;
    // convert image...
    // store result with resultId key for later retrieval

    // and when completed confirm
    w.delivery.confirmTo().tell(ConsumerController.confirmed());

    return Behaviors.same();
  }
}</code></pre></dd>
</dl>
<p>and image converter job manager (producer):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/delivery/WorkPullingDocExample.scala#L76-L243" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.typed.delivery.WorkPullingProducerController
import pekko.actor.typed.scaladsl.ActorContext
import pekko.actor.typed.scaladsl.StashBuffer

object ImageWorkManager {
  sealed trait Command
  final case class Convert(fromFormat: String, toFormat: String, image: Array[Byte]) extends Command
  private case class WrappedRequestNext(r: WorkPullingProducerController.RequestNext[ImageConverter.ConversionJob])
      extends Command

  final case class GetResult(resultId: UUID, replyTo: ActorRef[Option[Array[Byte]]]) extends Command

  def apply(): Behavior[Command] = {
    Behaviors.setup { context =&gt;
      val requestNextAdapter =
        context.messageAdapter[WorkPullingProducerController.RequestNext[ImageConverter.ConversionJob]](
          WrappedRequestNext(_))
      val producerController = context.spawn(
        WorkPullingProducerController(
          producerId = &quot;workManager&quot;,
          workerServiceKey = ImageConverter.serviceKey,
          durableQueueBehavior = None),
        &quot;producerController&quot;)
      producerController ! WorkPullingProducerController.Start(requestNextAdapter)

      Behaviors.withStash(1000) { stashBuffer =&gt;
        new ImageWorkManager(context, stashBuffer).waitForNext()
      }
    }
  }

}

final class ImageWorkManager(
    context: ActorContext[ImageWorkManager.Command],
    stashBuffer: StashBuffer[ImageWorkManager.Command]) {

  import ImageWorkManager._

  private def waitForNext(): Behavior[Command] = {
    Behaviors.receiveMessagePartial {
      case WrappedRequestNext(next) =&gt;
        stashBuffer.unstashAll(active(next))
      case c: Convert =&gt;
        if (stashBuffer.isFull) {
          context.log.warn(&quot;Too many Convert requests.&quot;)
          Behaviors.same
        } else {
          stashBuffer.stash(c)
          Behaviors.same
        }
      case GetResult(resultId, replyTo) =&gt;
        // TODO retrieve the stored result and reply
        Behaviors.same
    }
  }

  private def active(
      next: WorkPullingProducerController.RequestNext[ImageConverter.ConversionJob]): Behavior[Command] = {
    Behaviors.receiveMessagePartial {
      case Convert(from, to, image) =&gt;
        val resultId = UUID.randomUUID()
        next.sendNextTo ! ImageConverter.ConversionJob(resultId, from, to, image)
        waitForNext()
      case GetResult(resultId, replyTo) =&gt;
        // TODO retrieve the stored result and reply
        Behaviors.same
      case _: WrappedRequestNext =&gt;
        throw new IllegalStateException(&quot;Unexpected RequestNext&quot;)
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/WorkPullingDocExample.java#L31-L370" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.delivery.WorkPullingProducerController;
import org.apache.pekko.Done;

public class ImageWorkManager {

  interface Command {}

  public static class Convert implements Command {
    public final String fromFormat;
    public final String toFormat;
    public final byte[] image;

    public Convert(String fromFormat, String toFormat, byte[] image) {
      this.fromFormat = fromFormat;
      this.toFormat = toFormat;
      this.image = image;
    }
  }

  public static class GetResult implements Command {
    public final UUID resultId;
    public final ActorRef&lt;Optional&lt;byte[]&gt;&gt; replyTo;

    public GetResult(UUID resultId, ActorRef&lt;Optional&lt;byte[]&gt;&gt; replyTo) {
      this.resultId = resultId;
      this.replyTo = replyTo;
    }
  }

  private static class WrappedRequestNext implements Command {
    final WorkPullingProducerController.RequestNext&lt;ImageConverter.ConversionJob&gt; next;

    private WrappedRequestNext(
        WorkPullingProducerController.RequestNext&lt;ImageConverter.ConversionJob&gt; next) {
      this.next = next;
    }
  }


  private final ActorContext&lt;Command&gt; context;
  private final StashBuffer&lt;Command&gt; stashBuffer;

  private ImageWorkManager(ActorContext&lt;Command&gt; context, StashBuffer&lt;Command&gt; stashBuffer) {
    this.context = context;
    this.stashBuffer = stashBuffer;
  }

  public static Behavior&lt;Command&gt; create() {
    return Behaviors.setup(
        context -&gt; {
          ActorRef&lt;WorkPullingProducerController.RequestNext&lt;ImageConverter.ConversionJob&gt;&gt;
              requestNextAdapter =
                  context.messageAdapter(
                      WorkPullingProducerController.requestNextClass(), WrappedRequestNext::new);
          ActorRef&lt;WorkPullingProducerController.Command&lt;ImageConverter.ConversionJob&gt;&gt;
              producerController =
                  context.spawn(
                      WorkPullingProducerController.create(
                          ImageConverter.ConversionJob.class,
                          &quot;workManager&quot;,
                          ImageConverter.serviceKey,
                          Optional.empty()),
                      &quot;producerController&quot;);
          producerController.tell(new WorkPullingProducerController.Start&lt;&gt;(requestNextAdapter));

          return Behaviors.withStash(
              1000, stashBuffer -&gt; new ImageWorkManager(context, stashBuffer).waitForNext());
        });
  }

  private Behavior&lt;Command&gt; waitForNext() {
    return Behaviors.receive(Command.class)
        .onMessage(WrappedRequestNext.class, this::onWrappedRequestNext)
        .onMessage(Convert.class, this::onConvertWait)
        .onMessage(GetResult.class, this::onGetResult)
        .build();
  }

  private Behavior&lt;Command&gt; onWrappedRequestNext(WrappedRequestNext w) {
    return stashBuffer.unstashAll(active(w.next));
  }

  private Behavior&lt;Command&gt; onConvertWait(Convert convert) {
    if (stashBuffer.isFull()) {
      context.getLog().warn(&quot;Too many Convert requests.&quot;);
      return Behaviors.same();
    } else {
      stashBuffer.stash(convert);
      return Behaviors.same();
    }
  }

  private Behavior&lt;Command&gt; onGetResult(GetResult get) {
    // TODO retrieve the stored result and reply
    return Behaviors.same();
  }

  private Behavior&lt;Command&gt; active(
      WorkPullingProducerController.RequestNext&lt;ImageConverter.ConversionJob&gt; next) {
    return Behaviors.receive(Command.class)
        .onMessage(Convert.class, c -&gt; onConvert(c, next))
        .onMessage(GetResult.class, this::onGetResult)
        .onMessage(WrappedRequestNext.class, this::onUnexpectedWrappedRequestNext)
        .build();
  }

  private Behavior&lt;Command&gt; onUnexpectedWrappedRequestNext(WrappedRequestNext w) {
    throw new IllegalStateException(&quot;Unexpected RequestNext&quot;);
  }

  private Behavior&lt;Command&gt; onConvert(
      Convert convert,
      WorkPullingProducerController.RequestNext&lt;ImageConverter.ConversionJob&gt; next) {
    UUID resultId = UUID.randomUUID();
    next.sendNextTo()
        .tell(
            new ImageConverter.ConversionJob(
                resultId, convert.fromFormat, convert.toFormat, convert.image));
    return waitForNext();
  }
}</code></pre></dd>
</dl>
<p>Note how the <code>ActorRef</code> in the <code>Start</code> messages are constructed as message adapters to map the <code>RequestNext</code> and <code>Delivery</code> to the protocol of the producer and consumer actors respectively.</p>
<p>See also the corresponding <a href="reliable-delivery.html#ask-from-the-producer">example that is using ask from the producer</a>.</p>
<h3><a href="#work-pulling-delivery-semantics" name="work-pulling-delivery-semantics" class="anchor"><span class="anchor-link"></span></a>Work pulling delivery semantics</h3>
<p>For work pulling the order of the messages should not matter, because each message is routed randomly to one of the workers with demand and can therefore be processed in any order.</p>
<p>As long as neither producers nor workers crash (or workers being removed for other reasons) the messages are delivered to the workers without loss or duplicates. Meaning effectively-once processing without any business level deduplication.</p>
<p>Unconfirmed messages may be lost if the producer crashes. To avoid that you need to enable the <a href="reliable-delivery.html#durable-producer">durable queue</a> on the producer side. The stored unconfirmed messages will be redelivered when the corresponding producer is started again. Those messages may be routed to different workers than before and some of them may have already been processed but the fact that they were confirmed had not been stored yet. Meaning at-least-once delivery.</p>
<p>If a worker crashes or is stopped gracefully the unconfirmed messages will be redelivered to other workers. In that case some of these may already have been processed by the previous worker. Meaning at-least-once delivery.</p>
<h2><a href="#sharding" name="sharding" class="anchor"><span class="anchor-link"></span></a>Sharding</h2>
<p>To use reliable delivery with Cluster Sharding, add the following module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "2.6.20+81-523134c3+20230202-1514-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-cluster-sharding-typed" % PekkoVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.20+81-523134c3+20230202-1514-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-cluster-sharding-typed_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:2.6.20+81-523134c3+20230202-1514-SNAPSHOT")

  implementation "org.apache.pekko:pekko-cluster-sharding-typed_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<p>Reliable delivery between a producer actor sending messages to <a href="cluster-sharding.html">sharded</a> consumer actor receiving the messages.</p>
<p><img src="./images/delivery-sharding-1.png" alt="delivery-work-sharding-1.png" /></p>
<p>and sending to another entity</p>
<p><img src="./images/delivery-sharding-2.png" alt="delivery-work-sharding-2.png" /></p>
<p>and sending from another producer (different node)</p>
<p><img src="./images/delivery-sharding-3.png" alt="delivery-work-sharding-3.png" /></p>
<p>The <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/delivery/ShardingProducerController$.html" title="org.apache.pekko.cluster.sharding.typed.delivery.ShardingProducerController"><code>ShardingProducerController</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/delivery/ShardingProducerController$.html" title="org.apache.pekko.cluster.sharding.typed.delivery.ShardingProducerController"><code>ShardingProducerController</code></a></span> should be used together with <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/delivery/ShardingConsumerController$.html" title="org.apache.pekko.cluster.sharding.typed.delivery.ShardingConsumerController"><code>ShardingConsumerController</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/delivery/ShardingConsumerController$.html" title="org.apache.pekko.cluster.sharding.typed.delivery.ShardingConsumerController"><code>ShardingConsumerController</code></a></span>.</p>
<p>A producer can send messages via a <code>ShardingProducerController</code> to any <code>ShardingConsumerController</code> identified by an <code>entityId</code>. A single <code>ShardingProducerController</code> per <code>ActorSystem</code> (node) can be shared for sending to all entities of a certain entity type. No explicit registration is needed between the <code>ShardingConsumerController</code> and <code>ShardingProducerController</code>.</p>
<p>The producer actor will start the flow by sending a <code>ShardingProducerController.Start</code> message to the <code>ShardingProducerController</code>.</p>
<p>The <code>ShardingProducerController</code> sends <code>RequestNext</code> to the producer, which is then allowed to send one message to the <code>ShardingProducerController</code>. Thereafter the producer will receive a new <code>RequestNext</code> when it&rsquo;s allowed to send one more message.</p>
<p>In the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/delivery/ShardingProducerController$$RequestNext.html" title="org.apache.pekko.cluster.sharding.typed.delivery.ShardingProducerController.RequestNext"><code>ShardingProducerController.RequestNext</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/delivery/ShardingProducerController$$RequestNext.html" title="org.apache.pekko.cluster.sharding.typed.delivery.ShardingProducerController.RequestNext"><code>ShardingProducerController.RequestNext</code></a></span> message there is information about which entities that have demand. It is allowed to send to a new <code>entityId</code> that is not included in the <code>RequestNext.entitiesWithDemand</code>. If sending to an entity that doesn&rsquo;t have demand the message will be buffered. This support for buffering means that it is even allowed to send several messages in response to one <code>RequestNext</code> but it&rsquo;s recommended to only send one message and wait for next <code>RequestNext</code> before sending more messages.</p>
<p>The producer and <code>ShardingProducerController</code> actors are supposed to be local so that these messages are fast and not lost. This is enforced by a runtime check.</p>
<p>Similarly, on the consumer side the destination consumer actor will start the flow by sending an initial <code>ConsumerController.Start</code> message to the <code>ConsumerController</code>.</p>
<p>There will be one <code>ShardingConsumerController</code> for each entity. Many unconfirmed messages can be in flight between the <code>ShardingProducerController</code> and each <code>ShardingConsumerController</code>, but it is limited by a flow control window. The flow control is driven by the consumer side, which means that the <code>ShardingProducerController</code> will not send faster than the demand requested by the consumers.</p>
<h3><a href="#sharding-example" name="sharding-example" class="anchor"><span class="anchor-link"></span></a>Sharding example</h3>
<p>The sharded entity is a todo list which uses an async database call to store its entire state on each change, and first when that completes replies to reliable delivery that the message was consumed.</p>
<p>Example of <code>TodoList</code> entity (consumer):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/delivery/ShardingDocExample.scala#L17-L31" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import scala.concurrent.Future
import scala.concurrent.duration._
import scala.util.Failure
import scala.util.Success

import org.apache.pekko
import pekko.Done
import pekko.actor.typed.ActorRef
import pekko.actor.typed.Behavior
import pekko.actor.typed.delivery.ConsumerController
import pekko.actor.typed.scaladsl.ActorContext
import pekko.actor.typed.scaladsl.Behaviors
import pekko.cluster.sharding.typed.delivery.ShardingConsumerController
import pekko.util.Timeout

trait DB {
  def save(id: String, value: TodoList.State): Future[Done]
  def load(id: String): Future[TodoList.State]
}

object TodoList {

  sealed trait Command

  final case class AddTask(item: String) extends Command
  final case class CompleteTask(item: String) extends Command

  private final case class InitialState(state: State) extends Command
  private final case class SaveSuccess(confirmTo: ActorRef[ConsumerController.Confirmed]) extends Command
  private final case class DBError(cause: Throwable) extends Command

  private final case class CommandDelivery(command: Command, confirmTo: ActorRef[ConsumerController.Confirmed])
      extends Command

  final case class State(tasks: Vector[String])

  def apply(
      id: String,
      db: DB,
      consumerController: ActorRef[ConsumerController.Start[Command]]): Behavior[Command] = {
    Behaviors.setup[Command] { context =&gt;
      new TodoList(context, id, db).start(consumerController)
    }
  }

}

class TodoList(context: ActorContext[TodoList.Command], id: String, db: DB) {
  import TodoList._

  private def start(consumerController: ActorRef[ConsumerController.Start[Command]]): Behavior[Command] = {
    context.pipeToSelf(db.load(id)) {
      case Success(value) =&gt; InitialState(value)
      case Failure(cause) =&gt; DBError(cause)
    }

    Behaviors.receiveMessagePartial {
      case InitialState(state) =&gt;
        val deliveryAdapter: ActorRef[ConsumerController.Delivery[Command]] = context.messageAdapter { delivery =&gt;
          CommandDelivery(delivery.message, delivery.confirmTo)
        }
        consumerController ! ConsumerController.Start(deliveryAdapter)
        active(state)
      case DBError(cause) =&gt;
        throw cause
    }
  }

  private def active(state: State): Behavior[Command] = {
    Behaviors.receiveMessagePartial {
      case CommandDelivery(AddTask(item), confirmTo) =&gt;
        val newState = state.copy(tasks = state.tasks :+ item)
        save(newState, confirmTo)
        active(newState)
      case CommandDelivery(CompleteTask(item), confirmTo) =&gt;
        val newState = state.copy(tasks = state.tasks.filterNot(_ == item))
        save(newState, confirmTo)
        active(newState)
      case SaveSuccess(confirmTo) =&gt;
        confirmTo ! ConsumerController.Confirmed
        Behaviors.same
      case DBError(cause) =&gt;
        throw cause
    }
  }

  private def save(newState: State, confirmTo: ActorRef[ConsumerController.Confirmed]): Unit = {
    context.pipeToSelf(db.save(id, newState)) {
      case Success(_)     =&gt; SaveSuccess(confirmTo)
      case Failure(cause) =&gt; DBError(cause)
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/ShardingDocExample.java#L17-L33" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.Done;
import org.apache.pekko.actor.Address;
import org.apache.pekko.actor.typed.ActorRef;
import org.apache.pekko.actor.typed.Behavior;
import org.apache.pekko.actor.typed.delivery.ConsumerController;
import org.apache.pekko.actor.typed.javadsl.AbstractBehavior;
import org.apache.pekko.actor.typed.javadsl.ActorContext;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.actor.typed.javadsl.Receive;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletionStage;


interface DB {
  CompletionStage&lt;Done&gt; save(String id, TodoList.State state);

  CompletionStage&lt;TodoList.State&gt; load(String id);
}

public class TodoList {
  interface Command {}

  public static class AddTask implements Command {
    public final String item;

    public AddTask(String item) {
      this.item = item;
    }
  }

  public static class CompleteTask implements Command {
    public final String item;

    public CompleteTask(String item) {
      this.item = item;
    }
  }

  private static class InitialState implements Command {
    final State state;

    private InitialState(State state) {
      this.state = state;
    }
  }

  private static class SaveSuccess implements Command {
    final ActorRef&lt;ConsumerController.Confirmed&gt; confirmTo;

    private SaveSuccess(ActorRef&lt;ConsumerController.Confirmed&gt; confirmTo) {
      this.confirmTo = confirmTo;
    }
  }

  private static class DBError implements Command {
    final Exception cause;

    private DBError(Throwable cause) {
      if (cause instanceof Exception) this.cause = (Exception) cause;
      else this.cause = new RuntimeException(cause.getMessage(), cause);
    }
  }

  private static class CommandDelivery implements Command {
    final Command command;
    final ActorRef&lt;ConsumerController.Confirmed&gt; confirmTo;

    private CommandDelivery(Command command, ActorRef&lt;ConsumerController.Confirmed&gt; confirmTo) {
      this.command = command;
      this.confirmTo = confirmTo;
    }
  }

  public static class State {
    public final List&lt;String&gt; tasks;

    public State(List&lt;String&gt; tasks) {
      this.tasks = Collections.unmodifiableList(tasks);
    }

    public State add(String task) {
      ArrayList&lt;String&gt; copy = new ArrayList&lt;&gt;(tasks);
      copy.add(task);
      return new State(copy);
    }

    public State remove(String task) {
      ArrayList&lt;String&gt; copy = new ArrayList&lt;&gt;(tasks);
      copy.remove(task);
      return new State(copy);
    }
  }

  public static Behavior&lt;Command&gt; create(
      String id, DB db, ActorRef&lt;ConsumerController.Start&lt;Command&gt;&gt; consumerController) {
    return Init.create(id, db, consumerController);
  }

  private static Behavior&lt;Command&gt; onDBError(DBError error) throws Exception {
    throw error.cause;
  }

  static class Init extends AbstractBehavior&lt;Command&gt; {

    private final String id;
    private final DB db;
    private final ActorRef&lt;ConsumerController.Start&lt;Command&gt;&gt; consumerController;

    private Init(
        ActorContext&lt;Command&gt; context,
        String id,
        DB db,
        ActorRef&lt;ConsumerController.Start&lt;Command&gt;&gt; consumerController) {
      super(context);
      this.id = id;
      this.db = db;
      this.consumerController = consumerController;
    }

    static Behavior&lt;Command&gt; create(
        String id, DB db, ActorRef&lt;ConsumerController.Start&lt;Command&gt;&gt; consumerController) {
      return Behaviors.setup(
          context -&gt; {
            context.pipeToSelf(
                db.load(id),
                (state, exc) -&gt; {
                  if (exc == null) return new InitialState(state);
                  else return new DBError(exc);
                });

            return new Init(context, id, db, consumerController);
          });
    }

    @Override
    public Receive&lt;Command&gt; createReceive() {
      return newReceiveBuilder()
          .onMessage(InitialState.class, this::onInitialState)
          .onMessage(DBError.class, TodoList::onDBError)
          .build();
    }

    private Behavior&lt;Command&gt; onInitialState(InitialState initial) {
      ActorRef&lt;ConsumerController.Delivery&lt;Command&gt;&gt; deliveryAdapter =
          getContext()
              .messageAdapter(
                  ConsumerController.deliveryClass(),
                  d -&gt; new CommandDelivery(d.message(), d.confirmTo()));
      consumerController.tell(new ConsumerController.Start&lt;&gt;(deliveryAdapter));

      return Active.create(id, db, initial.state);
    }
  }

  static class Active extends AbstractBehavior&lt;Command&gt; {

    private final String id;
    private final DB db;
    private State state;

    private Active(ActorContext&lt;Command&gt; context, String id, DB db, State state) {
      super(context);
      this.id = id;
      this.db = db;
      this.state = state;
    }

    static Behavior&lt;Command&gt; create(String id, DB db, State state) {
      return Behaviors.setup(context -&gt; new Active(context, id, db, state));
    }

    @Override
    public Receive&lt;Command&gt; createReceive() {
      return newReceiveBuilder()
          .onMessage(CommandDelivery.class, this::onDelivery)
          .onMessage(SaveSuccess.class, this::onSaveSuccess)
          .onMessage(DBError.class, TodoList::onDBError)
          .build();
    }

    private Behavior&lt;Command&gt; onDelivery(CommandDelivery delivery) {
      if (delivery.command instanceof AddTask) {
        AddTask addTask = (AddTask) delivery.command;
        state = state.add(addTask.item);
        save(state, delivery.confirmTo);
        return this;
      } else if (delivery.command instanceof CompleteTask) {
        CompleteTask completeTask = (CompleteTask) delivery.command;
        state = state.remove(completeTask.item);
        save(state, delivery.confirmTo);
        return this;
      } else {
        return Behaviors.unhandled();
      }
    }

    private void save(State newState, ActorRef&lt;ConsumerController.Confirmed&gt; confirmTo) {
      getContext()
          .pipeToSelf(
              db.save(id, newState),
              (state, exc) -&gt; {
                if (exc == null) return new SaveSuccess(confirmTo);
                else return new DBError(exc);
              });
    }

    private Behavior&lt;Command&gt; onSaveSuccess(SaveSuccess success) {
      success.confirmTo.tell(ConsumerController.confirmed());
      return this;
    }
  }
}</code></pre></dd>
</dl>
<p>and <code>TodoService</code> (producer):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/delivery/ShardingDocExample.scala#L118-L194" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import pekko.cluster.sharding.typed.delivery.ShardingProducerController

object TodoService {
  sealed trait Command

  final case class UpdateTodo(listId: String, item: String, completed: Boolean, replyTo: ActorRef[Response])
      extends Command

  sealed trait Response
  case object Accepted extends Response
  case object Rejected extends Response
  case object MaybeAccepted extends Response

  private final case class WrappedRequestNext(requestNext: ShardingProducerController.RequestNext[TodoList.Command])
      extends Command
  private final case class Confirmed(originalReplyTo: ActorRef[Response]) extends Command
  private final case class TimedOut(originalReplyTo: ActorRef[Response]) extends Command

  def apply(producerController: ActorRef[ShardingProducerController.Command[TodoList.Command]]): Behavior[Command] = {
    Behaviors.setup { context =&gt;
      new TodoService(context).start(producerController)
    }
  }

}

class TodoService(context: ActorContext[TodoService.Command]) {
  import TodoService._

  private implicit val askTimeout: Timeout = 5.seconds

  private def start(
      producerController: ActorRef[ShardingProducerController.Start[TodoList.Command]]): Behavior[Command] = {
    val requestNextAdapter: ActorRef[ShardingProducerController.RequestNext[TodoList.Command]] =
      context.messageAdapter(WrappedRequestNext.apply)
    producerController ! ShardingProducerController.Start(requestNextAdapter)

    Behaviors.receiveMessagePartial {
      case WrappedRequestNext(next) =&gt;
        active(next)
      case UpdateTodo(_, _, _, replyTo) =&gt;
        // not hooked up with shardingProducerController yet
        replyTo ! Rejected
        Behaviors.same
    }
  }

  private def active(requestNext: ShardingProducerController.RequestNext[TodoList.Command]): Behavior[Command] = {
    Behaviors.receiveMessage {
      case WrappedRequestNext(next) =&gt;
        active(next)

      case UpdateTodo(listId, item, completed, replyTo) =&gt;
        if (requestNext.bufferedForEntitiesWithoutDemand.getOrElse(listId, 0) &gt;= 100)
          replyTo ! Rejected
        else {
          val requestMsg = if (completed) TodoList.CompleteTask(item) else TodoList.AddTask(item)
          context.ask[ShardingProducerController.MessageWithConfirmation[TodoList.Command], Done](
            requestNext.askNextTo,
            askReplyTo =&gt; ShardingProducerController.MessageWithConfirmation(listId, requestMsg, askReplyTo)) {
            case Success(Done) =&gt; Confirmed(replyTo)
            case Failure(_)    =&gt; TimedOut(replyTo)
          }
        }
        Behaviors.same

      case Confirmed(originalReplyTo) =&gt;
        originalReplyTo ! Accepted
        Behaviors.same

      case TimedOut(originalReplyTo) =&gt;
        originalReplyTo ! MaybeAccepted
        Behaviors.same
    }
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/ShardingDocExample.java#L37-L411" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.cluster.sharding.typed.delivery.ShardingProducerController;

public class TodoService {

  interface Command {}

  public static class UpdateTodo implements Command {
    public final String listId;
    public final String item;
    public final boolean completed;
    public final ActorRef&lt;Response&gt; replyTo;

    public UpdateTodo(String listId, String item, boolean completed, ActorRef&lt;Response&gt; replyTo) {
      this.listId = listId;
      this.item = item;
      this.completed = completed;
      this.replyTo = replyTo;
    }
  }

  public enum Response {
    ACCEPTED,
    REJECTED,
    MAYBE_ACCEPTED
  }

  private static class Confirmed implements Command {
    final ActorRef&lt;Response&gt; originalReplyTo;

    private Confirmed(ActorRef&lt;Response&gt; originalReplyTo) {
      this.originalReplyTo = originalReplyTo;
    }
  }

  private static class TimedOut implements Command {
    final ActorRef&lt;Response&gt; originalReplyTo;

    private TimedOut(ActorRef&lt;Response&gt; originalReplyTo) {
      this.originalReplyTo = originalReplyTo;
    }
  }

  private static class WrappedRequestNext implements Command {
    final ShardingProducerController.RequestNext&lt;TodoList.Command&gt; next;

    private WrappedRequestNext(ShardingProducerController.RequestNext&lt;TodoList.Command&gt; next) {
      this.next = next;
    }
  }

  public static Behavior&lt;Command&gt; create(
      ActorRef&lt;ShardingProducerController.Command&lt;TodoList.Command&gt;&gt; producerController) {
    return Init.create(producerController);
  }

  static class Init extends AbstractBehavior&lt;TodoService.Command&gt; {

    static Behavior&lt;Command&gt; create(
        ActorRef&lt;ShardingProducerController.Command&lt;TodoList.Command&gt;&gt; producerController) {
      return Behaviors.setup(
          context -&gt; {
            ActorRef&lt;ShardingProducerController.RequestNext&lt;TodoList.Command&gt;&gt;
                requestNextAdapter =
                    context.messageAdapter(
                        ShardingProducerController.requestNextClass(), WrappedRequestNext::new);
            producerController.tell(new ShardingProducerController.Start&lt;&gt;(requestNextAdapter));

            return new Init(context);
          });
    }

    private Init(ActorContext&lt;Command&gt; context) {
      super(context);
    }

    @Override
    public Receive&lt;Command&gt; createReceive() {
      return newReceiveBuilder()
          .onMessage(WrappedRequestNext.class, w -&gt; Active.create(w.next))
          .onMessage(
              UpdateTodo.class,
              command -&gt; {
                // not hooked up with shardingProducerController yet
                command.replyTo.tell(Response.REJECTED);
                return this;
              })
          .build();
    }
  }

  static class Active extends AbstractBehavior&lt;TodoService.Command&gt; {

    private ShardingProducerController.RequestNext&lt;TodoList.Command&gt; requestNext;

    static Behavior&lt;Command&gt; create(
        ShardingProducerController.RequestNext&lt;TodoList.Command&gt; requestNext) {
      return Behaviors.setup(context -&gt; new Active(context, requestNext));
    }

    private Active(
        ActorContext&lt;Command&gt; context,
        ShardingProducerController.RequestNext&lt;TodoList.Command&gt; requestNext) {
      super(context);
      this.requestNext = requestNext;
    }

    @Override
    public Receive&lt;Command&gt; createReceive() {
      return newReceiveBuilder()
          .onMessage(WrappedRequestNext.class, this::onRequestNext)
          .onMessage(UpdateTodo.class, this::onUpdateTodo)
          .onMessage(Confirmed.class, this::onConfirmed)
          .onMessage(TimedOut.class, this::onTimedOut)
          .build();
    }

    private Behavior&lt;Command&gt; onRequestNext(WrappedRequestNext w) {
      requestNext = w.next;
      return this;
    }

    private Behavior&lt;Command&gt; onUpdateTodo(UpdateTodo command) {
      Integer buffered = requestNext.getBufferedForEntitiesWithoutDemand().get(command.listId);
      if (buffered != null &amp;&amp; buffered &gt;= 100) {
        command.replyTo.tell(Response.REJECTED);
      } else {
        TodoList.Command requestMsg;
        if (command.completed) requestMsg = new TodoList.CompleteTask(command.item);
        else requestMsg = new TodoList.AddTask(command.item);
        getContext()
            .ask(
                Done.class,
                requestNext.askNextTo(),
                Duration.ofSeconds(5),
                askReplyTo -&gt;
                    new ShardingProducerController.MessageWithConfirmation&lt;&gt;(
                        command.listId, requestMsg, askReplyTo),
                (done, exc) -&gt; {
                  if (exc == null) return new Confirmed(command.replyTo);
                  else return new TimedOut(command.replyTo);
                });
      }
      return this;
    }

    private Behavior&lt;Command&gt; onConfirmed(Confirmed confirmed) {
      confirmed.originalReplyTo.tell(Response.ACCEPTED);
      return this;
    }

    private Behavior&lt;Command&gt; onTimedOut(TimedOut timedOut) {
      timedOut.originalReplyTo.tell(Response.MAYBE_ACCEPTED);
      return this;
    }
  }
}</code></pre></dd>
</dl>
<p>Note how the <code>ActorRef</code> in the <code>Start</code> messages are constructed as message adapters to map the <code>RequestNext</code> and <code>Delivery</code> to the protocol of the producer and consumer actors respectively.</p>
<p>Those are initialized with sharding like this (from the guardian):</p>
<dl>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/ShardingDocExample.java#L42-L444" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.cluster.sharding.typed.delivery.ShardingConsumerController;
import org.apache.pekko.cluster.sharding.typed.ShardingEnvelope;
import org.apache.pekko.cluster.sharding.typed.javadsl.ClusterSharding;
import org.apache.pekko.cluster.sharding.typed.javadsl.Entity;
import org.apache.pekko.cluster.sharding.typed.javadsl.EntityTypeKey;
import org.apache.pekko.cluster.typed.Cluster;
import org.apache.pekko.actor.typed.ActorSystem;

final DB db = theDatabaseImplementation();

ActorSystem&lt;Void&gt; system = context.getSystem();

EntityTypeKey&lt;ConsumerController.SequencedMessage&lt;TodoList.Command&gt;&gt; entityTypeKey =
    EntityTypeKey.create(ShardingConsumerController.entityTypeKeyClass(), &quot;todo&quot;);

ActorRef&lt;ShardingEnvelope&lt;ConsumerController.SequencedMessage&lt;TodoList.Command&gt;&gt;&gt; region =
    ClusterSharding.get(system)
        .init(
            Entity.of(
                entityTypeKey,
                entityContext -&gt;
                    ShardingConsumerController.create(
                        start -&gt;
                            TodoList.create(entityContext.getEntityId(), db, start))));

Address selfAddress = Cluster.get(system).selfMember().address();
String producerId = &quot;todo-producer-&quot; + selfAddress.hostPort();

ActorRef&lt;ShardingProducerController.Command&lt;TodoList.Command&gt;&gt; producerController =
    context.spawn(
        ShardingProducerController.create(
            TodoList.Command.class, producerId, region, Optional.empty()),
        &quot;producerController&quot;);

context.spawn(TodoService.create(producerController), &quot;producer&quot;);</code></pre></dd>
</dl>
<h3><a href="#sharding-delivery-semantics" name="sharding-delivery-semantics" class="anchor"><span class="anchor-link"></span></a>Sharding delivery semantics</h3>
<p>As long as neither producer nor consumer crash the messages are delivered to the consumer actor in the same order as they were sent to the <code>ShardingProducerController</code>, without loss or duplicates. Meaning effectively-once processing without any business level deduplication.</p>
<p>Unconfirmed messages may be lost if the producer crashes. To avoid that you need to enable the <a href="reliable-delivery.html#durable-producer">durable queue</a> on the producer side. The stored unconfirmed messages will be redelivered when the corresponding producer is started again. In that case there may be delivery of messages that had already been processed but the fact that they were confirmed had not been stored yet. Meaning at-least-once delivery.</p>
<p>If the consumer crashes or the shard is rebalanced the unconfirmed messages will be redelivered. In that case some of these may already have been processed by the previous consumer.</p>
<h2><a href="#durable-producer" name="durable-producer" class="anchor"><span class="anchor-link"></span></a>Durable producer</h2>
<p>Until sent messages have been confirmed the producer side keeps them in memory to be able to resend them. If the JVM of the producer side crashes those unconfirmed messages are lost. To make sure the messages can be delivered also in that scenario a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/DurableProducerQueue$.html" title="org.apache.pekko.actor.typed.delivery.DurableProducerQueue"><code>DurableProducerQueue</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/actor/typed/delivery/DurableProducerQueue$.html" title="org.apache.pekko.actor.typed.delivery.DurableProducerQueue"><code>DurableProducerQueue</code></a></span> can be used. Then the unconfirmed messages are stored in a durable way so that they can be redelivered when the producer is started again. An implementation of the <code>DurableProducerQueue</code> is provided by <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/persistence/typed/delivery/EventSourcedProducerQueue$.html" title="org.apache.pekko.persistence.typed.delivery.EventSourcedProducerQueue"><code>EventSourcedProducerQueue</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/2.6.20+81-523134c3+20230202-1514-SNAPSHOT/org/apache/pekko/persistence/typed/delivery/EventSourcedProducerQueue$.html" title="org.apache.pekko.persistence.typed.delivery.EventSourcedProducerQueue"><code>EventSourcedProducerQueue</code></a></span> in <code>pekko-persistence-typed</code>.</p>
<p>Be aware of that a <code>DurableProducerQueue</code> will add a substantial performance overhead. </p>
<p>When using the <code>EventSourcedProducerQueue</code> the following dependency is needed:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "2.6.20+81-523134c3+20230202-1514-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-persistence-typed" % PekkoVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.20+81-523134c3+20230202-1514-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-persistence-typed_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:2.6.20+81-523134c3+20230202-1514-SNAPSHOT")

  implementation "org.apache.pekko:pekko-persistence-typed_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<p>You also have to select journal plugin and snapshot store plugin, see <a href="../persistence-plugins.html">Persistence Plugins</a>.</p>
<p>Example of the image converter work manager from the <a href="reliable-delivery.html#work-pulling-example">Work pulling example</a> with <code>EventSourcedProducerQueue</code> enabled:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/delivery/WorkPullingDocExample.scala#L122-L133" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.persistence.typed.delivery.EventSourcedProducerQueue
import pekko.persistence.typed.PersistenceId

val durableQueue =
  EventSourcedProducerQueue[ImageConverter.ConversionJob](PersistenceId.ofUniqueId(&quot;ImageWorkManager&quot;))
val durableProducerController = context.spawn(
  WorkPullingProducerController(
    producerId = &quot;workManager&quot;,
    workerServiceKey = ImageConverter.serviceKey,
    durableQueueBehavior = Some(durableQueue)),
  &quot;producerController&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/WorkPullingDocExample.java#L37-L232" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.persistence.typed.PersistenceId;
import org.apache.pekko.persistence.typed.delivery.EventSourcedProducerQueue;

Behavior&lt;DurableProducerQueue.Command&lt;ImageConverter.ConversionJob&gt;&gt; durableQueue =
    EventSourcedProducerQueue.create(PersistenceId.ofUniqueId(&quot;ImageWorkManager&quot;));
ActorRef&lt;WorkPullingProducerController.Command&lt;ImageConverter.ConversionJob&gt;&gt;
    durableProducerController =
        context.spawn(
            WorkPullingProducerController.create(
                ImageConverter.ConversionJob.class,
                &quot;workManager&quot;,
                ImageConverter.serviceKey,
                Optional.of(durableQueue)),
            &quot;producerController&quot;);</code></pre></dd>
</dl>
<p>It&rsquo;s important to note that the <code>EventSourcedProducerQueue</code> requires a <a href="persistence.html#persistenceid">PersistenceId</a>, which must be unique. The same <code>PersistenceId</code> must not be used for different producers at the same time. A <a href="cluster-singleton.html">Cluster Singleton</a> hosting the producer would satisfy that requirement, or one producer per node and a naming scheme to ensure that different nodes use different <code>PersistenceId</code>. </p>
<p>To deliver unconfirmed messages after a crash the producer must be started again with same <code>PersistenceId</code> as before the crash.</p>
<h2><a href="#ask-from-the-producer" name="ask-from-the-producer" class="anchor"><span class="anchor-link"></span></a>Ask from the producer</h2>
<p>Instead of using <code>tell</code> with the <code>sendNextTo</code> in the <code>RequestNext</code> the producer can use <code>context.ask</code> with the <code>askNextTo</code> in the <code>RequestNext</code>. The difference is that a reply is sent back when the message has been handled. To include the <code>replyTo</code> <code>ActorRef</code> the message must be wrapped in a <code>MessageWithConfirmation</code>. If a <code>DurableProducerQueue</code> is used then the reply is sent when the message has been stored successfully, but it might not have been processed by the consumer yet. Otherwise the reply is sent after the consumer has processed and confirmed the message.</p>
<p>Example of using <code>ask</code> in the image converter work manager from the <a href="reliable-delivery.html#work-pulling-example">Work pulling example</a>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/delivery/WorkPullingDocExample.scala#L92-L239" target="_blank" title="Go to snippet source">source</a><code class="language-scala">final case class ConvertRequest(
    fromFormat: String,
    toFormat: String,
    image: Array[Byte],
    replyTo: ActorRef[ConvertResponse])
    extends Command

sealed trait ConvertResponse
final case class ConvertAccepted(resultId: UUID) extends ConvertResponse
case object ConvertRejected extends ConvertResponse
final case class ConvertTimedOut(resultId: UUID) extends ConvertResponse

private final case class AskReply(resultId: UUID, originalReplyTo: ActorRef[ConvertResponse], timeout: Boolean)
    extends Command

  import WorkPullingProducerController.MessageWithConfirmation
  import pekko.util.Timeout

  implicit val askTimeout: Timeout = 5.seconds

  private def waitForNext(): Behavior[Command] = {
    Behaviors.receiveMessagePartial {
      case WrappedRequestNext(next) =&gt;
        stashBuffer.unstashAll(active(next))
      case c: ConvertRequest =&gt;
        if (stashBuffer.isFull) {
          c.replyTo ! ConvertRejected
          Behaviors.same
        } else {
          stashBuffer.stash(c)
          Behaviors.same
        }
      case AskReply(resultId, originalReplyTo, timeout) =&gt;
        val response = if (timeout) ConvertTimedOut(resultId) else ConvertAccepted(resultId)
        originalReplyTo ! response
        Behaviors.same
      case GetResult(resultId, replyTo) =&gt;
        // TODO retrieve the stored result and reply
        Behaviors.same
    }
  }

  private def active(
      next: WorkPullingProducerController.RequestNext[ImageConverter.ConversionJob]): Behavior[Command] = {
    Behaviors.receiveMessagePartial {
      case ConvertRequest(from, to, image, originalReplyTo) =&gt;
        val resultId = UUID.randomUUID()
        context.ask[MessageWithConfirmation[ImageConverter.ConversionJob], Done](
          next.askNextTo,
          askReplyTo =&gt;
            MessageWithConfirmation(ImageConverter.ConversionJob(resultId, from, to, image), askReplyTo)) {
          case Success(done) =&gt; AskReply(resultId, originalReplyTo, timeout = false)
          case Failure(_)    =&gt; AskReply(resultId, originalReplyTo, timeout = true)
        }
        waitForNext()
      case AskReply(resultId, originalReplyTo, timeout) =&gt;
        val response = if (timeout) ConvertTimedOut(resultId) else ConvertAccepted(resultId)
        originalReplyTo ! response
        Behaviors.same
      case GetResult(resultId, replyTo) =&gt;
        // TODO retrieve the stored result and reply
        Behaviors.same
      case _: WrappedRequestNext =&gt;
        throw new IllegalStateException(&quot;Unexpected RequestNext&quot;)
    }
  }
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/delivery/WorkPullingDocExample.java#L144-L366" target="_blank" title="Go to snippet source">source</a><code class="language-java">public static class ConvertRequest implements Command {
  public final String fromFormat;
  public final String toFormat;
  public final byte[] image;
  public final ActorRef&lt;ConvertResponse&gt; replyTo;

  public ConvertRequest(
      String fromFormat, String toFormat, byte[] image, ActorRef&lt;ConvertResponse&gt; replyTo) {
    this.fromFormat = fromFormat;
    this.toFormat = toFormat;
    this.image = image;
    this.replyTo = replyTo;
  }
}

interface ConvertResponse {}

public static class ConvertAccepted implements ConvertResponse {
  public final UUID resultId;

  public ConvertAccepted(UUID resultId) {
    this.resultId = resultId;
  }
}

enum ConvertRejected implements ConvertResponse {
  INSTANCE
}

public static class ConvertTimedOut implements ConvertResponse {
  public final UUID resultId;

  public ConvertTimedOut(UUID resultId) {
    this.resultId = resultId;
  }
}

private static class AskReply implements Command {
  final UUID resultId;
  final ActorRef&lt;ConvertResponse&gt; originalReplyTo;
  final boolean timeout;

  private AskReply(UUID resultId, ActorRef&lt;ConvertResponse&gt; originalReplyTo, boolean timeout) {
    this.resultId = resultId;
    this.originalReplyTo = originalReplyTo;
    this.timeout = timeout;
  }
}

      private Behavior&lt;Command&gt; waitForNext() {
        return Behaviors.receive(Command.class)
            .onMessage(WrappedRequestNext.class, this::onWrappedRequestNext)
            .onMessage(ConvertRequest.class, this::onConvertRequestWait)
            .onMessage(AskReply.class, this::onAskReply)
            .onMessage(GetResult.class, this::onGetResult)
            .build();
      }

      private Behavior&lt;Command&gt; onConvertRequestWait(ConvertRequest convert) {
        if (stashBuffer.isFull()) {
          convert.replyTo.tell(ConvertRejected.INSTANCE);
          return Behaviors.same();
        } else {
          stashBuffer.stash(convert);
          return Behaviors.same();
        }
      }

      private Behavior&lt;Command&gt; onAskReply(AskReply reply) {
        if (reply.timeout) reply.originalReplyTo.tell(new ConvertTimedOut(reply.resultId));
        else reply.originalReplyTo.tell(new ConvertAccepted(reply.resultId));
        return Behaviors.same();
      }

      private Behavior&lt;Command&gt; onWrappedRequestNext(WrappedRequestNext w) {
        return stashBuffer.unstashAll(active(w.next));
      }

      private Behavior&lt;Command&gt; onGetResult(GetResult get) {
        // TODO retrieve the stored result and reply
        return Behaviors.same();
      }

      private Behavior&lt;Command&gt; active(
          WorkPullingProducerController.RequestNext&lt;ImageConverter.ConversionJob&gt; next) {
        return Behaviors.receive(Command.class)
            .onMessage(ConvertRequest.class, c -&gt; onConvertRequest(c, next))
            .onMessage(AskReply.class, this::onAskReply)
            .onMessage(GetResult.class, this::onGetResult)
            .onMessage(WrappedRequestNext.class, this::onUnexpectedWrappedRequestNext)
            .build();
      }

      private Behavior&lt;Command&gt; onConvertRequest(
          ConvertRequest convert,
          WorkPullingProducerController.RequestNext&lt;ImageConverter.ConversionJob&gt; next) {
        UUID resultId = UUID.randomUUID();

        context.ask(
            Done.class,
            next.askNextTo(),
            Duration.ofSeconds(5),
            askReplyTo -&gt;
                new WorkPullingProducerController.MessageWithConfirmation&lt;&gt;(
                    new ImageConverter.ConversionJob(
                        resultId, convert.fromFormat, convert.toFormat, convert.image),
                    askReplyTo),
            (done, exc) -&gt; {
              if (exc == null) return new AskReply(resultId, convert.replyTo, false);
              else return new AskReply(resultId, convert.replyTo, true);
            });

        return waitForNext();
      }

      private Behavior&lt;Command&gt; onUnexpectedWrappedRequestNext(WrappedRequestNext w) {
        throw new IllegalStateException(&quot;Unexpected RequestNext&quot;);
      }
</code></pre></dd>
</dl>
<h2><a href="#only-flow-control" name="only-flow-control" class="anchor"><span class="anchor-link"></span></a>Only flow control</h2>
<p>It&rsquo;s possible to use this without resending lost messages, but the flow control is still used. This can for example be useful when both consumer and producer are know to be located in the same local <code>ActorSystem</code>. This can be more efficient since messages don&rsquo;t have to be kept in memory in the <code>ProducerController</code> until they have been confirmed, but the drawback is that lost messages will not be delivered. See configuration <code>only-flow-control</code> of the <code>ConsumerController</code>.</p>
<h2><a href="#chunk-large-messages" name="chunk-large-messages" class="anchor"><span class="anchor-link"></span></a>Chunk large messages</h2>
<p>To avoid head of line blocking from serialization and transfer of large messages the <a href="reliable-delivery.html#point-to-point">Point-to-Point</a> pattern has support for automatically <a href="reliable-delivery.html#chunk-large-messages">splitting up large messages</a> and assemble them again on the consumer side.</p>
<p>Serialization and deserialization is performed by the <code>ProducerController</code> and <code>ConsumerController</code> respectively instead of in the remote transport layer.</p>
<p>This is enabled by configuration <code>pekko.reliable-delivery.producer-controller.chunk-large-messages</code> and defines the maximum size in bytes of the chunked pieces. Messages smaller than the configured size are not chunked, but serialization still takes place in the <code>ProducerController</code> and <code>ConsumerController</code>. </p>
<p>Aside from the configuration the API is the same as the <a href="reliable-delivery.html#point-to-point">Point-to-point</a> pattern. If <a href="reliable-delivery.html#durable-producer">Durable producer</a> is enabled the chunked pieces are stored rather than the full large message.</p>
<p>This feature is not implemented for <a href="reliable-delivery.html#work-pulling">Work pulling</a> and <a href="reliable-delivery.html#sharding">Sharding</a> yet.</p>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p>There are several configuration properties, please refer to <code>pekko.reliable-delivery</code> config section in the reference configuration:</p>
<ul>
  <li><a href="../general/configuration-reference.html#config-pekko-actor-typed">pekko-actor-typed reference configuration</a></li>
  <li><a href="../general/configuration-reference.html#config-pekko-persistence-typed">pekko-persistence-typed reference configuration</a></li>
  <li><a href="../general/configuration-reference.html#config-cluster-sharding-typed">pekko-cluster-sharding-typed reference configuration</a></li>
</ul>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/typed/reliable-delivery.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
2.6.20+81-523134c3+20230202-1514*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../typed/distributed-pub-sub.html" title="Distributed Publish Subscribe in Cluster" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Distributed Publish Subscribe in Cluster
</span>
</div>
</a>
<a href="../serialization.html" title="Serialization" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Serialization
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2023 The Apache Software Foundation, Licensed under the Apache License, Version 2.0
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script src="../assets/js/groups.js"></script>
</body>
</html>
