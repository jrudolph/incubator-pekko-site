<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Style guide Â· Apache Pekko</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko" class="md-header-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko
</span>
<span class="md-header-nav__topic">
Style guide
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko">
Apache Pekko
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../downloads.html" class="page">Downloads</a></li>
  <li><a href="../documentation.html" class="page">Documentation</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../general/index.html" class="page">General Concepts</a></li>
    <li><a href="../typed/index.html" class="page">Actors</a></li>
    <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
    <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
    <li><a href="../stream/index.html" class="page">Streams</a></li>
    <li><a href="../discovery/index.html" class="page">Discovery</a></li>
    <li><a href="../index-utilities.html" class="page">Utilities</a></li>
    <li><a href="../common/other-modules.html" class="page">Other Apache Pekko modules</a></li>
    <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
    <li><a href="../project/index.html" class="page">Project Information</a></li>
    <li><a href="../index-classic.html" class="page">Pekko Classic</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../typed/style-guide.html#style-guide" class="header">Style guide</a>
  <ul>
    <li><a href="../typed/style-guide.html#functional-versus-object-oriented-style" class="header">Functional versus object-oriented style</a></li>
    <li><a href="../typed/style-guide.html#passing-around-too-many-parameters" class="header">Passing around too many parameters</a></li>
    <li><a href="../typed/style-guide.html#behavior-factory-method" class="header">Behavior factory method</a></li>
    <li><a href="../typed/style-guide.html#where-to-define-messages" class="header">Where to define messages</a></li>
    <li><a href="../typed/style-guide.html#public-versus-private-messages" class="header">Public versus private messages</a></li>
    <li><a href="../typed/style-guide.html#lambdas-versus-method-references" class="header group-java">Lambdas versus method references</a></li>
    <li><a href="../typed/style-guide.html#partial-versus-total-function" class="header group-scala">Partial versus total Function</a></li>
    <li><a href="../typed/style-guide.html#how-to-compose-partial-functions" class="header group-scala">How to compose Partial Functions</a></li>
    <li><a href="../typed/style-guide.html#ask-versus-" class="header group-scala">ask versus ?</a></li>
    <li><a href="../typed/style-guide.html#receivebuilder" class="header group-java">ReceiveBuilder</a></li>
    <li><a href="../typed/style-guide.html#nesting-setup" class="header">Nesting setup</a></li>
    <li><a href="../typed/style-guide.html#additional-naming-conventions" class="header">Additional naming conventions</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 2.6.20+81-523134c3+20230202-1514*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../typed/style-guide.html#style-guide" class="header">Style guide</a>
  <ul>
    <li><a href="../typed/style-guide.html#functional-versus-object-oriented-style" class="header">Functional versus object-oriented style</a></li>
    <li><a href="../typed/style-guide.html#passing-around-too-many-parameters" class="header">Passing around too many parameters</a></li>
    <li><a href="../typed/style-guide.html#behavior-factory-method" class="header">Behavior factory method</a></li>
    <li><a href="../typed/style-guide.html#where-to-define-messages" class="header">Where to define messages</a></li>
    <li><a href="../typed/style-guide.html#public-versus-private-messages" class="header">Public versus private messages</a></li>
    <li><a href="../typed/style-guide.html#lambdas-versus-method-references" class="header group-java">Lambdas versus method references</a></li>
    <li><a href="../typed/style-guide.html#partial-versus-total-function" class="header group-scala">Partial versus total Function</a></li>
    <li><a href="../typed/style-guide.html#how-to-compose-partial-functions" class="header group-scala">How to compose Partial Functions</a></li>
    <li><a href="../typed/style-guide.html#ask-versus-" class="header group-scala">ask versus ?</a></li>
    <li><a href="../typed/style-guide.html#receivebuilder" class="header group-java">ReceiveBuilder</a></li>
    <li><a href="../typed/style-guide.html#nesting-setup" class="header">Nesting setup</a></li>
    <li><a href="../typed/style-guide.html#additional-naming-conventions" class="header">Additional naming conventions</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#style-guide" name="style-guide" class="anchor"><span class="anchor-link"></span></a>Style guide</h1>
<p>This is a style guide with recommendations of idioms and patterns for writing Pekko actors. Note that this guide does not cover the classic actor API.</p>
<p>As with all style guides, treat this as a list of rules to be broken. There are certainly times when alternative styles should be preferred over the ones given here.</p>
<h2><a href="#functional-versus-object-oriented-style" name="functional-versus-object-oriented-style" class="anchor"><span class="anchor-link"></span></a>Functional versus object-oriented style</h2>
<p>There are two flavors of the Actor APIs.</p>
<ol>
  <li>The functional programming style where you pass a function to a factory which then constructs a behavior,  for stateful actors this means passing immutable state around as parameters and switching to a new behavior  whenever you need to act on a changed state.</li>
  <li>The object-oriented style where a concrete class for the actor behavior is defined and mutable  state is kept inside of it as fields.</li>
</ol>
<p>An example of a counter actor implemented in the functional style:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L31-L71" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>import org.apache.pekko
import pekko.actor.typed.Behavior
import pekko.actor.typed.scaladsl.ActorContext
import pekko.actor.typed.scaladsl.Behaviors

object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class GetValue(replyTo: ActorRef[Value]) extends Command
  final case class Value(n: Int)

  def apply(): Behavior[Command] =
    counter(0)

  private def counter(n: Int): Behavior[Command] =
    Behaviors.receive { (context, message) =&gt;
      message match {
        case Increment =&gt;
          val newValue = n + 1
          context.log.debug(&quot;Incremented counter to [{}]&quot;, newValue)
          counter(newValue)
        case GetValue(replyTo) =&gt;
          replyTo ! Value(n)
          Behaviors.same
      }
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L18-L83" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.Behavior;
import org.apache.pekko.actor.typed.SupervisorStrategy;
import org.apache.pekko.actor.typed.javadsl.ActorContext;
import org.apache.pekko.actor.typed.javadsl.Behaviors;

public class Counter {
  public interface Command {}

  public enum Increment implements Command {
    INSTANCE
  }

  public static class GetValue implements Command {
    public final ActorRef&lt;Value&gt; replyTo;

    public GetValue(ActorRef&lt;Value&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static class Value {
    public final int value;

    public Value(int value) {
      this.value = value;
    }
  }

  public static Behavior&lt;Command&gt; create() {
    return Behaviors.setup(context -&gt; counter(context, 0));
  }

  private static Behavior&lt;Command&gt; counter(final ActorContext&lt;Command&gt; context, final int n) {

    return Behaviors.receive(Command.class)
        .onMessage(Increment.class, notUsed -&gt; onIncrement(context, n))
        .onMessage(GetValue.class, command -&gt; onGetValue(n, command))
        .build();
  }

  private static Behavior&lt;Command&gt; onIncrement(ActorContext&lt;Command&gt; context, int n) {
    int newValue = n + 1;
    context.getLog().debug(&quot;Incremented counter to [{}]&quot;, newValue);
    return counter(context, newValue);
  }

  private static Behavior&lt;Command&gt; onGetValue(int n, GetValue command) {
    command.replyTo.tell(new Value(n));
    return Behaviors.same();
  }
}</code></pre></dd>
</dl>
<p>Corresponding actor implemented in the object-oriented style:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L31-L108" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>import org.apache.pekko
import pekko.actor.typed.Behavior
import pekko.actor.typed.scaladsl.ActorContext
import pekko.actor.typed.scaladsl.Behaviors
import org.apache.pekko.actor.typed.scaladsl.AbstractBehavior
import org.slf4j.Logger

object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class GetValue(replyTo: ActorRef[Value]) extends Command
  final case class Value(n: Int)

  def apply(): Behavior[Command] = {
    Behaviors.setup(context =&gt; new Counter(context))
  }
}

class Counter(context: ActorContext[Counter.Command]) extends AbstractBehavior[Counter.Command](context) {
  import Counter._

  private var n = 0

  override def onMessage(msg: Command): Behavior[Counter.Command] = {
    msg match {
      case Increment =&gt;
        n += 1
        context.log.debug(&quot;Incremented counter to [{}]&quot;, n)
        this
      case GetValue(replyTo) =&gt;
        replyTo ! Value(n)
        this
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L18-L150" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.Behavior;
import org.apache.pekko.actor.typed.SupervisorStrategy;
import org.apache.pekko.actor.typed.javadsl.ActorContext;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.actor.typed.javadsl.AbstractBehavior;
import org.apache.pekko.actor.typed.javadsl.Receive;

public class Counter extends AbstractBehavior&lt;Counter.Command&gt; {

  public interface Command {}

  public enum Increment implements Command {
    INSTANCE
  }

  public static class GetValue implements Command {
    public final ActorRef&lt;Value&gt; replyTo;

    public GetValue(ActorRef&lt;Value&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static class Value {
    public final int value;

    public Value(int value) {
      this.value = value;
    }
  }

  public static Behavior&lt;Command&gt; create() {
    return Behaviors.setup(Counter::new);
  }

  private int n;

  private Counter(ActorContext&lt;Command&gt; context) {
    super(context);
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(Increment.class, notUsed -&gt; onIncrement())
        .onMessage(GetValue.class, this::onGetValue)
        .build();
  }

  private Behavior&lt;Command&gt; onIncrement() {
    n++;
    getContext().getLog().debug(&quot;Incremented counter to [{}]&quot;, n);
    return this;
  }

  private Behavior&lt;Command&gt; onGetValue(GetValue command) {
    command.replyTo.tell(new Value(n));
    return this;
  }
}</code></pre></dd>
</dl>
<p>Some similarities to note:</p>
<ul>
  <li>Messages are defined in the same way.</li>
  <li>Both have <span class="group-scala">an <code>apply</code> factory method in the companion object</span><span class="group-java">a static <code>create</code> factory method</span> to  create the initial behavior, i.e. from the outside they are used in the same way.</li>
  <li><span class="group-scala">Pattern matching</span><span class="group-java">Matching</span> and handling of the messages are done in the same way.</li>
  <li>The <code>ActorContext</code> API is the same.</li>
</ul>
<p>A few differences to note:</p>
<ul>
  <li>There is no class in the functional style, but that is not strictly a requirement and sometimes it&rsquo;s  convenient to use a class also with the functional style to reduce number of parameters in the methods.</li>
  <li>Mutable state, such as the <span class="group-scala"><code>var n</code></span><span class="group-java"><code>int n</code></span> is typically used in the object-oriented style.</li>
  <li>In the functional style the state is is updated by returning a new behavior that holds the new immutable state,  the <span class="group-scala"><code>n: Int</code></span><span class="group-java"><code>final int n</code></span> parameter of the <code>counter</code> method.</li>
  <li>The object-oriented style must use a new instance of the initial <code>Behavior</code> for each spawned actor instance,  since the state in <code>AbstractBehavior</code> instance must not be shared between actor instances.  This is &ldquo;hidden&rdquo; in the functional style since the immutable state is captured by the function.</li>
  <li>In the object-oriented style one can return <code>this</code> to stay with the same behavior for next message.  In the functional style there is no <code>this</code> so <code>Behaviors.same</code> is used instead.</li>
  <li><span class="group-scala">The <code>ActorContext</code> is accessed in different ways. In the object-oriented style it&rsquo;s retrieved from  <code>Behaviors.setup</code> and kept as an instance field, while in the functional style it&rsquo;s passed in alongside  the message. That said, <code>Behaviors.setup</code> is often used in the functional style as well, and then  often together with <code>Behaviors.receiveMessage</code> that doesn&rsquo;t pass in the context with the message.</span>  <span class="group-java">The <code>ActorContext</code> is accessed with <code>Behaviors.setup</code> but then kept in different ways.  As an instance field versus a method parameter.</span></li>
</ul>
<p>Which style you choose to use is a matter of taste and both styles can be mixed depending on which is best for a specific actor. An actor can switch between behaviors implemented in different styles. For example, it may have an initial behavior that is only stashing messages until some initial query has been completed and then switching over to its main active behavior that is maintaining some mutable state. Such initial behavior is nice in the functional style and the active behavior may be better with the object-oriented style.</p>
<p>We would recommend using the tool that is best for the job. The APIs are similar in many ways to make it easy to learn both. You may of course also decide to just stick to one style for consistency and familiarity reasons.</p><div class="group-scala">
<p>When developing in Scala the functional style will probably be the choice for many.</p>
<p>Some reasons why you may want to use the functional style:</p>
<ul>
  <li>You are familiar with a functional approach of structuring the code. Note that this API is still  not using any advanced functional programming or type theory constructs.</li>
  <li>The state is immutable and can be passed to &ldquo;next&rdquo; behavior.</li>
  <li>The <code>Behavior</code> is stateless.</li>
  <li>The actor lifecycle has several different phases that can be represented by switching between different  behaviors, like a <a href="fsm.html">finite state machine</a>. This is also supported with the object-oriented style, but  it&rsquo;s typically nicer with the functional style.</li>
  <li>It&rsquo;s less risk of accessing mutable state in the actor from other threads, like <code>Future</code> or Streams  callbacks.</li>
</ul>
<p>Some reasons why you may want to use the object-oriented style:</p>
<ul>
  <li>You are more familiar with an object-oriented style of structuring the code with methods  in a class rather than functions.</li>
  <li>Some state is not immutable.</li>
  <li>It could be more familiar and easier to upgrade existing classic actors to this style.</li>
  <li>Mutable state can sometimes have better performance, e.g. mutable collections and  avoiding allocating new instance for next behavior (be sure to benchmark if this is your  motivation).</li>
</ul></div><div class="group-java">
<p>When developing in Java the object-oriented style will probably be the choice for many.</p>
<p>Some reasons why you may want to use the object-oriented style:</p>
<ul>
  <li>You are more familiar with an object-oriented style of structuring the code with methods  in a class rather than functions.</li>
  <li>Java lambdas can only close over final or effectively final fields, making it  impractical to use the functional style in behaviors that mutate their fields.</li>
  <li>Some state is not immutable, e.g. immutable collections are not widely used in Java.  It is OK to use mutable state also with the functional style but you must make sure  that it&rsquo;s not shared between different actor instances.</li>
  <li>It could be more familiar and easier to upgrade existing classic actors to this style.</li>
  <li>Mutable state can sometimes have better performance, e.g. mutable collections and  avoiding allocating new instance for next behavior (be sure to benchmark if this is your  motivation).</li>
</ul>
<p>Some reasons why you may want to use the functional style:</p>
<ul>
  <li>You are familiar with a functional approach of structuring the code. Note that this API is still  not using any advanced functional programming or type theory constructs.</li>
  <li>The state is immutable and can be passed to &ldquo;next&rdquo; behavior.</li>
  <li>The <code>Behavior</code> is stateless.</li>
  <li>The actor lifecycle has several different phases that can be represented by switching between different  behaviors, like a <a href="fsm.html">finite state machine</a>. This is also supported with the object-oriented style, but  it&rsquo;s typically nicer with the functional style.</li>
  <li>It&rsquo;s less risk of accessing mutable state in the actor from other threads, like <code>CompletionStage</code> or Streams  callbacks.</li>
</ul></div>
<h2><a href="#passing-around-too-many-parameters" name="passing-around-too-many-parameters" class="anchor"><span class="anchor-link"></span></a>Passing around too many parameters</h2>
<p>One thing you will quickly run into when using the functional style is that you need to pass around many parameters.</p>
<p>Let&rsquo;s add <code>name</code> parameter and timers to the previous <code>Counter</code> example. A first approach would be to just add those as separate parameters:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L115-L149" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>// this is an anti-example, better solutions exists
object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class IncrementRepeatedly(interval: FiniteDuration) extends Command
  final case class GetValue(replyTo: ActorRef[Value]) extends Command
  final case class Value(n: Int)

  def apply(name: String): Behavior[Command] =
    Behaviors.withTimers { timers =&gt;
      counter(name, timers, 0)
    }

  private def counter(name: String, timers: TimerScheduler[Command], n: Int): Behavior[Command] =
    Behaviors.receive { (context, message) =&gt;
      message match {
        case IncrementRepeatedly(interval) =&gt;
          context.log.debug(
            &quot;[{}] Starting repeated increments with interval [{}], current count is [{}]&quot;,
            name,
            interval.toString,
            n.toString)
          timers.startTimerWithFixedDelay(Increment, interval)
          Behaviors.same
        case Increment =&gt;
          val newValue = n + 1
          context.log.debug2(&quot;[{}] Incremented counter to [{}]&quot;, name, newValue)
          counter(name, timers, newValue)
        case GetValue(replyTo) =&gt;
          replyTo ! Value(n)
          Behaviors.same
      }
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L158-L239" target="_blank" title="Go to snippet source">source</a><code class="language-java"><br/>// this is an anti-example, better solutions exists
public class Counter {
  public interface Command {}

  public static class IncrementRepeatedly implements Command {
    public final Duration interval;

    public IncrementRepeatedly(Duration interval) {
      this.interval = interval;
    }
  }

  public enum Increment implements Command {
    INSTANCE
  }

  public static class GetValue implements Command {
    public final ActorRef&lt;Value&gt; replyTo;

    public GetValue(ActorRef&lt;Value&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static class Value {
    public final int value;

    public Value(int value) {
      this.value = value;
    }
  }

  public static Behavior&lt;Command&gt; create(String name) {
    return Behaviors.setup(
        context -&gt; Behaviors.withTimers(timers -&gt; counter(name, context, timers, 0)));
  }

  private static Behavior&lt;Command&gt; counter(
      final String name,
      final ActorContext&lt;Command&gt; context,
      final TimerScheduler&lt;Command&gt; timers,
      final int n) {

    return Behaviors.receive(Command.class)
        .onMessage(
            IncrementRepeatedly.class,
            command -&gt; onIncrementRepeatedly(name, context, timers, n, command))
        .onMessage(Increment.class, notUsed -&gt; onIncrement(name, context, timers, n))
        .onMessage(GetValue.class, command -&gt; onGetValue(n, command))
        .build();
  }

  private static Behavior&lt;Command&gt; onIncrementRepeatedly(
      String name,
      ActorContext&lt;Command&gt; context,
      TimerScheduler&lt;Command&gt; timers,
      int n,
      IncrementRepeatedly command) {
    context
        .getLog()
        .debug(
            &quot;[{}] Starting repeated increments with interval [{}], current count is [{}]&quot;,
            name,
            command.interval,
            n);
    timers.startTimerWithFixedDelay(Increment.INSTANCE, command.interval);
    return Behaviors.same();
  }

  private static Behavior&lt;Command&gt; onIncrement(
      String name, ActorContext&lt;Command&gt; context, TimerScheduler&lt;Command&gt; timers, int n) {
    int newValue = n + 1;
    context.getLog().debug(&quot;[{}] Incremented counter to [{}]&quot;, name, newValue);
    return counter(name, context, timers, newValue);
  }

  private static Behavior&lt;Command&gt; onGetValue(int n, GetValue command) {
    command.replyTo.tell(new Value(n));
    return Behaviors.same();
  }
}</code></pre></dd>
</dl>
<p>Ouch, that doesn&rsquo;t look good. More things may be needed, such as stashing or application specific &ldquo;constructor&rdquo; parameters. As you can imagine, that will be too much boilerplate.</p>
<p>As a first step we can place all these parameters in a class so that we at least only have to pass around one thing. Still good to have the &ldquo;changing&rdquo; state, the <span class="group-scala"><code>n: Int</code></span><span class="group-java"><code>final int n</code></span> here, as a separate parameter.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L155-L191" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>// this is better than previous example, but even better solution exists
object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class IncrementRepeatedly(interval: FiniteDuration) extends Command
  final case class GetValue(replyTo: ActorRef[Value]) extends Command
  final case class Value(n: Int)

  private case class Setup(name: String, context: ActorContext[Command], timers: TimerScheduler[Command])

  def apply(name: String): Behavior[Command] =
    Behaviors.setup { context =&gt;
      Behaviors.withTimers { timers =&gt;
        counter(Setup(name, context, timers), 0)
      }
    }

  private def counter(setup: Setup, n: Int): Behavior[Command] =
    Behaviors.receiveMessage {
      case IncrementRepeatedly(interval) =&gt;
        setup.context.log.debugN(
          &quot;[{}] Starting repeated increments with interval [{}], current count is [{}]&quot;,
          setup.name,
          interval,
          n)
        setup.timers.startTimerWithFixedDelay(Increment, interval)
        Behaviors.same
      case Increment =&gt;
        val newValue = n + 1
        setup.context.log.debug2(&quot;[{}] Incremented counter to [{}]&quot;, setup.name, newValue)
        counter(setup, newValue)
      case GetValue(replyTo) =&gt;
        replyTo ! Value(n)
        Behaviors.same
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L245-L333" target="_blank" title="Go to snippet source">source</a><code class="language-java"><br/>// this is better than previous example, but even better solution exists
public class Counter {
  // messages omitted for brevity, same messages as above example

  private static class Setup {
    final String name;
    final ActorContext&lt;Command&gt; context;
    final TimerScheduler&lt;Command&gt; timers;

    private Setup(String name, ActorContext&lt;Command&gt; context, TimerScheduler&lt;Command&gt; timers) {
      this.name = name;
      this.context = context;
      this.timers = timers;
    }
  }

  public static Behavior&lt;Command&gt; create(String name) {
    return Behaviors.setup(
        context -&gt;
            Behaviors.withTimers(timers -&gt; counter(new Setup(name, context, timers), 0)));
  }

  private static Behavior&lt;Command&gt; counter(final Setup setup, final int n) {

    return Behaviors.receive(Command.class)
        .onMessage(
            IncrementRepeatedly.class, command -&gt; onIncrementRepeatedly(setup, n, command))
        .onMessage(Increment.class, notUsed -&gt; onIncrement(setup, n))
        .onMessage(GetValue.class, command -&gt; onGetValue(n, command))
        .build();
  }

  private static Behavior&lt;Command&gt; onIncrementRepeatedly(
      Setup setup, int n, IncrementRepeatedly command) {
    setup
        .context
        .getLog()
        .debug(
            &quot;[{}] Starting repeated increments with interval [{}], current count is [{}]&quot;,
            setup.name,
            command.interval,
            n);
    setup.timers.startTimerWithFixedDelay(Increment.INSTANCE, command.interval);
    return Behaviors.same();
  }

  private static Behavior&lt;Command&gt; onIncrement(Setup setup, int n) {
    int newValue = n + 1;
    setup.context.getLog().debug(&quot;[{}] Incremented counter to [{}]&quot;, setup.name, newValue);
    return counter(setup, newValue);
  }

  private static Behavior&lt;Command&gt; onGetValue(int n, GetValue command) {
    command.replyTo.tell(new Value(n));
    return Behaviors.same();
  }
}</code></pre></dd>
</dl>
<p>That&rsquo;s better. Only one thing to carry around and easy to add more things to it without rewriting everything. <span class="group-scala">Note that we also placed the <code>ActorContext</code> in the <code>Setup</code> class, and therefore switched from <code>Behaviors.receive</code> to <code>Behaviors.receiveMessage</code> since we already have access to the <code>context</code>.</span></p>
<p>It&rsquo;s still rather annoying to have to pass the same thing around everywhere.</p>
<p>We can do better by introducing an enclosing class, even though it&rsquo;s still using the functional style. The &ldquo;constructor&rdquo; parameters can be <span class="group-scala">immutable</span><span class="group-java"><code>final</code></span> instance fields and can be accessed from member methods.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L197-L238" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>// this is better than previous examples
object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class IncrementRepeatedly(interval: FiniteDuration) extends Command
  final case class GetValue(replyTo: ActorRef[Value]) extends Command
  final case class Value(n: Int)

  def apply(name: String): Behavior[Command] =
    Behaviors.setup { context =&gt;
      Behaviors.withTimers { timers =&gt;
        new Counter(name, context, timers).counter(0)
      }
    }
}

class Counter private (
    name: String,
    context: ActorContext[Counter.Command],
    timers: TimerScheduler[Counter.Command]) {
  import Counter._

  private def counter(n: Int): Behavior[Command] =
    Behaviors.receiveMessage {
      case IncrementRepeatedly(interval) =&gt;
        context.log.debugN(
          &quot;[{}] Starting repeated increments with interval [{}], current count is [{}]&quot;,
          name,
          interval,
          n)
        timers.startTimerWithFixedDelay(Increment, interval)
        Behaviors.same
      case Increment =&gt;
        val newValue = n + 1
        context.log.debug2(&quot;[{}] Incremented counter to [{}]&quot;, name, newValue)
        counter(newValue)
      case GetValue(replyTo) =&gt;
        replyTo ! Value(n)
        Behaviors.same
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L339-L421" target="_blank" title="Go to snippet source">source</a><code class="language-java"><br/>// this is better than previous examples
public class Counter {
  // messages omitted for brevity, same messages as above example

  public static Behavior&lt;Command&gt; create(String name) {
    return Behaviors.setup(
        context -&gt;
            Behaviors.withTimers(timers -&gt; new Counter(name, context, timers).counter(0)));
  }

  private final String name;
  private final ActorContext&lt;Command&gt; context;
  private final TimerScheduler&lt;Command&gt; timers;

  private Counter(String name, ActorContext&lt;Command&gt; context, TimerScheduler&lt;Command&gt; timers) {
    this.name = name;
    this.context = context;
    this.timers = timers;
  }

  private Behavior&lt;Command&gt; counter(final int n) {
    return Behaviors.receive(Command.class)
        .onMessage(IncrementRepeatedly.class, command -&gt; onIncrementRepeatedly(n, command))
        .onMessage(Increment.class, notUsed -&gt; onIncrement(n))
        .onMessage(GetValue.class, command -&gt; onGetValue(n, command))
        .build();
  }

  private Behavior&lt;Command&gt; onIncrementRepeatedly(int n, IncrementRepeatedly command) {
    context
        .getLog()
        .debug(
            &quot;[{}] Starting repeated increments with interval [{}], current count is [{}]&quot;,
            name,
            command.interval,
            n);
    timers.startTimerWithFixedDelay(Increment.INSTANCE, command.interval);
    return Behaviors.same();
  }

  private Behavior&lt;Command&gt; onIncrement(int n) {
    int newValue = n + 1;
    context.getLog().debug(&quot;[{}] Incremented counter to [{}]&quot;, name, newValue);
    return counter(newValue);
  }

  private Behavior&lt;Command&gt; onGetValue(int n, GetValue command) {
    command.replyTo.tell(new Value(n));
    return Behaviors.same();
  }
}</code></pre></dd>
</dl>
<p>That&rsquo;s nice. One thing to be cautious with here is that it&rsquo;s important that you create a new instance for each spawned actor, since those parameters must not be shared between different actor instances. That comes natural when creating the instance from <code>Behaviors.setup</code> as in the above example. Having a <span class="group-scala"><code>apply</code> factory method in the companion object and making the constructor private is recommended.</span> <span class="group-java">static <code>create</code> factory method and making the constructor private is recommended.</span></p>
<p>This can also be useful when testing the behavior by creating a test subclass that overrides certain methods in the class. The test would create the instance without the <span class="group-scala"><code>apply</code> factory method</span><span class="group-java">static <code>create</code> factory method</span>. Then you need to relax the visibility constraints of the constructor and methods.</p>
<p>It&rsquo;s not recommended to place mutable state and <span class="group-scala"><code>var</code> members</span><span class="group-java">non-final members</span> in the enclosing class. It would be correct from an actor thread-safety perspective as long as the same instance of the enclosing class is not shared between different actor instances, but if that is what you need you should rather use the object-oriented style with the <code>AbstractBehavior</code> class.</p><div class="group-scala">
<p>Similar can be achieved without an enclosing class by placing the <code>def counter</code> inside the <code>Behaviors.setup</code> block. That works fine, but for more complex behaviors it can be better to structure the methods in a class. For completeness, here is how it would look like:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L244-L279" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>// this works, but previous example is better for structuring more complex behaviors
object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class IncrementRepeatedly(interval: FiniteDuration) extends Command
  final case class GetValue(replyTo: ActorRef[Value]) extends Command
  final case class Value(n: Int)

  def apply(name: String): Behavior[Command] =
    Behaviors.setup { context =&gt;
      Behaviors.withTimers { timers =&gt;
        def counter(n: Int): Behavior[Command] =
          Behaviors.receiveMessage {
            case IncrementRepeatedly(interval) =&gt;
              context.log.debugN(
                &quot;[{}] Starting repeated increments with interval [{}], current count is [{}]&quot;,
                name,
                interval,
                n)
              timers.startTimerWithFixedDelay(Increment, interval)
              Behaviors.same
            case Increment =&gt;
              val newValue = n + 1
              context.log.debug2(&quot;[{}] Incremented counter to [{}]&quot;, name, newValue)
              counter(newValue)
            case GetValue(replyTo) =&gt;
              replyTo ! Value(n)
              Behaviors.same
          }

        counter(0)
      }
    }
}
</code></pre></dd>
</dl></div>
<h2><a href="#behavior-factory-method" name="behavior-factory-method" class="anchor"><span class="anchor-link"></span></a>Behavior factory method</h2>
<p>The initial behavior should be created via <span class="group-scala">a factory method in the companion object</span><span class="group-java">a static factory method</span>. Thereby the usage of the behavior doesn&rsquo;t change when the implementation is changed, for example if changing between object-oriented and function style.</p>
<p>The factory method is a good place for retrieving resources like <code>Behaviors.withTimers</code>, <code>Behaviors.withStash</code> and <code>ActorContext</code> with <code>Behaviors.setup</code>.</p>
<p>When using the object-oriented style, <code>AbstractBehavior</code>, a new instance should be created from a <code>Behaviors.setup</code> block in this factory method even though the <code>ActorContext</code> is not needed. This is important because a new instance should be created when restart supervision is used. Typically, the <code>ActorContext</code> is needed anyway.</p>
<p>The naming convention for the factory method is <span class="group-scala"><code>apply</code> (when using Scala)</span><span class="group-java"><code>create</code> (when using Java)</span>. Consistent naming makes it easier for readers of the code to find the &ldquo;starting point&rdquo; of the behavior.</p>
<p>In the functional style the factory could even have been defined as a <span class="group-scala"><code>val</code></span><span class="group-java"><code>static field</code></span> if all state is immutable and captured by the function, but since most behaviors need some initialization parameters it is preferred to consistently use a method <span class="group-scala">(<code>def</code>)</span> for the factory.</p>
<p>Example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L285-L310" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object CountDown {
  sealed trait Command
  case object Down extends Command

  // factory for the initial `Behavior`
  def apply(countDownFrom: Int, notifyWhenZero: ActorRef[Done]): Behavior[Command] =
    new CountDown(notifyWhenZero).counter(countDownFrom)
}

private class CountDown(notifyWhenZero: ActorRef[Done]) {
  import CountDown._

  private def counter(remaining: Int): Behavior[Command] = {
    Behaviors.receiveMessage {
      case Down =&gt;
        if (remaining == 1) {
          notifyWhenZero.tell(Done)
          Behaviors.stopped
        } else
          counter(remaining - 1)
    }
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L427-L464" target="_blank" title="Go to snippet source">source</a><code class="language-java">public class CountDown extends AbstractBehavior&lt;CountDown.Command&gt; {

  public interface Command {}

  public enum Down implements Command {
    INSTANCE
  }

  // factory for the initial `Behavior`
  public static Behavior&lt;Command&gt; create(int countDownFrom, ActorRef&lt;Done&gt; notifyWhenZero) {
    return Behaviors.setup(context -&gt; new CountDown(context, countDownFrom, notifyWhenZero));
  }

  private final ActorRef&lt;Done&gt; notifyWhenZero;
  private int remaining;

  private CountDown(
      ActorContext&lt;Command&gt; context, int countDownFrom, ActorRef&lt;Done&gt; notifyWhenZero) {
    super(context);
    this.remaining = countDownFrom;
    this.notifyWhenZero = notifyWhenZero;
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder().onMessage(Down.class, notUsed -&gt; onDown()).build();
  }

  private Behavior&lt;Command&gt; onDown() {
    remaining--;
    if (remaining == 0) {
      notifyWhenZero.tell(Done.getInstance());
      return Behaviors.stopped();
    } else {
      return this;
    }
  }
}</code></pre></dd>
</dl>
<p>When spawning an actor from this initial behavior it looks like:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L318" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val countDown = context.spawn(CountDown(100, doneRef), &quot;countDown&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L473-L474" target="_blank" title="Go to snippet source">source</a><code class="language-java">ActorRef&lt;CountDown.Command&gt; countDown =
    context.spawn(CountDown.create(100, doneRef), &quot;countDown&quot;);</code></pre></dd>
</dl>
<h2><a href="#where-to-define-messages" name="where-to-define-messages" class="anchor"><span class="anchor-link"></span></a>Where to define messages</h2>
<p>When sending or receiving actor messages they should be prefixed with the name of the actor/behavior that defines them to avoid ambiguities.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L322" target="_blank" title="Go to snippet source">source</a><code class="language-scala">countDown ! CountDown.Down</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L478" target="_blank" title="Go to snippet source">source</a><code class="language-java">countDown.tell(CountDown.Down.INSTANCE);</code></pre></dd>
</dl>
<p>Such a style is preferred over using <span class="group-scala">importing <code>Down</code> and using <code>countDown ! Down</code></span> <span class="group-java">importing <code>Down</code> and using <code>countDown.tell(Down.INSTANCE);</code></span>. However, within the <code>Behavior</code> that handle these messages the short names can be used.</p>
<p>Therefore it is not recommended to define messages as top-level classes.</p>
<p>For the majority of cases it&rsquo;s good style to define the messages <span class="group-scala">in the companion object</span><span class="group-java">as static inner classes</span> together with the <code>Behavior</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L48-L71" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class GetValue(replyTo: ActorRef[Value]) extends Command
  final case class Value(n: Int)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L92-L150" target="_blank" title="Go to snippet source">source</a><code class="language-java">public class Counter extends AbstractBehavior&lt;Counter.Command&gt; {

  public interface Command {}

  public enum Increment implements Command {
    INSTANCE
  }

  public static class GetValue implements Command {
    public final ActorRef&lt;Value&gt; replyTo;

    public GetValue(ActorRef&lt;Value&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static class Value {
    public final int value;

    public Value(int value) {
      this.value = value;
    }
  }
}</code></pre></dd>
</dl>
<p>If several actors share the same message protocol, it&rsquo;s recommended to define those messages in a separate <span class="group-scala"><code>object</code></span><span class="group-java"><code>interface</code></span> for that protocol.</p>
<p>Here&rsquo;s an example of a shared message protocol setup:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L329-L338" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object CounterProtocol {
  sealed trait Command

  final case class Increment(delta: Int, replyTo: ActorRef[OperationResult]) extends Command
  final case class Decrement(delta: Int, replyTo: ActorRef[OperationResult]) extends Command

  sealed trait OperationResult
  case object Confirmed extends OperationResult
  final case class Rejected(reason: String) extends OperationResult
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L486-L522" target="_blank" title="Go to snippet source">source</a><code class="language-java">interface CounterProtocol {
  interface Command {}

  public static class Increment implements Command {
    public final int delta;
    private final ActorRef&lt;OperationResult&gt; replyTo;

    public Increment(int delta, ActorRef&lt;OperationResult&gt; replyTo) {
      this.delta = delta;
      this.replyTo = replyTo;
    }
  }

  public static class Decrement implements Command {
    public final int delta;
    private final ActorRef&lt;OperationResult&gt; replyTo;

    public Decrement(int delta, ActorRef&lt;OperationResult&gt; replyTo) {
      this.delta = delta;
      this.replyTo = replyTo;
    }
  }

  interface OperationResult {}

  enum Confirmed implements OperationResult {
    INSTANCE
  }

  public static class Rejected implements OperationResult {
    public final String reason;

    public Rejected(String reason) {
      this.reason = reason;
    }
  }
}</code></pre></dd>
</dl>
<p>Note that the response message hierarchy in this case could be completely avoided by using the  API instead (see <a href="interaction-patterns.html#generic-response-wrapper">Generic Response Wrapper</a>).</p>
<h2><a href="#public-versus-private-messages" name="public-versus-private-messages" class="anchor"><span class="anchor-link"></span></a>Public versus private messages</h2>
<p>Often an actor has some messages that are only for its internal implementation and not part of the public message protocol, such as timer messages or wrapper messages for <code>ask</code> or <code>messageAdapter</code>.</p>
<p>Such messages should be declared <code>private</code> so they can&rsquo;t be accessed and sent from the outside of the actor. Note that they must still <span class="group-scala">extend</span><span class="group-java">implement</span> the public <code>Command</code> <span class="group-scala">trait</span><span class="group-java">interface</span>.</p>
<p>Here is an example of using <code>private</code> for an internal message:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L344-L379" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class GetValue(replyTo: ActorRef[Value]) extends Command
  final case class Value(n: Int)

  // Tick is private so can&#39;t be sent from the outside
  private case object Tick extends Command

  def apply(name: String, tickInterval: FiniteDuration): Behavior[Command] =
    Behaviors.setup { context =&gt;
      Behaviors.withTimers { timers =&gt;
        timers.startTimerWithFixedDelay(Tick, tickInterval)
        new Counter(name, context).counter(0)
      }
    }
}

class Counter private (name: String, context: ActorContext[Counter.Command]) {
  import Counter._

  private def counter(n: Int): Behavior[Command] =
    Behaviors.receiveMessage {
      case Increment =&gt;
        val newValue = n + 1
        context.log.debug2(&quot;[{}] Incremented counter to [{}]&quot;, name, newValue)
        counter(newValue)
      case Tick =&gt;
        val newValue = n + 1
        context.log.debug2(&quot;[{}] Incremented counter by background tick to [{}]&quot;, name, newValue)
        counter(newValue)
      case GetValue(replyTo) =&gt;
        replyTo ! Value(n)
        Behaviors.same
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L531-L652" target="_blank" title="Go to snippet source">source</a><code class="language-java">public class Counter extends AbstractBehavior&lt;Counter.Command&gt; {

  public interface Command {}

  public enum Increment implements Command {
    INSTANCE
  }

  public static class GetValue implements Command {
    public final ActorRef&lt;Value&gt; replyTo;

    public GetValue(ActorRef&lt;Value&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static class Value {
    public final int value;

    public Value(int value) {
      this.value = value;
    }
  }

  // Tick is private so can&#39;t be sent from the outside
  private enum Tick implements Command {
    INSTANCE
  }

  public static Behavior&lt;Command&gt; create(String name, Duration tickInterval) {
    return Behaviors.setup(
        context -&gt;
            Behaviors.withTimers(
                timers -&gt; {
                  timers.startTimerWithFixedDelay(Tick.INSTANCE, tickInterval);
                  return new Counter(name, context);
                }));
  }

  private final String name;
  private int count;

  private Counter(String name, ActorContext&lt;Command&gt; context) {
    super(context);
    this.name = name;
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(Increment.class, notUsed -&gt; onIncrement())
        .onMessage(Tick.class, notUsed -&gt; onTick())
        .onMessage(GetValue.class, this::onGetValue)
        .build();
  }


  private Behavior&lt;Command&gt; onIncrement() {
    count++;
    getContext().getLog().debug(&quot;[{}] Incremented counter to [{}]&quot;, name, count);
    return this;
  }

  private Behavior&lt;Command&gt; onTick() {
    count++;
    getContext()
        .getLog()
        .debug(&quot;[{}] Incremented counter by background tick to [{}]&quot;, name, count);
    return this;
  }

  private Behavior&lt;Command&gt; onGetValue(GetValue command) {
    command.replyTo.tell(new Value(count));
    return this;
  }

}</code></pre></dd>
</dl>
<p>An alternative approach is using a type hierarchy and <code>narrow</code> to have a super-type for the public messages as a distinct type from the super-type of all actor messages. The former approach is recommended but it is good to know this alternative as it can be useful when using shared message protocol classes as described in <a href="style-guide.html#where-to-define-messages">Where to define messages</a>.</p>
<p>Here&rsquo;s an example of using a type hierarchy to separate public and private messages:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L385-L430" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// above example is preferred, but this is possible and not wrong
object Counter {
  // The type of all public and private messages the Counter actor handles
  sealed trait Message

  /** Counter&#39;s public message protocol type. */
  sealed trait Command extends Message
  case object Increment extends Command
  final case class GetValue(replyTo: ActorRef[Value]) extends Command
  final case class Value(n: Int)

  // The type of the Counter actor&#39;s internal messages.
  sealed trait PrivateCommand extends Message
  // Tick is a private command so can&#39;t be sent to an ActorRef[Command]
  case object Tick extends PrivateCommand

  def apply(name: String, tickInterval: FiniteDuration): Behavior[Command] = {
    Behaviors
      .setup[Counter.Message] { context =&gt;
        Behaviors.withTimers { timers =&gt;
          timers.startTimerWithFixedDelay(Tick, tickInterval)
          new Counter(name, context).counter(0)
        }
      }
      .narrow // note narrow here
  }
}

class Counter private (name: String, context: ActorContext[Counter.Message]) {
  import Counter._

  private def counter(n: Int): Behavior[Message] =
    Behaviors.receiveMessage {
      case Increment =&gt;
        val newValue = n + 1
        context.log.debug2(&quot;[{}] Incremented counter to [{}]&quot;, name, newValue)
        counter(newValue)
      case Tick =&gt;
        val newValue = n + 1
        context.log.debug2(&quot;[{}] Incremented counter by background tick to [{}]&quot;, name, newValue)
        counter(newValue)
      case GetValue(replyTo) =&gt;
        replyTo ! Value(n)
        Behaviors.same
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L659-L742" target="_blank" title="Go to snippet source">source</a><code class="language-java">// above example is preferred, but this is possible and not wrong
public class Counter extends AbstractBehavior&lt;Counter.Message&gt; {

  // The type of all public and private messages the Counter actor handles
  public interface Message {}

  /** Counter&#39;s public message protocol type. */
  public interface Command extends Message {}

  public enum Increment implements Command {
    INSTANCE
  }

  public static class GetValue implements Command {
    public final ActorRef&lt;Value&gt; replyTo;

    public GetValue(ActorRef&lt;Value&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static class Value {
    public final int value;

    public Value(int value) {
      this.value = value;
    }
  }

  // The type of the Counter actor&#39;s internal messages.
  interface PrivateCommand extends Message {}

  // Tick is a private command so can&#39;t be sent to an ActorRef&lt;Command&gt;
  enum Tick implements PrivateCommand {
    INSTANCE
  }

  public static Behavior&lt;Command&gt; create(String name, Duration tickInterval) {
    return Behaviors.setup(
            (ActorContext&lt;Message&gt; context) -&gt;
                Behaviors.withTimers(
                    timers -&gt; {
                      timers.startTimerWithFixedDelay(Tick.INSTANCE, tickInterval);
                      return new Counter(name, context);
                    }))
        .narrow(); // note narrow here
  }

  private final String name;
  private int count;

  private Counter(String name, ActorContext&lt;Message&gt; context) {
    super(context);
    this.name = name;
  }

  @Override
  public Receive&lt;Message&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(Increment.class, notUsed -&gt; onIncrement())
        .onMessage(Tick.class, notUsed -&gt; onTick())
        .onMessage(GetValue.class, this::onGetValue)
        .build();
  }

  private Behavior&lt;Message&gt; onIncrement() {
    count++;
    getContext().getLog().debug(&quot;[{}] Incremented counter to [{}]&quot;, name, count);
    return this;
  }

  private Behavior&lt;Message&gt; onTick() {
    count++;
    getContext()
        .getLog()
        .debug(&quot;[{}] Incremented counter by background tick to [{}]&quot;, name, count);
    return this;
  }

  private Behavior&lt;Message&gt; onGetValue(GetValue command) {
    command.replyTo.tell(new Value(count));
    return this;
  }
}</code></pre></dd>
</dl>
<p><code>private</code> visibility can be defined for the <code>PrivateCommand</code> messages but it&rsquo;s not strictly needed since they can&rsquo;t be sent to an <span class="group-scala">ActorRef[Command]</span><span class="group-java">ActorRef<Command></span>, which is the public message type of the actor.</p><div class="group-java">
<h3><a href="#singleton-messages" name="singleton-messages" class="anchor"><span class="anchor-link"></span></a>Singleton messages</h3>
<p>For messages without parameters the <code>enum</code> singleton pattern is recommended:</p>
<dl>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L97-L99" target="_blank" title="Go to snippet source">source</a><code class="language-java">public enum Increment implements Command {
  INSTANCE
}</code></pre></dd>
</dl>
<p>In the <code>ReceiveBuilder</code> it can be matched in same way as other messages:</p>
<dl>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L133" target="_blank" title="Go to snippet source">source</a><code class="language-java">.onMessage(Increment.class, notUsed -&gt; onIncrement())</code></pre></dd>
</dl></div><div class="group-java">
<h2><a href="#lambdas-versus-method-references" name="lambdas-versus-method-references" class="anchor"><span class="anchor-link"></span></a>Lambdas versus method references</h2>
<p>It&rsquo;s recommended to keep the message matching with the <code>ReceiveBuilder</code> as short and clean as possible and delegate to methods. This improves readability and ease of method navigation with an IDE.</p>
<p>The delegation can be with lambdas or <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">method references</a>.</p>
<p>Example of delegation using a lambda:</p>
<dl>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L580-L603" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public Receive&lt;Command&gt; createReceive() {
  return newReceiveBuilder()
      .onMessage(Increment.class, notUsed -&gt; onIncrement())
      .build();
}

private Behavior&lt;Command&gt; onIncrement() {
  count++;
  getContext().getLog().debug(&quot;[{}] Incremented counter to [{}]&quot;, name, count);
  return this;
}</code></pre></dd>
</dl>
<p>When possible it&rsquo;s preferred to use method references instead of lambdas. The benefit is less verbosity and in some cases it can actually give better type inference.</p>
<dl>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L580-L618" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public Receive&lt;Command&gt; createReceive() {
  return newReceiveBuilder()
      .onMessage(GetValue.class, this::onGetValue)
      .build();
}

private Behavior&lt;Command&gt; onGetValue(GetValue command) {
  command.replyTo.tell(new Value(count));
  return this;
}</code></pre></dd>
</dl>
<p><code>this::onGetValue</code> is a method reference in above example. It corresponds to <code>command -&gt; onGetValue(command)</code>.</p>
<p>If you are using IntelliJ IDEA it has support for converting lambdas to method references.</p>
<p>More important than the choice between lambdas or method references is to avoid lambdas with a large block of code. An anti-pattern would be to inline all message handling inside the lambdas like this:</p>
<dl>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L528-L649" target="_blank" title="Go to snippet source">source</a><code class="language-java">// this is an anti-pattern, don&#39;t use lambdas with a large block of code
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(
            Increment.class,
            notUsed -&gt; {
              count++;
              getContext().getLog().debug(&quot;[{}] Incremented counter to [{}]&quot;, name, count);
              return this;
            })
        .onMessage(
            Tick.class,
            notUsed -&gt; {
              count++;
              getContext()
                  .getLog()
                  .debug(&quot;[{}] Incremented counter by background tick to [{}]&quot;, name, count);
              return this;
            })
        .onMessage(
            GetValue.class,
            command -&gt; {
              command.replyTo.tell(new Value(count));
              return this;
            })
        .build();
  }</code></pre></dd>
</dl>
<p>In a real application it would often be more than 3 lines for each message. It&rsquo;s not only making it more difficult to get an overview of the message matching, but compiler errors related to lambdas can sometimes be difficult to understand.</p>
<p>Ideally, lambdas should be written in one line of code. Two lines can be ok, but three is probably too much. Also, don&rsquo;t use braces and return statements in one-line lambda bodies.</p></div><div class="group-scala">
<h2><a href="#partial-versus-total-function" name="partial-versus-total-function" class="anchor"><span class="anchor-link"></span></a>Partial versus total Function</h2>
<p>It&rsquo;s recommended to use a <code>sealed</code> trait as the super type of the commands (incoming messages) of an actor as the compiler will emit a warning if a message type is forgotten in the pattern match.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L470-L473" target="_blank" title="Go to snippet source">source</a><code class="language-scala">sealed trait Command
case object Down extends Command
final case class GetValue(replyTo: ActorRef[Value]) extends Command
final case class Value(n: Int)</code></pre></dd>
</dl>
<p>That is the main reason for <code>Behaviors.receive</code>, <code>Behaviors.receiveMessage</code> taking a <code>Function</code> rather than a <code>PartialFunction</code>.</p>
<p>The compiler warning if <code>GetValue</code> is not handled would be:</p>
<pre><code>[warn] ... Counter.scala:45:34: match may not be exhaustive.
[warn] It would fail on the following input: GetValue(_)
[warn]         Behaviors.receiveMessage {
[warn]                                  ^
</code></pre>
<p>Note that a <code>MatchError</code> will be thrown at runtime if a message is not handled, so it&rsquo;s important to pay attention to those. If a <code>Behavior</code> should not handle certain messages you can still include them in the pattern match and return <code>Behaviors.unhandled</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L481-L489" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val zero: Behavior[Command] = {
  Behaviors.receiveMessage {
    case GetValue(replyTo) =&gt;
      replyTo ! Value(0)
      Behaviors.same
    case Down =&gt;
      Behaviors.unhandled
  }
}</code></pre></dd>
</dl>
<p>It&rsquo;s recommended to use the <code>sealed</code> trait and total functions with exhaustiveness check to detect mistakes of forgetting to handle some messages. Sometimes, that can be inconvenient and then you can use a <code>PartialFunction</code> with <code>Behaviors.receivePartial</code> or <code>Behaviors.receiveMessagePartial</code></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L495-L501" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val zero: Behavior[Command] = {
  Behaviors.receiveMessagePartial {
    case GetValue(replyTo) =&gt;
      replyTo ! Value(0)
      Behaviors.same
  }
}</code></pre></dd>
</dl></div><div class="group-scala">
<h2><a href="#how-to-compose-partial-functions" name="how-to-compose-partial-functions" class="anchor"><span class="anchor-link"></span></a>How to compose Partial Functions</h2>
<p>Following up from previous section, there are times when one might want to combine different <code>PartialFunction</code>s into one <code>Behavior</code>.</p>
<p>A good use case for composing two or more <code>PartialFunction</code>s is when there is a bit of behavior that repeats across different states of the Actor. Below, you can find a simplified example for this use case.</p>
<p>The Command definition is still highly recommended be kept within a <code>sealed</code> Trait:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L511-L514" target="_blank" title="Go to snippet source">source</a><code class="language-scala">sealed trait Command
case object Down extends Command
final case class GetValue(replyTo: ActorRef[Value]) extends Command
final case class Value(n: Int)</code></pre></dd>
</dl>
<p>In this particular case, the Behavior that is repeating over is the one in charge to handle the <code>GetValue</code> Command, as it behaves the same regardless of the Actor&rsquo;s internal state. Instead of defining the specific handlers as a <code>Behavior</code>, we can define them as a <code>PartialFunction</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L518-L522" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def getHandler(value: Int): PartialFunction[Command, Behavior[Command]] = {
  case GetValue(replyTo) =&gt;
    replyTo ! Value(value)
    Behaviors.same
}
def setHandlerNotZero(value: Int): PartialFunction[Command, Behavior[Command]] = {
  case Down =&gt;
    if (value == 1)
      zero
    else
      nonZero(value - 1)
}
def setHandlerZero(log: Logger): PartialFunction[Command, Behavior[Command]] = {
  case Down =&gt;
    log.error(&quot;Counter is already at zero!&quot;)
    Behaviors.same
}</code></pre></dd>
</dl>
<p>Finally, we can go on defining the two different behaviors for this specific actor. For each <code>Behavior</code> we would go and concatenate all needed <code>PartialFunction</code> instances with <code>orElse</code> to finally apply the command to the resulting one:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L544-L552" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val zero: Behavior[Command] = Behaviors.setup { context =&gt;
  Behaviors.receiveMessagePartial(getHandler(0).orElse(setHandlerZero(context.log)))
}

def nonZero(capacity: Int): Behavior[Command] =
  Behaviors.receiveMessagePartial(getHandler(capacity).orElse(setHandlerNotZero(capacity)))

// Default Initial Behavior for this actor
def apply(initialCapacity: Int): Behavior[Command] = nonZero(initialCapacity)</code></pre></dd>
</dl>
<p>Even though in this particular example we could use <code>receiveMessage</code> as we cover all cases, we use <code>receiveMessagePartial</code> instead to cover potential future unhandled message cases.</p></div><div class="group-scala">
<h2><a href="#ask-versus-" name="ask-versus-" class="anchor"><span class="anchor-link"></span></a>ask versus ?</h2>
<p>When using the <code>AskPattern</code> it&rsquo;s recommended to use the <code>ask</code> method rather than the infix <code>?</code> operator, like so:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L440-L447" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.typed.scaladsl.AskPattern._
import pekko.util.Timeout

implicit val timeout: Timeout = Timeout(3.seconds)
val counter: ActorRef[Command] = ???

val result: Future[OperationResult] = counter.ask(replyTo =&gt; Increment(delta = 2, replyTo))</code></pre></dd>
</dl>
<p>You may also use the more terse placeholder syntax <code>_</code> instead of <code>replyTo</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L451" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val result2: Future[OperationResult] = counter.ask(Increment(delta = 2, _))</code></pre></dd>
</dl>
<p>However, using the infix operator <code>?</code> with the placeholder syntax <code>_</code>, like is done in the following example, won&rsquo;t typecheck because of the binding scope rules for wildcard parameters:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L456-L457" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// doesn&#39;t compile
val result3: Future[OperationResult] = counter ? Increment(delta = 2, _)</code></pre></dd>
</dl>
<p>Adding the necessary parentheses (as shown below) makes it typecheck, but, subjectively, it&rsquo;s rather ugly so the recommendation is to use <code>ask</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L462" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val result3: Future[OperationResult] = counter ? (Increment(delta = 2, _))</code></pre></dd>
</dl>
<p>Note that <code>AskPattern</code> is only intended for request-response interaction from outside an actor. If the requester is inside an actor, prefer <code>ActorContext.ask</code> as it provides better thread-safety by not requiring the use of a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> inside the actor.</p></div><div class="group-java">
<h2><a href="#receivebuilder" name="receivebuilder" class="anchor"><span class="anchor-link"></span></a>ReceiveBuilder</h2>
<p>Using the <code>ReceiveBuilder</code> is the typical, and recommended, way of defining message handlers, but it can be good to know that it&rsquo;s optional in case you would prefer a different approach. Alternatives could be like:</p>
<ul>
  <li>direct processing because there is only one message type</li>
  <li>if or switch statements</li>
  <li>annotation processor</li>
  <li><a href="https://www.vavr.io/vavr-docs/#_pattern_matching">Vavr Pattern Matching DSL</a></li>
  <li>pattern matching since JDK 14 (<a href="https://openjdk.java.net/jeps/305">JEP 305</a>)</li>
</ul>
<p>In <code>Behaviors</code> there are <code>receive</code>, <code>receiveMessage</code> and <code>receiveSignal</code> factory methods that takes functions instead of using the <code>ReceiveBuilder</code>, which is the <code>receive</code> with the class parameter.</p>
<p>In <code>AbstractBehavior</code> you can return your own <code>org.apache.pekko.actor.typed.javadsl.Receive</code> from <code>createReceive</code> instead of using <code>newReceiveBuilder</code>. Implement the <code>receiveMessage</code> and <code>receiveSignal</code> in the <code>Receive</code> subclass.</p></div>
<h2><a href="#nesting-setup" name="nesting-setup" class="anchor"><span class="anchor-link"></span></a>Nesting setup</h2>
<p>When an actor behavior needs more than one of <code>setup</code>, <code>withTimers</code> and <code>withStash</code> the methods can be nested to access the needed dependencies:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L560-L572" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def apply(): Behavior[Command] =
  Behaviors.setup[Command](context =&gt;
    Behaviors.withStash(100)(stash =&gt;
      Behaviors.withTimers { timers =&gt;
        context.log.debug(&quot;Starting up&quot;)

        // behavior using context, stash and timers ...
      }))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L750-L765" target="_blank" title="Go to snippet source">source</a><code class="language-java">public static Behavior&lt;Command&gt; apply() {
  return Behaviors.setup(
      context -&gt;
          Behaviors.withStash(
              100,
              stash -&gt;
                  Behaviors.withTimers(
                      timers -&gt; {
                        context.getLog().debug(&quot;Starting up&quot;);

                        // behavior using context, stash and timers ...
                      })));
}</code></pre></dd>
</dl>
<p>The order of the nesting does not change the behavior as long as there is no additional logic in any other function than the innermost one. It can be nice to default to put <code>setup</code> outermost as that is the least likely block that will be removed if the actor logic changes. </p>
<p>Note that adding <code>supervise</code> to the mix is different as it will restart the behavior it wraps, but not the behavior around itself: </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/scala/docs/org/apache/pekko/typed/StyleGuideDocExamples.scala#L580-L596" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def apply(): Behavior[Command] =
  Behaviors.setup { context =&gt;
    // only run on initial actor start, not on crash-restart
    context.log.info(&quot;Starting&quot;)

    Behaviors
      .supervise(Behaviors.withStash[Command](100) { stash =&gt;
        // every time the actor crashes and restarts a new stash is created (previous stash is lost)
        context.log.debug(&quot;Starting up with stash&quot;)
        // Behaviors.receiveMessage { ... }
      })
      .onFailure[RuntimeException](SupervisorStrategy.restart)
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/actor-typed-tests/src/test/java/jdocs/org/apache/pekko/typed/StyleGuideDocExamples.java#L773-L793" target="_blank" title="Go to snippet source">source</a><code class="language-java">public static Behavior&lt;Command&gt; create() {
  return Behaviors.setup(
      context -&gt; {
        // only run on initial actor start, not on crash-restart
        context.getLog().info(&quot;Starting&quot;);

        return Behaviors.&lt;Command&gt;supervise(
                Behaviors.withStash(
                    100,
                    stash -&gt; {
                      // every time the actor crashes and restarts a new stash is created
                      // (previous stash is lost)
                      context.getLog().debug(&quot;Starting up with stash&quot;);
                      // Behaviors.receiveMessage { ... }
                    }))
            .onFailure(RuntimeException.class, SupervisorStrategy.restart());
      });
}</code></pre></dd>
</dl>
<h2><a href="#additional-naming-conventions" name="additional-naming-conventions" class="anchor"><span class="anchor-link"></span></a>Additional naming conventions</h2>
<p>Some naming conventions have already been mentioned in the context of other recommendations, but here is a list of additional conventions:</p>
<ul>
  <li>
  <p><code>replyTo</code> is the typical name for the <span class="group-scala"><code>ActorRef[Reply]</code></span><span class="group-java"><code>ActorRef&lt;Reply&gt;</code></span> parameter in  messages to which a reply or acknowledgement should be sent.</p></li>
  <li>
  <p>Incoming messages to an actor are typically called commands, and therefore the super type of all  messages that an actor can handle is typically <span class="group-scala"><code>sealed trait Command</code></span><span class="group-java"><code>interface Command {}</code></span>.</p></li>
  <li>
  <p>Use past tense for the events persisted by an <code>EventSourcedBehavior</code> since those represent facts that have happened,  for example <code>Incremented</code>.</p></li>
</ul>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/typed/style-guide.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
2.6.20+81-523134c3+20230202-1514*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../typed/coexisting.html" title="Coexistence" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Coexistence
</span>
</div>
</a>
<a href="../typed/from-classic.html" title="Learning Pekko Typed from Classic" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Learning Pekko Typed from Classic
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2023 The Apache Software Foundation, Licensed under the Apache License, Version 2.0
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script src="../assets/js/groups.js"></script>
</body>
</html>
